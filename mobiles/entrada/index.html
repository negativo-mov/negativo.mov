<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg0:#fbf4f8;
      --bg1:#f3f7ff;
      --ink:#1a1a1a;
      --mut:#45424a;
      --shadow: 0 18px 70px rgba(25,16,40,.16);
      --shadow2: 0 10px 36px rgba(25,16,40,.12);
      --radius: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(255,210,232,.75), transparent 55%),
        radial-gradient(1100px 900px at 85% 20%, rgba(207,226,255,.85), transparent 60%),
        radial-gradient(900px 900px at 30% 85%, rgba(215,255,232,.65), transparent 55%),
        radial-gradient(900px 900px at 80% 85%, rgba(217,199,255,.55), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }
    .wrap{ width:min(980px, calc(100% - 28px)); margin: 28px auto 140px; }
    .title{ margin: 8px 0 10px; font-size: 26px; letter-spacing: .2px; font-weight: 820; color: #120f17; }
    .lead{
      font-size: 16px; line-height: 1.55; color: var(--mut); white-space: pre-line;
      margin: 14px 0 22px; padding: 18px 18px; border-radius: var(--radius);
      background: rgba(255,255,255,.55); box-shadow: var(--shadow2);
      border: 1.5px solid rgba(20,10,30,.12); backdrop-filter: blur(6px);
    }
    .sig{
      display:inline-block; font-family: var(--mono); font-size: 12px;
      color: rgba(20,10,30,.64); background: rgba(255,255,255,.6);
      border: 1px solid rgba(20,10,30,.12); padding: 6px 10px; border-radius: 999px;
      margin: 10px 0 0;
    }
    .section{ margin: 28px 0; }
    .intro{
      white-space: pre-line; font-size: 15px; line-height: 1.55;
      color: rgba(15,10,22,.80); margin: 0 0 14px; padding: 14px 16px;
      border-radius: 18px; background: rgba(255,255,255,.50);
      border: 1.3px solid rgba(20,10,30,.10); box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
    }
    .scene{
      position: relative; border-radius: calc(var(--radius) + 8px);
      border: 1.6px solid rgba(20,10,30,.14);
      background: rgba(255,255,255,.42);
      box-shadow: var(--shadow);
      overflow:hidden;
      transform: translateZ(0);
    }
    .scene::after{
      content:""; position:absolute; inset:-14%;
      background:
        radial-gradient(700px 420px at 30% 20%, rgba(255,210,232,.22), transparent 60%),
        radial-gradient(820px 520px at 75% 35%, rgba(207,226,255,.22), transparent 65%),
        radial-gradient(900px 520px at 45% 85%, rgba(215,255,232,.18), transparent 65%);
      opacity:.95; mix-blend-mode:multiply;
      transform: translate3d(var(--bx,0px), var(--by,0px), 0) rotate(var(--br,0deg));
      transition: transform 820ms cubic-bezier(.2,.9,.2,1);
      pointer-events:none;
    }
    .scenePad{
      padding: 26px 22px 30px;
      position:relative; z-index:1;
      min-height: 320px;
    }
    .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding: 14px 16px; border-top: 1px solid rgba(20,10,30,.10);
      background: rgba(255,255,255,.40); backdrop-filter: blur(6px);
      position:relative; z-index:2;
    }
    button{
      font-family: var(--sans);
      font-weight: 720;
      letter-spacing:.2px;
      border-radius: 999px;
      padding: 10px 14px;
      border: 1.4px solid rgba(20,10,30,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.62));
      color: #140e1e;
      box-shadow: 0 10px 20px rgba(20,10,30,.10);
      cursor:pointer; user-select:none;
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0px); }
    button.small{ padding: 8px 12px; font-size: 13px; }
    button.ghost{ background: rgba(255,255,255,.35); box-shadow:none; }
    .hint{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(15,10,22,.65);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(20,10,30,.18);
      background: rgba(255,255,255,.35);
    }

    .frGrid3{ display:grid; grid-template-columns: repeat(3, 1fr); gap: 18px; align-items:end; }
    .frGrid7{ display:grid; grid-template-columns: repeat(7, 1fr); gap: 14px; }
    .frGrid5{ display:grid; grid-template-columns: repeat(5, 1fr); gap: 16px; }
    .fr2{ display:grid; grid-template-columns: 1.25fr .75fr; gap: 18px; align-items:end; }
    @media (max-width: 860px){
      .scenePad{ min-height: 290px; }
      .frGrid7{ grid-template-columns: repeat(4, 1fr); }
      .frGrid5{ grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 700px){
      .fr2{ grid-template-columns: 1fr; }
      .scenePad{ min-height: 260px; }
    }
    @media (max-width: 520px){
      .frGrid7{ grid-template-columns: repeat(3, 1fr); }
      .frGrid5{ grid-template-columns: repeat(2, 1fr); }
      .scenePad{ min-height: 240px; }
    }

    .frag{
      position: relative;
      border-radius: 18px;
      border: 2.2px solid rgba(20,10,30,.72);
      background: rgba(255,255,255,.40);
      box-shadow: 0 14px 32px rgba(20,10,30,.18);
      overflow:hidden;
      aspect-ratio: 1 / 1;
      display:flex;
      align-items:center;
      justify-content:center;
      transform: translate3d(var(--dx,0px), var(--dy,0px), 0) rotate(var(--dr,0deg)) scale(.92);
      transition:
        transform 760ms cubic-bezier(.18,.9,.18,1),
        box-shadow 260ms ease,
        outline 220ms ease;
      will-change: transform;
    }
    .frag .img{ width: 100%; height: 100%; object-fit: contain; background: rgba(255,255,255,.25); }
    .frag.clickable{ cursor:pointer; }
    .frag.clickable:hover{
      box-shadow: 0 18px 44px rgba(20,10,30,.22);
      outline: 3px solid rgba(255,255,255,.65);
      transform: translate3d(var(--dx,0px), calc(var(--dy,0px) - 3px), 0) rotate(var(--dr,0deg)) scale(.94);
    }
    .fragTag{
      position:absolute;
      left: 10px;
      top: 10px;
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(20,10,30,.14);
      color: rgba(20,10,30,.75);
      pointer-events:none;
    }

    .bg-crib::before,
    .bg-mountains::before,
    .bg-lab::before,
    .bg-stairs::before{
      content:""; position:absolute; inset:0; opacity:.85;
      pointer-events:none; mix-blend-mode: multiply;
    }
    .bg-crib::before{
      background:
        radial-gradient(420px 260px at 50% 20%, rgba(255,255,255,.85), transparent 60%),
        linear-gradient(180deg, rgba(255,210,232,.55), rgba(217,199,255,.25)),
        repeating-linear-gradient(90deg, rgba(20,10,30,.10) 0 2px, transparent 2px 12px);
    }
    .bg-mountains::before{
      background:
        linear-gradient(180deg, rgba(207,226,255,.55), rgba(255,243,218,.35)),
        radial-gradient(900px 450px at 40% 85%, rgba(180,255,207,.35), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='420' viewBox='0 0 1200 420'%3E%3Cpath d='M0 340 L170 230 L320 330 L500 190 L680 340 L860 210 L1020 340 L1200 250 L1200 420 L0 420 Z' fill='rgba(20,10,30,0.08)'/%3E%3Cpath d='M0 360 L150 280 L280 355 L460 240 L620 370 L780 260 L940 360 L1200 290 L1200 420 L0 420 Z' fill='rgba(20,10,30,0.06)'/%3E%3C/svg%3E");
      background-repeat:no-repeat;
      background-position:center bottom;
      background-size: cover;
    }
    .bg-lab::before{
      background:
        radial-gradient(700px 420px at 30% 20%, rgba(255,210,232,.35), transparent 60%),
        radial-gradient(700px 420px at 85% 30%, rgba(207,226,255,.35), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='700' viewBox='0 0 1200 700'%3E%3Cg fill='none' stroke='rgba(20,10,30,0.16)' stroke-width='5'%3E%3Cpath d='M80 120 H420 V260 H240 V400 H520 V560 H980'/%3E%3Cpath d='M160 80 H560 V200 H360 V320 H640 V460 H420 V620 H1120'/%3E%3Cpath d='M60 520 H280 V360 H120 V240 H320 V120 H980'/%3E%3C/g%3E%3C/svg%3E");
      background-size: cover;
      background-position:center;
    }
    .bg-stairs::before{
      background:
        radial-gradient(900px 520px at 50% 18%, rgba(255,243,218,.45), transparent 55%),
        radial-gradient(820px 520px at 35% 85%, rgba(217,199,255,.25), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='520' viewBox='0 0 1200 520'%3E%3Cg fill='none' stroke='rgba(20,10,30,0.16)' stroke-width='7'%3E%3Cpath d='M120 420 L260 340 L400 420 L540 340 L680 420 L820 340 L960 420'/%3E%3Cpath d='M220 130 L220 320 L360 240 L360 430'/%3E%3Cpath d='M620 90 L760 170 L620 250 L760 330 L620 410'/%3E%3Cpath d='M980 140 L860 220 L980 300 L860 380'/%3E%3C/g%3E%3C/svg%3E");
      background-size: cover;
      background-position:center;
    }

    .dyn{ padding: 0 18px 20px; position:relative; z-index:2; }
    .dyn p{ margin: 12px 0 0; color: rgba(20,10,30,.86); line-height: 1.6; font-size: 15px; }
    .dyn .small{ font-size: 13px; color: rgba(20,10,30,.70); }

    .tok{
      display:inline-block;
      padding: 0 2px;
      border-radius: 6px;
      transition: background .12s ease, outline .12s ease, transform .12s ease;
    }
    .tok.click{
      cursor:pointer;
      outline: 1.2px dashed rgba(20,10,30,.18);
      background: rgba(255,255,255,.35);
    }
    .tok.click:hover{
      background: rgba(255,255,255,.68);
      outline-color: rgba(20,10,30,.30);
      transform: translateY(-1px);
    }
    .tok.verb{
      font-weight: 820;
      outline: 2px solid rgba(20,10,30,.65);
      background: rgba(255,255,255,.72);
    }

    .finalWrap{ margin-top: 16px; padding: 18px; }
    .constellation{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-top: 14px;
    }
    @media (max-width: 860px){ .constellation{ grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 520px){ .constellation{ grid-template-columns: repeat(2, 1fr); } }

    .note{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(20,10,30,.65);
      margin-top: 12px;
      white-space: pre-line;
    }

    .flash{ animation: flash .22s ease-in-out 1; }
    @keyframes flash{
      0%{ filter: saturate(1); }
      50%{ filter: saturate(1.7) contrast(1.05); }
      100%{ filter: saturate(1); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">MÓBILES — entrada</div>

    <div class="lead">
Operas aqui a tua própria curadoria.
A artista é suiornotsui.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.
Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto —
aquilo que nunca aparece —
sustenta o desejo de continuar.</div>

    <div class="sig">suiornotsui</div>

    <!-- M1 -->
    <div class="section" id="m1">
      <div class="intro">
Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.</div>

      <div class="scene bg-crib" id="scene_m1">
        <div class="scenePad frGrid3" id="m1_frags"></div>
        <div class="dyn"><p id="m1_text"></p></div>
        <div class="controls">
          <button id="btn_m1">Tensionar o início</button>
          <button class="small ghost" id="btn_share_m1">Partilhar Móbile 1</button>
          <span class="hint">M1: só este botão opera.</span>
        </div>
      </div>
    </div>

    <!-- M2 -->
    <div class="section" id="m2">
      <div class="intro">
Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.</div>

      <div class="scene bg-mountains" id="scene_m2">
        <div class="scenePad fr2" id="m2_frags"></div>
        <div class="dyn">
          <p id="m2_text"></p>
          <p class="small">M2: fragmentos só invertem frente↔fundo e sujeito↔objeto. O verbo muda apenas o objeto (e o fragmento do objeto).</p>
        </div>
        <div class="controls">
          <button class="small ghost" id="btn_share_m2">Partilhar Móbile 2</button>
          <span class="hint">M2: só fragmentos + verbo.</span>
        </div>
      </div>
    </div>

    <!-- M3 -->
    <div class="section" id="m3">
      <div class="intro">
O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.</div>

      <div class="scene bg-lab" id="scene_m3">
        <div class="scenePad frGrid7" id="m3_frags"></div>
        <div class="dyn">
          <p id="m3_text"></p>
          <p class="small">M3: clique local (palavra ou fragmento) reforça o traço daquele item, com espraiamento e decaimento.</p>
        </div>
        <div class="controls">
          <button class="small ghost" id="btn_share_m3">Partilhar Móbile 3</button>
          <span class="hint">M3: só palavras + fragmentos.</span>
        </div>
      </div>
    </div>

    <!-- M4 -->
    <div class="section" id="m4">
      <div class="intro">
Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.</div>

      <div class="scene bg-stairs" id="scene_m4">
        <div class="scenePad frGrid5" id="m4_frags"></div>
        <div class="dyn">
          <p id="m4_text"></p>
          <p class="small">M4: só palavras. O som domina o texto até colapsar.</p>
        </div>
        <div class="controls">
          <button class="small ghost" id="btn_share_m4">Partilhar Móbile 4</button>
          <span class="hint">M4: só palavras.</span>
        </div>
      </div>
    </div>

    <!-- Final -->
    <div class="section" id="final">
      <div class="intro">
O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.</div>

      <div class="scene" id="scene_final">
        <div class="finalWrap">
          <button id="btn_generate">Gerar a minha exposição</button>
          <button class="small ghost" id="btn_share_final" style="display:none;">Partilhar resultado</button>

          <div id="final_out" style="display:none;">
            <div class="constellation" id="final_frags"></div>
            <div class="dyn">
              <p id="final_style"></p>
              <p id="final_crit"></p>
              <div class="note" id="final_call"></div>
            </div>
          </div>
        </div>

        <div class="controls">
          <span class="hint">Para ver outros percursos: faz primeiro a tua curadoria.</span>
        </div>
      </div>
    </div>
  </div>

<script>
/* paths */
const PATH_SUI_JSON = "../sui.json";
const PATH_PREFIX_FROM_ENTRADA = "../";

/* util */
const AXES = ["corte","fluxo","densidade","rarefacao","centro_instavel","contorno","ritmo","memoria","tensao","presenca","emergencia","cuidado"];
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function pick(a){ return a[Math.floor(Math.random()*a.length)]; }

/* pluralização (boa o bastante p/ nosso léxico fechado) */
function pluralPT(word){
  if(!word) return word;
  const w = word.trim();
  if(w.includes(" ")) return w;       // não mexe em locuções
  if(w.includes("-")) return w;       // não mexe em hifenizados
  if(w.endsWith("ões") || w.endsWith("ães")) return w;
  if(w.endsWith("ão")) return w.slice(0,-2) + "ões";
  if(w.endsWith("s")) return w;
  if(w.endsWith("z")) return w + "es";
  if(w.endsWith("r")) return w + "es";
  if(w.endsWith("l")) return w.slice(0,-1) + "is";
  if(w.endsWith("m")) return w.slice(0,-1) + "ns";
  if(w.endsWith("a")) return w + "s";
  if(w.endsWith("o")) return w.slice(0,-1) + "os";
  if(w.endsWith("e")) return w + "s";
  return w + "s";
}
function maybePluralize(text, on=true){
  return on ? pluralPT(text) : text;
}

/* state */
const state = {
  tick: 0,
  axes: Object.fromEntries(AXES.map(k=>[k, 0.33])),
  phono: { surda:0.33, sonora:0.33, fricativa:0.33 },
  phonoTarget: "surda",

  suiMap: null,
  suiUrl: null,
  forceSui: (Math.random() < 0.90),
  suiPlaced: { m1:false, m3:false, m4:false, final:false },

  m1: { clicks:0, slots:[12,53,71] },

  m2: {
    frontSlot: 18,
    backSlot: 66,
    swapped: false,
    verbIndex: 0,
    subj: null,
    obj: null
  },

  m3: { slots:[], clicks:0 },
  m4: { slots:[], clicks:0 },

  final: { hash:"", slots:[], styleText:"", critText:"", shareText:"" }
};

function axisWeight(axis){ return clamp(state.axes[axis], 0.02, 0.98); }

function applyImpulse(axis, strength){
  const s = clamp(strength, -1, 1);
  state.axes[axis] = clamp(state.axes[axis] + s*0.10, 0.02, 0.98);

  if(axis==="corte"){ state.axes["fluxo"]=clamp(state.axes["fluxo"]-s*0.05,0.02,0.98); }
  if(axis==="fluxo"){ state.axes["corte"]=clamp(state.axes["corte"]-s*0.05,0.02,0.98); }
  if(axis==="densidade"){ state.axes["rarefacao"]=clamp(state.axes["rarefacao"]-s*0.05,0.02,0.98); }
  if(axis==="rarefacao"){ state.axes["densidade"]=clamp(state.axes["densidade"]-s*0.05,0.02,0.98); }

  state.tick++;
}

function applyPhonoImpulse(kind, strength){
  const s = clamp(strength, 0, 1);
  state.phono[kind] = clamp(state.phono[kind] + s*0.16, 0.02, 0.98);
  for(const k of ["surda","sonora","fricativa"]){
    if(k!==kind) state.phono[k] = clamp(state.phono[k] - s*0.07, 0.02, 0.98);
  }
  let best="surda", bestV=-1;
  for(const k of ["surda","sonora","fricativa"]){
    if(state.phono[k] > bestV){ bestV = state.phono[k]; best=k; }
  }
  state.phonoTarget = best;
  state.tick++;
}

/* lexicon (vinco no lugar de prega) */
const LEX = [
  { op:"vestigio", axis:["memoria","presenca"], surda:"traço", sonora:"marca", fricativa:"sombra" },
  { op:"sopro", axis:["fluxo","rarefacao"], surda:"pingo", sonora:"bafo", fricativa:"suspiro" },
  { op:"dobra", axis:["contorno","fluxo"], surda:"vinco", sonora:"curva", fricativa:"flexão" },
  { op:"canto", axis:["contorno","corte"], surda:"quina", sonora:"beira", fricativa:"franja" },
  { op:"margem", axis:["contorno","tensao"], surda:"limite", sonora:"borda", fricativa:"fronteira" },
  { op:"poeira", axis:["rarefacao","memoria"], surda:"pó", sonora:"bruma", fricativa:"cinza" },
  { op:"silencio", axis:["rarefacao","cuidado"], surda:"pausa", sonora:"calma", fricativa:"sussurro" },
  { op:"rastro", axis:["memoria","ritmo"], surda:"pegada", sonora:"vesta", fricativa:"resíduo" },
  { op:"fragmento", axis:["corte","memoria"], surda:"cortezinho", sonora:"bordado", fricativa:"desfiado" },
  { op:"detalhe", axis:["cuidado","presenca"], surda:"ponto", sonora:"miolo", fricativa:"nuança" },
  { op:"lembranca", axis:["memoria","presenca"], surda:"nota", sonora:"memória", fricativa:"recordação" },
  { op:"demora_n", axis:["ritmo","cuidado"], surda:"pausa", sonora:"espera", fricativa:"suspensão" },
  { op:"intervalo", axis:["corte","rarefacao"], surda:"corte", sonora:"entre", fricativa:"fresta" },
  { op:"eco", axis:["ritmo","presenca"], surda:"toque", sonora:"resposta", fricativa:"ressonância" },
  { op:"resto", axis:["memoria","tensao"], surda:"ruga", sonora:"sobra", fricativa:"resíduo" },
  { op:"plano", axis:["presenca","contorno"], surda:"linha", sonora:"base", fricativa:"superfície" },
  { op:"camada", axis:["densidade","presenca"], surda:"capa", sonora:"nível", fricativa:"espessura" },
  { op:"textura", axis:["densidade","cuidado"], surda:"trama", sonora:"tecido", fricativa:"fibra" },
  { op:"superficie", axis:["presenca","contorno"], surda:"pele", sonora:"face", fricativa:"película" },
  { op:"escala", axis:["tensao","presenca"], surda:"passo", sonora:"medida", fricativa:"proporção" },
  { op:"ritmo", axis:["ritmo","fluxo"], surda:"pulso", sonora:"cadência", fricativa:"fluência" },
  { op:"materia", axis:["densidade","presenca"], surda:"corpo", sonora:"substância", fricativa:"massa" },
  { op:"presenca", axis:["presenca","tensao"], surda:"toque", sonora:"vulto", fricativa:"sombra" },
  { op:"tensao", axis:["tensao","corte"], surda:"nó", sonora:"peso", fricativa:"pressão" },
  { op:"campo", axis:["presenca","fluxo"], surda:"plano", sonora:"território", fricativa:"ambiente" },
  { op:"emergencia", axis:["emergencia","tensao"], surda:"salto", sonora:"aparição", fricativa:"insurgência" },
  { op:"config", axis:["presenca","contorno"], surda:"forma", sonora:"estrutura", fricativa:"composição" },
  { op:"cessacao", axis:["corte","rarefacao"], surda:"corte", sonora:"encerramento", fricativa:"silenciamento" },

  { op:"aproximar", axis:["cuidado","presenca"], surda:"chegar", sonora:"beirar", fricativa:"esfumar" },
  { op:"reparar", axis:["cuidado","centro_instavel"], surda:"notar", sonora:"observar", fricativa:"esmiuçar" },
  { op:"tocar", axis:["presenca","cuidado"], surda:"tatear", sonora:"roçar", fricativa:"aflorar" },
  { op:"escutar", axis:["cuidado","ritmo"], surda:"ouvir", sonora:"acolher", fricativa:"sintonizar" },
  { op:"demorar_v", axis:["ritmo","cuidado"], surda:"parar", sonora:"permanecer", fricativa:"alongar-se" },
  { op:"pousar", axis:["rarefacao","fluxo"], surda:"cair", sonora:"assentar", fricativa:"deslizar" },
  { op:"acompanhar", axis:["fluxo","cuidado"], surda:"seguir", sonora:"amparar", fricativa:"entrelaçar" },
  { op:"cuidar", axis:["cuidado","presenca"], surda:"zelar", sonora:"nutrir", fricativa:"suavizar" },
  { op:"recortar", axis:["corte","contorno"], surda:"cortar", sonora:"delimitar", fricativa:"fissurar" },
  { op:"deslocar", axis:["centro_instavel","fluxo"], surda:"mover", sonora:"transferir", fricativa:"deslizar" },
  { op:"sustentar", axis:["densidade","presenca"], surda:"segurar", sonora:"manter", fricativa:"suspender" },
  { op:"distribuir", axis:["ritmo","presenca"], surda:"partir", sonora:"organizar", fricativa:"espalhar" },
  { op:"sobrepor", axis:["densidade","fluxo"], surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir" },
  { op:"atravessar", axis:["fluxo","centro_instavel"], surda:"passar", sonora:"cruzar", fricativa:"permeiar" },
  { op:"insinuar", axis:["centro_instavel","presenca"], surda:"sugerir", sonora:"indicar", fricativa:"sussurrar" },
  { op:"insistir", axis:["tensao","ritmo"], surda:"bater", sonora:"persistir", fricativa:"ressoar" },
  { op:"interromper", axis:["corte","rarefacao"], surda:"cortar", sonora:"cessar", fricativa:"esvair-se" },
  { op:"fixar", axis:["contorno","densidade"], surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar" },
  { op:"suspender_v", axis:["rarefacao","tensao"], surda:"parar", sonora:"reter", fricativa:"flutuar" },
  { op:"reter", axis:["memoria","densidade"], surda:"prender", sonora:"guardar", fricativa:"conservar" },
  { op:"abandonar", axis:["rarefacao","corte"], surda:"largar", sonora:"deixar", fricativa:"dissolver" },
  { op:"transformar", axis:["emergencia","centro_instavel"], surda:"romper", sonora:"converter", fricativa:"transfigurar" },

  { op:"leve", axis:["rarefacao","fluxo"], surda:"claro", sonora:"brando", fricativa:"suave" },
  { op:"minimo", axis:["rarefacao","cuidado"], surda:"curto", sonora:"pequeno", fricativa:"sutil" },
  { op:"fragil", axis:["rarefacao","tensao"], surda:"ténue", sonora:"delicado", fricativa:"sensível" },
  { op:"tenue", axis:["rarefacao","contorno"], surda:"fino", sonora:"delgado", fricativa:"esfumado" },
  { op:"quase_adj", axis:["centro_instavel","tensao"], surda:"breve", sonora:"próximo", fricativa:"difuso" },
  { op:"opaco", axis:["densidade","corte"], surda:"denso", sonora:"turvo", fricativa:"fosco" },
  { op:"poroso", axis:["fluxo","centro_instavel"], surda:"aberto", sonora:"vazado", fricativa:"permeável" },
  { op:"irregular", axis:["centro_instavel","tensao"], surda:"torto", sonora:"oscilante", fricativa:"assimétrico" },
  { op:"difuso_adj", axis:["centro_instavel","rarefacao"], surda:"solto", sonora:"amplo", fricativa:"disperso" },
  { op:"latente", axis:["memoria","emergencia"], surda:"oculto", sonora:"presente", fricativa:"subjacente" },
  { op:"instavel", axis:["centro_instavel","tensao"], surda:"quebrado", sonora:"oscilante", fricativa:"flutuante" },
  { op:"provisorio", axis:["emergencia","fluxo"], surda:"breve", sonora:"mutável", fricativa:"transitório" },

  { op:"ainda", axis:["emergencia","tensao"], surda:"já", sonora:"agora", fricativa:"sempre" },
  { op:"quase_adv", axis:["centro_instavel","tensao"], surda:"logo", sonora:"perto", fricativa:"talvez" },
  { op:"lentamente", axis:["ritmo","cuidado"], surda:"aos poucos", sonora:"com calma", fricativa:"suavemente" },
  { op:"por_vezes", axis:["centro_instavel","ritmo"], surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente" },
  { op:"sempre", axis:["ritmo","tensao"], surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente" },
  { op:"raramente", axis:["rarefacao","memoria"], surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente" },
  { op:"talvez", axis:["centro_instavel","emergencia"], surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente" },
  { op:"agora", axis:["presenca","tensao"], surda:"já", sonora:"neste momento", fricativa:"presentemente" }
];

const byOp = Object.fromEntries(LEX.map(x=>[x.op,x]));
function axesOf(op){ return byOp[op]?.axis || ["presenca"]; }
function surfaceOf(op, kind){
  const o = byOp[op]; if(!o) return op;
  return o[kind] || o.surda || o.sonora || o.fricativa || op;
}

const OPS = {
  subst: LEX.slice(0, 28).map(x=>x.op),
  verb:  LEX.slice(28, 50).map(x=>x.op),
  adj:   LEX.slice(50, 62).map(x=>x.op),
  adv:   LEX.slice(62, 70).map(x=>x.op),
};

function weightedPick(ops){
  const weights = ops.map(op=>{
    const ax = axesOf(op);
    let w = 0.01;
    for(const a of ax) w += axisWeight(a);
    return w;
  });
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<ops.length;i++){
    r -= weights[i];
    if(r<=0) return ops[i];
  }
  return ops[ops.length-1];
}

function chooseSurface(op, mode){
  let kind = state.phonoTarget;

  if(mode==="semantic"){
    const s = state.axes.corte;
    const f = state.axes.fluxo + state.axes.rarefacao*0.6;
    const t = state.axes.tensao + state.axes.emergencia*0.5;
    const tot = s+f+t;
    const r = Math.random()*tot;
    if(r < s) kind="surda";
    else if(r < s+t) kind="sonora";
    else kind="fricativa";
  }

  if(mode==="phono"){
    const sum = state.phono.surda + state.phono.sonora + state.phono.fricativa;
    const r = Math.random()*sum;
    if(r < state.phono.surda) kind="surda";
    else if(r < state.phono.surda + state.phono.sonora) kind="sonora";
    else kind="fricativa";
  }

  return surfaceOf(op, kind);
}

/* visual families */
const FAMILIES = [
  { name:"F1",  range:[1,10],   axis:["fluxo","presenca"] },
  { name:"F2",  range:[11,20],  axis:["corte","tensao"] },
  { name:"F3",  range:[21,30],  axis:["centro_instavel","fluxo"] },
  { name:"F4",  range:[31,40],  axis:["ritmo","memoria"] },
  { name:"F5",  range:[41,50],  axis:["corte","centro_instavel"] },
  { name:"F6",  range:[51,60],  axis:["densidade","presenca"] },
  { name:"F7",  range:[61,70],  axis:["rarefacao","cuidado"] },
  { name:"F8",  range:[71,80],  axis:["centro_instavel","tensao"] },
  { name:"F9",  range:[81,90],  axis:["rarefacao","contorno"] },
  { name:"F10", range:[91,100], axis:["tensao","emergencia"] },
  { name:"F11", range:[101,110],axis:["contorno","presenca"] },
  { name:"F12", range:[111,120],axis:["densidade","corte"] },
];
function familyOfSlot(slot){
  for(const f of FAMILIES){
    if(slot>=f.range[0] && slot<=f.range[1]) return f;
  }
  return FAMILIES[0];
}

function selectSlotByAxes(){
  const famScores = FAMILIES.map(f=>{
    let s = 0.01;
    for(const a of f.axis) s += axisWeight(a);
    if(state.phonoTarget==="surda") s *= (f.axis.includes("corte")?1.18:0.94);
    if(state.phonoTarget==="fricativa") s *= ((f.axis.includes("fluxo")||f.axis.includes("rarefacao"))?1.18:0.94);
    if(state.phonoTarget==="sonora") s *= ((f.axis.includes("tensao")||f.axis.includes("emergencia"))?1.18:0.94);
    return s;
  });
  const sum = famScores.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  let fam = FAMILIES[0];
  for(let i=0;i<FAMILIES.length;i++){
    r -= famScores[i];
    if(r<=0){ fam = FAMILIES[i]; break; }
  }
  const [a,b] = fam.range;
  return a + Math.floor(Math.random()*(b-a+1));
}

/* fragment svg */
function makeFragmentSVG(slot){
  const f = familyOfSlot(slot);
  const a = f.axis;
  const cut = a.includes("corte") ? 1 : 0;
  const flow = a.includes("fluxo") ? 1 : 0;
  const dense = a.includes("densidade") ? 1 : 0;
  const rare = a.includes("rarefacao") ? 1 : 0;
  const center = a.includes("centro_instavel") ? 1 : 0;
  const edge = a.includes("contorno") ? 1 : 0;
  const rhythm = a.includes("ritmo") ? 1 : 0;
  const mem = a.includes("memoria") ? 1 : 0;
  const tens = a.includes("tensao") ? 1 : 0;
  const emer = a.includes("emergencia") ? 1 : 0;
  const care = a.includes("cuidado") ? 1 : 0;

  const hueBase = (slot * 17) % 360;
  const hue2 = (hueBase + 110) % 360;
  const sat = 35 + (dense*20) + (tens*12);
  const light = 86 - (dense*18) + (rare*6);

  const strokes = edge ? 3 : 2;
  const cutLines = cut ? 6 : 2;
  const blobs = dense ? 7 : 3;
  const mist = rare ? 0.22 : 0.10;

  const seed = slot * 99991;
  function pr(n){ return (Math.sin(seed + n*12.9898) * 43758.5453) % 1; }

  const shapes = [];
  shapes.push(`<rect x="0" y="0" width="100" height="100" fill="hsla(${hueBase},${sat}%,${light}%,0.95)"/>`);
  shapes.push(`<rect x="0" y="0" width="100" height="100" fill="hsla(${hue2},${sat-10}%,${light-6}%,${mist})"/>`);

  for(let i=0;i<cutLines;i++){
    const x1 = (pr(i+1)*100).toFixed(2);
    const y1 = (pr(i+2)*100).toFixed(2);
    const x2 = (pr(i+3)*100).toFixed(2);
    const y2 = (pr(i+4)*100).toFixed(2);
    const w = (1.2 + pr(i+5)*2.8 + (cut?1.2:0)).toFixed(2);
    const op = (0.18 + pr(i+6)*0.22 + (cut?0.12:0) - (rare?0.05:0)).toFixed(2);
    const dash = flow ? `${(6+pr(i+7)*10).toFixed(1)} ${(4+pr(i+8)*10).toFixed(1)}` : "0 0";
    shapes.push(`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(20,10,30,${op})" stroke-width="${w}" stroke-linecap="round" stroke-dasharray="${dash}"/>`);
  }

  for(let i=0;i<blobs;i++){
    const cx = (10 + pr(50+i)*80).toFixed(2);
    const cy = (10 + pr(70+i)*80).toFixed(2);
    const r  = (6 + pr(90+i)*18 + (dense?6:0) - (rare?3:0)).toFixed(2);
    const op = (0.10 + pr(110+i)*0.18 + (dense?0.12:0) - (rare?0.05:0)).toFixed(2);
    shapes.push(`<circle cx="${cx}" cy="${cy}" r="${r}" fill="rgba(20,10,30,${op})"/>`);
  }

  if(mem){
    for(let i=0;i<24;i++){
      const x = (pr(200+i)*100).toFixed(2);
      const y = (pr(230+i)*100).toFixed(2);
      const op = (0.06 + pr(260+i)*0.12).toFixed(2);
      shapes.push(`<circle cx="${x}" cy="${y}" r="${(0.6 + pr(290+i)*1.2).toFixed(2)}" fill="rgba(20,10,30,${op})"/>`);
    }
  }

  if(emer){
    shapes.push(`<path d="M${20+pr(401)*60} ${30+pr(402)*40} L${35+pr(403)*50} ${20+pr(404)*30} L${60+pr(405)*30} ${38+pr(406)*40}"
      stroke="rgba(20,10,30,0.22)" stroke-width="3.2" fill="none" stroke-linecap="round"/>`);
  }

  if(care){
    shapes.push(`<circle cx="50" cy="50" r="38" fill="none" stroke="rgba(255,255,255,0.35)" stroke-width="5"/>`);
  }

  if(rhythm){
    shapes.push(`<rect x="6" y="6" width="88" height="88" rx="16" ry="16"
      fill="none" stroke="rgba(20,10,30,0.20)" stroke-width="${strokes}"/>`);
  } else if(edge){
    shapes.push(`<rect x="7" y="7" width="86" height="86" rx="14" ry="14"
      fill="none" stroke="rgba(20,10,30,0.18)" stroke-width="${strokes}"/>`);
  }

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 100 100">
  ${shapes.join("\n  ")}
</svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

function getFragmentURL(slot){
  if(slot === 53 && state.suiUrl) return state.suiUrl;
  return makeFragmentSVG(slot);
}

/* movimento tensivo */
function driftScene(sceneId, amount=16){
  const el = document.getElementById(sceneId);
  if(!el) return;
  const dx = (Math.random()*2-1)*amount;
  const dy = (Math.random()*2-1)*amount;
  const dr = (Math.random()*2-1)*(amount/16);
  el.style.setProperty("--bx", dx.toFixed(1)+"px");
  el.style.setProperty("--by", dy.toFixed(1)+"px");
  el.style.setProperty("--br", dr.toFixed(2)+"deg");
}
function driftFrag(el, amount=14){
  const dx = (Math.random()*2-1)*amount;
  const dy = (Math.random()*2-1)*amount;
  const dr = (Math.random()*2-1)*(amount/22);
  el.style.setProperty("--dx", dx.toFixed(1)+"px");
  el.style.setProperty("--dy", dy.toFixed(1)+"px");
  el.style.setProperty("--dr", dr.toFixed(2)+"deg");
}
function driftAllFrags(containerId, amount=14){
  const c = document.getElementById(containerId);
  if(!c) return;
  c.querySelectorAll(".frag").forEach(el=>driftFrag(el, amount));
}
function flash(el){
  if(!el) return;
  el.classList.remove("flash"); void el.offsetWidth; el.classList.add("flash");
}

/* tokens */
function token(op, text, clickable=true, extraClass=""){
  const cls = ["tok", clickable?"click":"", extraClass].filter(Boolean).join(" ");
  const safe = text.replace(/</g,"&lt;").replace(/>/g,"&gt;");
  return `<span class="${cls}" data-op="${op}">${safe}</span>`;
}

/* frases */
function m1_generateText(){
  const sub = weightedPick(OPS.subst);
  const verb = weightedPick(OPS.verb);
  const obj = weightedPick(OPS.subst);
  const adv = weightedPick(OPS.adv);
  const t1 = chooseSurface(sub,"semantic");
  const t2 = `${chooseSurface(verb,"semantic")}-${chooseSurface(obj,"semantic")}`; // substantivação com hífen (Caio)
  const t3 = chooseSurface(adv,"semantic");
  return `No começo, ${t1} aparece como eixo — e isso já inclina o campo. O que nasce aqui é um ${t2}, ${t3}. O resto não some: fica como toque à espera de outra tensão. Se o campo endurece, não é ruído: é corte em formação.`;
}

/* ========= M3 (NOVO: frase robusta, plural, sem ridículo) =========
   - sujeitos fixos no plural
   - variáveis pluralizadas (quando são uma palavra só)
   - adjetivo sempre entra como "em modo X" (sem concordância)
   - infinitivos sempre sustentados por verbos conjugados
*/
function renderM3Sentence(){
  const mode = "semantic";
  const adv1 = chooseSurface(weightedPick(OPS.adv), mode);
  const adv2 = chooseSurface(weightedPick(OPS.adv), mode);

  const subA = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subB = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subC = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subD = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);

  const v1 = chooseSurface(weightedPick(OPS.verb), mode);
  const v2 = chooseSurface(weightedPick(OPS.verb), mode);
  const v3 = chooseSurface(weightedPick(OPS.verb), mode);

  const adjMode = chooseSurface(weightedPick(OPS.adj), mode);

  const parts = [
    "<span class='tok'>No</span> <span class='tok'>campo,</span>",
    `<span class="tok">${adv1}</span><span class='tok'>,</span>`,
    "<span class='tok'>vestígios</span> <span class='tok'>e</span> <span class='tok'>margens</span>",
    "<span class='tok'>permitem</span>",
    token("v1", v1, true),
    token("subA", subA, true),
    "<span class='tok'>;</span>",
    "<span class='tok'>gestos</span> <span class='tok'>em</span> <span class='tok'>modo</span>",
    token("adjMode", adjMode, true),
    "<span class='tok'>deixam</span>",
    token("v2", v2, true),
    token("subB", subB, true),
    "<span class='tok'>;</span>",
    "<span class='tok'>ritmos</span> <span class='tok'>e</span> <span class='tok'>camadas</span>",
    "<span class='tok'>levam</span> <span class='tok'>a</span>",
    token("v3", v3, true),
    token("subC", subC, true),
    "<span class='tok'>—</span>",
    `<span class="tok">${adv2}</span><span class='tok'>,</span>`,
    "<span class='tok'>até</span> <span class='tok'>que</span>",
    "<span class='tok'>restos</span>",
    "<span class='tok'>voltam</span> <span class='tok'>a</span>",
    token("v4", chooseSurface(weightedPick(OPS.verb), mode), true),
    token("subD", subD, true),
    "<span class='tok'>.</span>"
  ];
  return parts.join(" ");
}

/* ========= M4 (NOVO: poético por som, sem dizer regime) =========
   - muita superfície trocável por phono
   - sujeitos fixos no plural
   - variáveis pluralizadas quando cabível
*/
function renderM4Sentence(){
  const mode = "phono";

  const adv1 = chooseSurface(weightedPick(OPS.adv), mode);
  const adv2 = chooseSurface(weightedPick(OPS.adv), mode);

  const subA = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subB = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subC = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);
  const subD = maybePluralize(chooseSurface(weightedPick(OPS.subst), mode), true);

  const v1 = chooseSurface(weightedPick(OPS.verb), mode);
  const v2 = chooseSurface(weightedPick(OPS.verb), mode);
  const v3 = chooseSurface(weightedPick(OPS.verb), mode);

  const adjMode = chooseSurface(weightedPick(OPS.adj), mode);

  const parts = [
    "<span class='tok'>No</span> <span class='tok'>limite,</span>",
    "<span class='tok'>corpos</span> <span class='tok'>e</span> <span class='tok'>regimes</span>",
    "<span class='tok'>em</span> <span class='tok'>modo</span>",
    token("adjMode4", adjMode, true),
    "<span class='tok'>deixam</span>",
    token("v1", v1, true),
    token("subA", subA, true),
    "<span class='tok'>em</span>",
    token("subB", subB, true),
    "<span class='tok'>;</span>",
    `<span class="tok">${adv1}</span><span class='tok'>,</span>`,
    "<span class='tok'>cortes</span> <span class='tok'>e</span> <span class='tok'>passagens</span>",
    "<span class='tok'>fazem</span>",
    token("v2", v2, true),
    token("subC", subC, true),
    "<span class='tok'>;</span>",
    `<span class="tok">${adv2}</span><span class='tok'>,</span>`,
    "<span class='tok'>ecos</span> <span class='tok'>e</span> <span class='tok'>restos</span>",
    "<span class='tok'>levam</span> <span class='tok'>a</span>",
    token("v3", v3, true),
    token("subD", subD, true),
    "<span class='tok'>—</span>",
    "<span class='tok'>até</span> <span class='tok'>que</span>",
    "<span class='tok'>tudo</span> <span class='tok'>cede</span><span class='tok'>.</span>"
  ];
  return parts.join(" ");
}

/* M2 — clusters congelados */
function buildFrozenCluster(){
  const core = weightedPick(OPS.subst);
  const wantAdj = Math.random() < (0.28 + 0.30*state.axes.densidade);
  const wantAdv = Math.random() < (0.22 + 0.28*state.axes.rarefacao + 0.16*state.axes.ritmo);
  const pieces = [];
  pieces.push({op:core, text: chooseSurface(core, "semantic")});
  if(wantAdj){
    const adj = weightedPick(OPS.adj);
    pieces.push({op:"modo", text:"modo"});
    pieces.push({op:adj, text: chooseSurface(adj, "semantic")});
  }
  if(wantAdv){
    const adv = weightedPick(OPS.adv);
    pieces.push({op:adv, text: chooseSurface(adv, "semantic")});
  }
  return pieces;
}
function renderFrozenCluster(cluster){
  return cluster.map(p=>`<span class="tok">${p.text}</span>`).join(" ");
}

const M2_VERB_POOL = ["sustentar","recortar","aproximar","insinuar","distribuir","atravessar","fixar","transformar","interromper","acompanhar"];
function autoVerbFor(){
  const sC = state.axes.corte;
  const sF = state.axes.fluxo;
  const sD = state.axes.densidade;
  const sE = state.axes.emergencia;
  return (sC > sF && sC > sD) ? pick(["recortar","interromper"]) :
         (sF > sD && sF > sC) ? pick(["atravessar","acompanhar"]) :
         (sE > 0.55) ? "transformar" :
         pick(["sustentar","fixar","insinuar","distribuir"]);
}

/* fragment div */
function fragDiv(slot, clickable, tagPrefix){
  const d = document.createElement("div");
  d.className = "frag" + (clickable ? " clickable" : "");
  d.dataset.slot = slot;

  const img = document.createElement("img");
  img.className = "img";
  img.alt = `fragmento ${slot}`;
  img.crossOrigin = "anonymous";
  img.src = getFragmentURL(slot);

  const tag = document.createElement("div");
  tag.className = "fragTag";
  const fam = familyOfSlot(slot).name;
  tag.textContent = `${tagPrefix} · ${fam} · ${slot}`;

  d.appendChild(img);
  d.appendChild(tag);

  driftFrag(d, 18);
  return d;
}

/* SUI loader */
async function loadSui(){
  try{
    const res = await fetch(PATH_SUI_JSON, { cache:"no-store" });
    if(!res.ok) throw new Error("Falha ao carregar sui.json");
    const data = await res.json();
    state.suiMap = data;
    const p = data["53"] || data[53];
    if(p){
      state.suiUrl = PATH_PREFIX_FROM_ENTRADA + String(p).replace(/^\/+/,"");
    }else{
      state.suiUrl = PATH_PREFIX_FROM_ENTRADA + "assets/sui/slot_053.jpg";
    }
  }catch(e){
    state.suiUrl = PATH_PREFIX_FROM_ENTRADA + "assets/sui/slot_053.jpg";
  }
}

/* Sui guarantee helper */
function ensureSuiInSlots(slots, markKey){
  if(!state.forceSui || !state.suiUrl) return slots;
  if(slots.includes(53)){ state.suiPlaced[markKey]=true; return slots; }
  if(!state.suiPlaced[markKey]){
    slots[Math.floor(Math.random()*slots.length)] = 53;
    state.suiPlaced[markKey]=true;
  }
  return slots;
}

/* M1 */
function m1_tension(){
  state.m1.clicks++;
  const axes = pick([["corte","tensao"],["fluxo","cuidado"],["densidade","presenca"],["rarefacao","centro_instavel"],["emergencia","memoria"]]);
  for(const a of axes) applyImpulse(a, +1);
  applyPhonoImpulse(pick(["surda","sonora","fricativa"]), 0.35);

  let slots = [selectSlotByAxes(), selectSlotByAxes(), selectSlotByAxes()];
  slots = ensureSuiInSlots(slots, "m1");
  state.m1.slots = slots;
}

/* M2 interactions */
function m2_swapByFragments(){
  state.m2.swapped = !state.m2.swapped;
  const t = state.m2.frontSlot;
  state.m2.frontSlot = state.m2.backSlot;
  state.m2.backSlot = t;

  const tmp = state.m2.subj;
  state.m2.subj = state.m2.obj;
  state.m2.obj = tmp;

  familyOfSlot(state.m2.frontSlot).axis.forEach(a=>applyImpulse(a, 0.55));
}

function m2_cycleVerbAndObject(){
  state.m2.verbIndex = (state.m2.verbIndex + 1) % M2_VERB_POOL.length;

  applyImpulse("emergencia", 0.55);
  applyImpulse("centro_instavel", 0.22);

  state.m2.obj = buildFrozenCluster();

  const newSlot = selectSlotByAxes();
  if(state.m2.swapped){
    state.m2.frontSlot = newSlot;
  }else{
    state.m2.backSlot = newSlot;
  }
}

/* renderers */
function m1_render(){
  driftScene("scene_m1", 18);
  const wrap = document.getElementById("m1_frags");
  wrap.innerHTML = "";
  state.m1.slots.forEach(slot=>{
    const el = fragDiv(slot, false, "m1");
    wrap.appendChild(el);
  });
  document.getElementById("m1_text").textContent = m1_generateText();
  driftAllFrags("m1_frags", 18);
}

function m2_render(){
  driftScene("scene_m2", 16);
  const wrap = document.getElementById("m2_frags");
  wrap.innerHTML = "";

  const front = fragDiv(state.m2.frontSlot, true, "m2");
  const back  = fragDiv(state.m2.backSlot, true, "m2");

  front.addEventListener("click", ()=>{
    m2_swapByFragments();
    rerenderAll(true);
  });
  back.addEventListener("click", ()=>{
    m2_swapByFragments();
    rerenderAll(true);
  });

  wrap.appendChild(front);
  wrap.appendChild(back);

  const verbAuto = autoVerbFor();
  const verbChosen = (state.m2.verbIndex % 2 === 0) ? verbAuto : M2_VERB_POOL[state.m2.verbIndex];

  const module1HTML = renderFrozenCluster(state.m2.subj);
  const verbHTML = `<span class="tok click verb" data-verb="1">${chooseSurface(verbChosen,"semantic")}</span>`;
  const module3HTML = renderFrozenCluster(state.m2.obj);

  const tEl = document.getElementById("m2_text");
  tEl.innerHTML = `${module1HTML} ${verbHTML} ${module3HTML}.`;

  const vTok = tEl.querySelector("[data-verb='1']");
  if(vTok){
    vTok.addEventListener("click",(e)=>{
      e.stopPropagation();
      m2_cycleVerbAndObject();
      rerenderAll(true);
    });
  }

  driftAllFrags("m2_frags", 18);
}

function m3_render(){
  driftScene("scene_m3", 16);

  if(state.m3.slots.length !== 7){
    state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
    state.m3.slots = ensureSuiInSlots(state.m3.slots, "m3");
  }else{
    const driftChance = 0.10 + 0.20*state.axes.centro_instavel;
    for(let i=0;i<state.m3.slots.length;i++){
      if(Math.random()<driftChance*0.12) state.m3.slots[i] = selectSlotByAxes();
    }
    state.m3.slots = ensureSuiInSlots(state.m3.slots, "m3");
  }

  const wrap = document.getElementById("m3_frags");
  wrap.innerHTML = "";
  state.m3.slots.forEach(slot=>{
    const el = fragDiv(slot, true, "m3");
    el.addEventListener("click", ()=>{
      const fam = familyOfSlot(slot);
      fam.axis.forEach(a=>applyImpulse(a, 0.90));
      state.m3.clicks++;

      if(state.m3.clicks >= 9){
        state.m3.clicks = 0;
        applyImpulse("emergencia", 1.0);
        applyImpulse("tensao", 0.7);
        state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
        state.m3.slots = ensureSuiInSlots(state.m3.slots, "m3");
        flash(document.getElementById("scene_m3"));
      }
      rerenderAll(true);
    });
    wrap.appendChild(el);
  });

  const tEl = document.getElementById("m3_text");
  tEl.innerHTML = renderM3Sentence();

  tEl.querySelectorAll(".tok.click[data-op]").forEach(span=>{
    span.addEventListener("click", (e)=>{
      e.stopPropagation();
      const op = span.getAttribute("data-op");
      axesOf(op).forEach(a=>applyImpulse(a, 0.95));
      state.m3.clicks++;

      if(state.m3.clicks >= 9){
        state.m3.clicks = 0;
        applyImpulse("emergencia", 1.0);
        applyImpulse("tensao", 0.7);
        state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
        state.m3.slots = ensureSuiInSlots(state.m3.slots, "m3");
        flash(document.getElementById("scene_m3"));
      }
      rerenderAll(true);
    });
  });

  driftAllFrags("m3_frags", 18);
}

function m4_render(){
  driftScene("scene_m4", 16);

  if(state.m4.slots.length !== 5){
    state.m4.slots = Array.from({length:5}, ()=>selectSlotByAxes());
    state.m4.slots = ensureSuiInSlots(state.m4.slots, "m4");
  }else{
    for(let i=0;i<state.m4.slots.length;i++){
      if(Math.random()<0.05) state.m4.slots[i] = selectSlotByAxes();
    }
    state.m4.slots = ensureSuiInSlots(state.m4.slots, "m4");
  }

  const wrap = document.getElementById("m4_frags");
  wrap.innerHTML = "";
  state.m4.slots.forEach(slot=>{
    wrap.appendChild(fragDiv(slot, false, "m4"));
  });

  const tEl = document.getElementById("m4_text");
  tEl.innerHTML = renderM4Sentence();

  tEl.querySelectorAll(".tok.click[data-op]").forEach(span=>{
    span.addEventListener("click",(e)=>{
      e.stopPropagation();
      const op = span.getAttribute("data-op");
      const ax = axesOf(op);

      let kind = state.phonoTarget;
      if(ax.includes("corte")) kind = "surda";
      else if(ax.includes("tensao") || ax.includes("emergencia")) kind = "sonora";
      else if(ax.includes("fluxo") || ax.includes("rarefacao")) kind = "fricativa";

      applyPhonoImpulse(kind, 0.95);

      if(kind==="surda"){ applyImpulse("corte", 0.80); applyImpulse("contorno", 0.25); }
      if(kind==="sonora"){ applyImpulse("tensao", 0.80); applyImpulse("emergencia", 0.35); }
      if(kind==="fricativa"){ applyImpulse("fluxo", 0.80); applyImpulse("rarefacao", 0.35); }

      state.m4.clicks++;
      if(state.m4.clicks >= 12){
        state.m4.clicks = 0;
        const order = ["surda","sonora","fricativa"];
        const idx = order.indexOf(state.phonoTarget);
        const next = order[(idx+1)%order.length];
        state.phonoTarget = next;
        state.phono[next] = 0.92;
        for(const k of order){ if(k!==next) state.phono[k] = 0.12; }

        state.m4.slots = Array.from({length:5}, ()=>selectSlotByAxes());
        state.m4.slots = ensureSuiInSlots(state.m4.slots, "m4");
        flash(document.getElementById("scene_m4"));
      }

      rerenderAll(true);
    });
  });

  driftAllFrags("m4_frags", 18);
}

/* FINAL determinístico */
function computeStateHash(){
  const a = AXES.map(k=>state.axes[k].toFixed(3)).join(",");
  const p = ["surda","sonora","fricativa"].map(k=>state.phono[k].toFixed(3)).join(",");
  const l = [
    state.m1.clicks,
    state.m2.frontSlot, state.m2.backSlot, state.m2.swapped?1:0, state.m2.verbIndex,
    JSON.stringify(state.m2.subj||[]),
    JSON.stringify(state.m2.obj||[]),
    state.m3.slots.join("-"),
    state.m4.slots.join("-"),
    state.phonoTarget
  ].join("|");
  return `${a}__${p}__${l}`;
}
function seededRng(seedStr){
  let h = 2166136261 >>> 0;
  for(let i=0;i<seedStr.length;i++){
    h ^= seedStr.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return function(){
    h += 0x6D2B79F5;
    let t = Math.imul(h ^ (h >>> 15), 1 | h);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}
function axisLabel(a){
  const map = {
    corte: "corte e decisão",
    fluxo: "passagens e continuidade",
    densidade: "densidade contida",
    rarefacao: "rarefação e respiro",
    centro_instavel: "centro instável",
    contorno: "contorno e margem",
    ritmo: "ritmo de insistência",
    memoria: "memória e vestígio",
    tensao: "tensão e peso",
    presenca: "presença táctil",
    emergencia: "emergência",
    cuidado: "cuidado de aproximação",
  };
  return map[a] || a;
}
function selectSlotByAxesSeeded(R){
  const famScores = FAMILIES.map(f=>{
    let s = 0.01;
    for(const a of f.axis) s += axisWeight(a);
    if(state.phonoTarget==="surda") s *= (f.axis.includes("corte")?1.18:0.94);
    if(state.phonoTarget==="fricativa") s *= ((f.axis.includes("fluxo")||f.axis.includes("rarefacao"))?1.18:0.94);
    if(state.phonoTarget==="sonora") s *= ((f.axis.includes("tensao")||f.axis.includes("emergencia"))?1.18:0.94);
    return s;
  });
  const sum = famScores.reduce((a,b)=>a+b,0);
  let r = R()*sum;
  let fam = FAMILIES[0];
  for(let i=0;i<FAMILIES.length;i++){
    r -= famScores[i];
    if(r<=0){ fam = FAMILIES[i]; break; }
  }
  const [a,b] = fam.range;
  return a + Math.floor(R()*(b-a+1));
}
function buildCritiqueText(){
  const domAxes = AXES.slice().sort((a,b)=>state.axes[b]-state.axes[a]).slice(0,2);
  const ph = state.phonoTarget;
  const phText = (ph==="surda") ? "corte seco" : (ph==="sonora") ? "ruptura sonora" : "passagem fricativa";

  const v = chooseSurface(weightedPick(OPS.verb), "phono");
  const sub = maybePluralize(chooseSurface(weightedPick(OPS.subst), "phono"), true);
  const obj = maybePluralize(chooseSurface(weightedPick(OPS.subst), "phono"), true);
  const adv = chooseSurface(weightedPick(OPS.adv), "phono");
  const adj = chooseSurface(weightedPick(OPS.adj), "phono");

  return `A exposição não fecha um tema: instala um regime de olhar. Entre ${axisLabel(domAxes[0])} e ${axisLabel(domAxes[1])}, um corpo em modo ${adj} faz a linguagem tender a ${phText}. ${adv}, vestígios permitem ${v} ${sub} em ${obj} — e o resto insiste como condição de reentrada.`;
}
function renderFinal(){
  driftScene("scene_final", 16);
  const out = document.getElementById("final_out");
  const grid = document.getElementById("final_frags");
  grid.innerHTML = "";
  state.final.slots.forEach(slot=>{
    grid.appendChild(fragDiv(slot, false, "expo"));
  });

  document.getElementById("final_style").textContent = state.final.styleText;
  document.getElementById("final_crit").textContent  = state.final.critText;
  document.getElementById("final_call").textContent =
`Partilha a tua exposição — e chama outras pessoas para verem o que tu não conseguiste alcançar.
Para descobrir outras constelações, é preciso antes arriscar a tua própria curadoria.`;

  out.style.display = "block";
  document.getElementById("btn_share_final").style.display = "inline-block";
}
function generateFinal(){
  const hash = computeStateHash();
  if(state.final.hash === hash && state.final.slots.length===10) return;

  const R = seededRng(hash);
  const slots = [];
  for(let i=0;i<10;i++) slots.push(selectSlotByAxesSeeded(R));

  if(state.forceSui && state.suiUrl && !slots.includes(53)){
    slots[Math.floor(R()*10)] = 53;
  }

  const domAxes = AXES.slice().sort((a,b)=>state.axes[b]-state.axes[a]).slice(0,3);
  const ph = state.phonoTarget;
  const phText = (ph==="surda") ? "corte seco" : (ph==="sonora") ? "ruptura sonora" : "passagem fricativa";

  const style = `O teu estilo curatorial inclina-se para ${axisLabel(domAxes[0])}, com ${axisLabel(domAxes[1])} e um resto de ${axisLabel(domAxes[2])}. Predomina um corpo sonoro de ${phText}, que reorganiza a presença e a ausência no campo.`;
  const crit = buildCritiqueText();

  const shareText =
`Eu gerei a minha curadoria possível em MÓBILES (suiornotsui).
O que apareceu para mim não é “o todo”: é um recorte.
E o resto — o que não consegui alcançar — continua a operar.

Faz a tua:
${location.href}`;

  state.final.hash = hash;
  state.final.slots = slots;
  state.final.styleText = style;
  state.final.critText = crit;
  state.final.shareText = shareText;

  renderFinal();
}

/* ========= PARTILHA: imagem + texto + link ========= */
function buildShareText(kind){
  const base = `MÓBILES (suiornotsui) — ${kind}\n\nFaz a tua curadoria e vê o que aparece (e o que fica de fora).\n${location.href}`;
  if(kind==="Exposição final" && state.final.shareText) return state.final.shareText;
  return base;
}

async function makeSceneImage(sceneKey){
  // sceneKey: "m1"|"m2"|"m3"|"m4"|"final"
  // desenha grade simples com os fragmentos atuais, num canvas exportável.
  const cfg = {
    m1: { slots: state.m1.slots.slice(), cols: 3, title: "Móbile 1" },
    m2: { slots: [state.m2.frontSlot, state.m2.backSlot], cols: 2, title: "Móbile 2" },
    m3: { slots: state.m3.slots.slice(), cols: 4, title: "Móbile 3" },
    m4: { slots: state.m4.slots.slice(), cols: 3, title: "Móbile 4" },
    final: { slots: state.final.slots.slice(), cols: 5, title: "Exposição final" }
  }[sceneKey];

  const W = 1080, H = 1350;
  const pad = 70;
  const headerH = 150;
  const gap = 22;

  const canvas = document.createElement("canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d");

  // fundo
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.fillRect(0,0,W,H);

  // título
  ctx.fillStyle = "rgba(20,10,30,0.92)";
  ctx.font = "700 46px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(cfg.title, pad, 78);

  ctx.fillStyle = "rgba(20,10,30,0.60)";
  ctx.font = "500 24px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
  ctx.fillText("suiornotsui — NEGATIVO.mov", pad, 118);

  const slots = cfg.slots.filter(Boolean);
  const cols = cfg.cols;
  const rows = Math.ceil(slots.length / cols);

  const availW = W - pad*2;
  const availH = H - pad - headerH - 90;
  const cellW = Math.floor((availW - gap*(cols-1)) / cols);
  const cellH = Math.floor((availH - gap*(rows-1)) / rows);
  const size = Math.min(cellW, cellH);

  // carrega imagens e desenha
  async function loadImg(src){
    return new Promise((resolve,reject)=>{
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.onload = ()=>resolve(im);
      im.onerror = ()=>resolve(null);
      im.src = src;
    });
  }

  for(let i=0;i<slots.length;i++){
    const slot = slots[i];
    const col = i % cols;
    const row = Math.floor(i / cols);

    const x = pad + col*(size+gap);
    const y = headerH + pad + row*(size+gap);

    // moldura
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.strokeStyle = "rgba(20,10,30,0.78)";
    ctx.lineWidth = 8;
    roundRect(ctx, x, y, size, size, 26);
    ctx.fill();
    ctx.stroke();

    const img = await loadImg(getFragmentURL(slot));
    if(img){
      // contain
      const iw = img.width, ih = img.height;
      const scale = Math.min((size-18)/iw, (size-18)/ih);
      const dw = iw*scale, dh = ih*scale;
      const ix = x + (size-dw)/2;
      const iy = y + (size-dh)/2;
      ctx.drawImage(img, ix, iy, dw, dh);
    }

    // tag
    ctx.fillStyle = "rgba(20,10,30,0.72)";
    ctx.font = "600 20px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
    ctx.fillText(`#${slot}`, x+16, y+32);
  }

  // rodapé link
  ctx.fillStyle = "rgba(20,10,30,0.70)";
  ctx.font = "500 22px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(location.href, pad, H-40);

  return canvas;
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

async function shareWithImage(sceneKey){
  const kind = (sceneKey==="final") ? "Exposição final" : `Móbile ${sceneKey.replace("m","")}`;
  const text = buildShareText(kind);

  const canvas = await makeSceneImage(sceneKey);
  const blob = await new Promise(res=>canvas.toBlob(res, "image/png", 0.95));
  if(!blob){ return shareTextOnly(text); }

  const file = new File([blob], `mobiles_${sceneKey}.png`, { type:"image/png" });

  if(navigator.share && navigator.canShare && navigator.canShare({ files:[file] })){
    try{
      await navigator.share({ text, files:[file] });
      return;
    }catch(e){
      // fallback abaixo
    }
  }

  // fallback: copia texto + abre imagem em nova aba
  try{
    await navigator.clipboard.writeText(text);
  }catch(e){}
  const url = URL.createObjectURL(blob);
  window.open(url, "_blank");
  alert("Texto copiado. A imagem abriu numa nova aba (se o share nativo não estiver disponível).");
}

async function shareTextOnly(text){
  if(navigator.share){
    try{ await navigator.share({ text, url: location.href }); return; }catch(e){}
  }
  try{ await navigator.clipboard.writeText(text); alert("Texto copiado."); }
  catch(e){ prompt("Copia o texto:", text); }
}

/* rerender */
function rerenderAll(withDrift=false){
  m1_render();
  m2_render();
  m3_render();
  m4_render();

  if(withDrift){
    driftScene("scene_m1", 18); driftAllFrags("m1_frags", 20);
    driftScene("scene_m2", 16); driftAllFrags("m2_frags", 20);
    driftScene("scene_m3", 16); driftAllFrags("m3_frags", 20);
    driftScene("scene_m4", 16); driftAllFrags("m4_frags", 20);
  }

  const h = computeStateHash();
  if(state.final.hash && state.final.hash !== h){
    document.getElementById("btn_share_final").style.display = "none";
  }
}

/* init */
async function init(){
  await loadSui();

  state.m1.slots = [selectSlotByAxes(), selectSlotByAxes(), selectSlotByAxes()];
  if(state.forceSui && state.suiUrl){
    state.m1.slots[1] = 53;
    state.suiPlaced.m1 = true;
  }

  state.m2.frontSlot = selectSlotByAxes();
  state.m2.backSlot = selectSlotByAxes();
  state.m2.subj = buildFrozenCluster();
  state.m2.obj  = buildFrozenCluster();

  if(state.forceSui && state.suiUrl && Math.random()<0.25){
    if(Math.random()<0.5) state.m2.frontSlot = 53; else state.m2.backSlot = 53;
  }

  rerenderAll(true);

  document.getElementById("btn_m1").addEventListener("click", ()=>{
    m1_tension();
    rerenderAll(true);
  });

  document.getElementById("btn_generate").addEventListener("click", ()=>{
    generateFinal();
  });

  document.getElementById("btn_share_m1").addEventListener("click", ()=>shareWithImage("m1"));
  document.getElementById("btn_share_m2").addEventListener("click", ()=>shareWithImage("m2"));
  document.getElementById("btn_share_m3").addEventListener("click", ()=>shareWithImage("m3"));
  document.getElementById("btn_share_m4").addEventListener("click", ()=>shareWithImage("m4"));

  document.getElementById("btn_share_final").addEventListener("click", ()=>{
    shareWithImage("final");
  });
}

init();
</script>
</body>
</html>
