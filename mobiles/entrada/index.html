<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg1:#f6f1f7;
      --bg2:#eef6f6;
      --ink:#1b1b1f;
      --muted:#4b4b57;
      --card:#ffffffcc;
      --stroke:#15151a22;
      --stroke2:#15151a44;
      --accent:#ff4fd822;
      --accent2:#38ffd422;
      --shadow: 0 16px 42px rgba(15,15,20,.10);
      --r: 18px;
      --pad: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1100px 600px at 12% 10%, #ffd7ef55 0%, transparent 60%),
        radial-gradient(900px 600px at 85% 22%, #c8fff555 0%, transparent 55%),
        radial-gradient(1200px 800px at 50% 80%, #d9d2ff44 0%, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 28px 16px 90px;
    }

    .lead{
      font-size: 16px;
      line-height: 1.55;
      color: var(--muted);
      margin: 6px 0 18px;
      white-space: pre-line;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 18px;
      margin: 14px 0 24px;
      overflow: hidden;
    }

    .title{
      margin: 0 0 8px;
      font-weight: 650;
      letter-spacing:.2px;
      font-size: 18px;
    }

    .intro{
      margin: 10px 0 14px;
      color: #2b2b35;
      line-height: 1.55;
      white-space: pre-line;
    }

    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 10px;
    }

    button{
      appearance: none;
      border: 1px solid var(--stroke2);
      background: #fff;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 600;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(10,10,20,.08);
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0px); }

    .canvasWrap{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background:
        radial-gradient(700px 260px at 30% 30%, var(--accent) 0%, transparent 55%),
        radial-gradient(900px 330px at 75% 50%, var(--accent2) 0%, transparent 55%),
        linear-gradient(180deg,#ffffffaa,#ffffff55);
      overflow:hidden;
    }

    canvas{
      width: 100%;
      height: auto;
      display:block;
    }

    .gen{
      margin-top: 12px;
      line-height: 1.62;
      color:#1e1e25;
      font-size: 15px;
    }

    .gen .w{
      cursor: pointer;
      border-radius: 8px;
      padding: 0 4px;
      margin: 0 1px;
      display:inline-block;
    }
    .gen .w:hover{
      background: #00000008;
      outline: 1px solid #00000010;
    }
    .gen .w:active{
      background: #00000012;
    }

    .hint{
      font-size: 13px;
      color: #535362;
      margin-top: 6px;
    }

    .finalBox{
      margin-top: 14px;
      padding: 14px;
      border-radius: 14px;
      border: 1px dashed var(--stroke2);
      background: #ffffff99;
    }

    .small{
      font-size: 13px;
      color: #4f4f5f;
      line-height: 1.5;
      white-space: pre-line;
    }

    .copy{
      font-family: var(--mono);
      font-size: 12px;
      color: #2f2f3b;
      background:#ffffffaa;
      border: 1px solid var(--stroke);
      padding: 10px;
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      margin-top: 10px;
    }

    .ok{
      display:inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid #2a7a3a33;
      background:#2a7a3a12;
      color:#2a7a3a;
      font-weight:700;
      font-size: 12px;
      margin-left: 8px;
    }

    .warn{
      display:inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid #a36b0a33;
      background:#a36b0a12;
      color:#7a5205;
      font-weight:700;
      font-size: 12px;
      margin-left: 8px;
    }
  </style>
</head>
<body>
<div class="wrap">

  <h1 class="title">MÓBILES — operar curadoria (entrada)</h1>
  <div class="lead">Operas aqui a tua própria curadoria.
A artista é <b>suiornotsui</b>.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.

Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto — aquilo que nunca aparece — sustenta o desejo de continuar.</div>

  <!-- M1 -->
  <section class="card" id="m1">
    <div class="intro">Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.</div>

    <div class="canvasWrap">
      <canvas id="c1" width="940" height="340"></canvas>
    </div>

    <div class="row">
      <button id="b1">Tensionar o início</button>
      <button id="s1">Partilhar este móbile</button>
      <span id="suiState" class="warn" title="Tentaremos carregar a imagem da Sui; se falhar, seguimos com fallback.">Sui: a carregar…</span>
    </div>

    <div class="gen" id="t1"></div>
    <div class="hint">Aqui só este botão opera. Cada clique muda o ponto de partida do campo (e inclina os outros móbiles).</div>
  </section>

  <!-- M2 -->
  <section class="card" id="m2">
    <div class="intro">Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.</div>

    <div class="canvasWrap">
      <canvas id="c2" width="940" height="320"></canvas>
    </div>

    <div class="row">
      <button id="s2">Partilhar este móbile</button>
    </div>

    <div class="gen" id="t2"></div>
    <div class="hint">Neste móbile: clicar nos fragmentos apenas inverte frente↔fundo (e sujeito↔objeto). Clicar no verbo muda o objeto e abre outra saída.</div>
  </section>

  <!-- M3 -->
  <section class="card" id="m3">
    <div class="intro">O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.</div>

    <div class="canvasWrap">
      <canvas id="c3" width="940" height="360"></canvas>
    </div>

    <div class="row">
      <button id="s3">Partilhar este móbile</button>
    </div>

    <div class="gen" id="t3"></div>
    <div class="hint">Aqui: clicar numa palavra reforça o eixo dessa palavra. Clicar num fragmento reforça a família tensiva do slot (F1–F12). O espraiamento é regulado, não aleatório.</div>
  </section>

  <!-- M4 -->
  <section class="card" id="m4">
    <div class="intro">Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.</div>

    <div class="canvasWrap">
      <canvas id="c4" width="940" height="340"></canvas>
    </div>

    <div class="row">
      <button id="s4">Partilhar este móbile</button>
    </div>

    <div class="gen" id="t4"></div>
    <div class="hint">Aqui: só palavras são clicáveis. O som (surda/sonora/fricativa) domina progressivamente o texto — até colapsar.</div>
  </section>

  <!-- Final -->
  <section class="card" id="final">
    <div class="intro">O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.</div>

    <div class="row">
      <button id="genFinal">Gerar a minha exposição</button>
      <button id="shareFinal" style="display:none;">Partilhar a minha exposição</button>
    </div>

    <div class="finalBox" id="finalBox" style="display:none;">
      <div class="canvasWrap">
        <canvas id="cf" width="940" height="420"></canvas>
      </div>
      <div class="gen" id="tf"></div>
      <div class="small" style="margin-top:10px;">Para ver os demais estados expositivos da semana, faz primeiro a tua curadoria (gera a tua expo).</div>
      <div class="copy" id="shareText" style="display:none;"></div>
    </div>
  </section>

</div>

<script>
(() => {
  "use strict";

  // -------------------------------
  // Helpers: deterministic RNG
  // -------------------------------
  function mulberry32(a){
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }
  function hashStr(s){
    let h = 2166136261 >>> 0;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // -------------------------------
  // Axes (semantic/tensive)
  // -------------------------------
  const AXES = [
    "continuity","cut","oblique","repetition","rupture","density","rarefaction","center","neutral","conflict","contour","mass",
    "memory","care","presence","tension","emergence","configuration","cessation","rhythm","surface","texture"
  ];

  // families F1..F12 → axes weights
  const FAMILY_AXES = {
    F1:{continuity:1, presence:.2},
    F2:{cut:1, contour:.4},
    F3:{oblique:1, tension:.3},
    F4:{repetition:1, memory:.4, rhythm:.3},
    F5:{rupture:1, cut:.5},
    F6:{density:1, mass:.4, texture:.3},
    F7:{rarefaction:1, continuity:.3},
    F8:{center:1, tension:.3},
    F9:{neutral:1, surface:.2},
    F10:{conflict:1, oblique:.3},
    F11:{contour:1, cut:.3},
    F12:{mass:1, density:.4}
  };

  // slot → family (your schema: 1–10 F1, 11–20 F2, ... 111–120 F12)
  function familyForSlot(slot){
    const s = clamp(slot,1,120);
    const idx = Math.floor((s-1)/10) + 1; // 1..12
    return "F" + idx;
  }

  // -------------------------------
  // Lexicon: (70 operators × 3 realizations)
  // Each operator has: key, pos, baseAxes[], variants {surda,sonora,fricativa}
  // -------------------------------
  // NOTE: "prega" -> "vinco"
  const LEX = [
    {key:"vestígio", pos:"N", axes:["memory","presence"], v:{surda:"traço", sonora:"marca", fricativa:"sombra"}},
    {key:"sopro", pos:"N", axes:["rarefaction","continuity"], v:{surda:"pingo", sonora:"bafo", fricativa:"suspiro"}},
    {key:"dobra", pos:"N", axes:["texture","contour"], v:{surda:"vinco", sonora:"curva", fricativa:"flexão"}},
    {key:"canto", pos:"N", axes:["contour","cut"], v:{surda:"quina", sonora:"beira", fricativa:"franja"}},
    {key:"margem", pos:"N", axes:["contour","configuration"], v:{surda:"limite", sonora:"borda", fricativa:"fronteira"}},
    {key:"poeira", pos:"N", axes:["memory","rarefaction"], v:{surda:"pó", sonora:"bruma", fricativa:"cinza"}},
    {key:"silêncio", pos:"N", axes:["rarefaction","cessation"], v:{surda:"pausa", sonora:"calma", fricativa:"sussurro"}},
    {key:"rastro", pos:"N", axes:["memory","repetition"], v:{surda:"pegada", sonora:"vesta", fricativa:"resíduo"}},
    {key:"fragmento", pos:"N", axes:["cut","texture"], v:{surda:"cortezinho", sonora:"bordado", fricativa:"desfiado"}},
    {key:"detalhe", pos:"N", axes:["care","surface"], v:{surda:"ponto", sonora:"miolo", fricativa:"nuança"}},

    {key:"lembrança", pos:"N", axes:["memory"], v:{surda:"nota", sonora:"memória", fricativa:"recordação"}},
    {key:"demora", pos:"N", axes:["continuity","care"], v:{surda:"pausa", sonora:"espera", fricativa:"suspensão"}},
    {key:"intervalo", pos:"N", axes:["cut","rarefaction"], v:{surda:"corte", sonora:"entre", fricativa:"fresta"}},
    {key:"eco", pos:"N", axes:["repetition","presence"], v:{surda:"toque", sonora:"resposta", fricativa:"ressonância"}},
    {key:"resto", pos:"N", axes:["memory","emergence"], v:{surda:"ruga", sonora:"sobra", fricativa:"resíduo"}},

    {key:"plano", pos:"N", axes:["surface","configuration"], v:{surda:"linha", sonora:"base", fricativa:"superfície"}},
    {key:"camada", pos:"N", axes:["density","texture"], v:{surda:"capa", sonora:"nível", fricativa:"espessura"}},
    {key:"textura", pos:"N", axes:["texture","density"], v:{surda:"trama", sonora:"tecido", fricativa:"fibra"}},
    {key:"superfície", pos:"N", axes:["surface","presence"], v:{surda:"pele", sonora:"face", fricativa:"película"}},
    {key:"escala", pos:"N", axes:["configuration","tension"], v:{surda:"passo", sonora:"medida", fricativa:"proporção"}},
    {key:"ritmo", pos:"N", axes:["rhythm","repetition"], v:{surda:"pulso", sonora:"cadência", fricativa:"fluência"}},
    {key:"matéria", pos:"N", axes:["mass","density"], v:{surda:"corpo", sonora:"substância", fricativa:"massa"}},

    {key:"presença", pos:"N", axes:["presence"], v:{surda:"toque", sonora:"vulto", fricativa:"sombra"}},
    {key:"tensão", pos:"N", axes:["tension","conflict"], v:{surda:"nó", sonora:"peso", fricativa:"pressão"}},
    {key:"campo", pos:"N", axes:["configuration","presence"], v:{surda:"plano", sonora:"território", fricativa:"ambiente"}},
    {key:"emergência", pos:"N", axes:["emergence"], v:{surda:"salto", sonora:"aparição", fricativa:"insurgência"}},
    {key:"configuração", pos:"N", axes:["configuration"], v:{surda:"forma", sonora:"estrutura", fricativa:"composição"}},
    {key:"cessação", pos:"N", axes:["cessation","cut"], v:{surda:"corte", sonora:"encerramento", fricativa:"silenciamento"}},

    // VERBS (infinitive, we will wrap with "um" or "um gesto:" or "a fazer" etc)
    {key:"aproximar", pos:"V", axes:["care","presence"], v:{surda:"chegar", sonora:"beirar", fricativa:"esfumar"}},
    {key:"reparar", pos:"V", axes:["care","center"], v:{surda:"notar", sonora:"observar", fricativa:"esmiuçar"}},
    {key:"tocar", pos:"V", axes:["presence","surface"], v:{surda:"tatear", sonora:"roçar", fricativa:"aflorar"}},
    {key:"escutar", pos:"V", axes:["care","rarefaction"], v:{surda:"ouvir", sonora:"acolher", fricativa:"sintonizar"}},
    {key:"demorar(v)", pos:"V", axes:["continuity","care"], v:{surda:"parar", sonora:"permanecer", fricativa:"alongar-se"}},
    {key:"pousar", pos:"V", axes:["continuity","surface"], v:{surda:"cair", sonora:"assentar", fricativa:"deslizar"}},
    {key:"acompanhar", pos:"V", axes:["continuity","repetition"], v:{surda:"seguir", sonora:"amparar", fricativa:"entrelaçar"}},
    {key:"cuidar", pos:"V", axes:["care"], v:{surda:"zelar", sonora:"nutrir", fricativa:"suavizar"}},

    {key:"recortar", pos:"V", axes:["cut","contour"], v:{surda:"cortar", sonora:"delimitar", fricativa:"fissurar"}},
    {key:"deslocar", pos:"V", axes:["oblique","configuration"], v:{surda:"mover", sonora:"transferir", fricativa:"deslizar"}},
    {key:"sustentar", pos:"V", axes:["continuity","presence"], v:{surda:"segurar", sonora:"manter", fricativa:"suspender"}},
    {key:"distribuir", pos:"V", axes:["configuration","rhythm"], v:{surda:"partir", sonora:"organizar", fricativa:"espalhar"}},
    {key:"sobrepor", pos:"V", axes:["density","texture"], v:{surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir"}},
    {key:"atravessar", pos:"V", axes:["continuity","oblique"], v:{surda:"passar", sonora:"cruzar", fricativa:"permeiar"}},
    {key:"insinuar", pos:"V", axes:["rarefaction","emergence"], v:{surda:"sugerir", sonora:"indicar", fricativa:"sussurrar"}},

    {key:"insistir", pos:"V", axes:["repetition","tension"], v:{surda:"bater", sonora:"persistir", fricativa:"ressoar"}},
    {key:"interromper", pos:"V", axes:["cessation","cut"], v:{surda:"cortar", sonora:"cessar", fricativa:"esvair-se"}},
    {key:"fixar", pos:"V", axes:["contour","configuration"], v:{surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar"}},
    {key:"suspender(v)", pos:"V", axes:["rarefaction","tension"], v:{surda:"parar", sonora:"reter", fricativa:"flutuar"}},
    {key:"reter", pos:"V", axes:["memory","mass"], v:{surda:"prender", sonora:"guardar", fricativa:"conservar"}},
    {key:"abandonar", pos:"V", axes:["cessation","rarefaction"], v:{surda:"largar", sonora:"deixar", fricativa:"dissolver"}},
    {key:"transformar", pos:"V", axes:["emergence","configuration"], v:{surda:"romper", sonora:"converter", fricativa:"transfigurar"}},

    // ADJ
    {key:"leve", pos:"A", axes:["rarefaction","continuity"], v:{surda:"claro", sonora:"brando", fricativa:"suave"}},
    {key:"mínimo", pos:"A", axes:["rarefaction","care"], v:{surda:"curto", sonora:"pequeno", fricativa:"sutil"}},
    {key:"frágil", pos:"A", axes:["tension","rarefaction"], v:{surda:"ténue", sonora:"delicado", fricativa:"sensível"}},
    {key:"tênue", pos:"A", axes:["rarefaction","surface"], v:{surda:"fino", sonora:"delgado", fricativa:"esfumado"}},
    {key:"quase(adj)", pos:"A", axes:["emergence","rarefaction"], v:{surda:"breve", sonora:"próximo", fricativa:"difuso"}},

    {key:"opaco", pos:"A", axes:["density","mass"], v:{surda:"denso", sonora:"turvo", fricativa:"fosco"}},
    {key:"poroso", pos:"A", axes:["continuity","rarefaction"], v:{surda:"aberto", sonora:"vazado", fricativa:"permeável"}},
    {key:"irregular", pos:"A", axes:["oblique","tension"], v:{surda:"torto", sonora:"instável", fricativa:"assimétrico"}},
    {key:"difuso", pos:"A", axes:["center","rarefaction"], v:{surda:"solto", sonora:"amplo", fricativa:"disperso"}},

    {key:"latente", pos:"A", axes:["emergence","memory"], v:{surda:"oculto", sonora:"presente", fricativa:"subjacente"}},
    {key:"instável", pos:"A", axes:["tension","oblique"], v:{surda:"quebrado", sonora:"oscilante", fricativa:"flutuante"}},
    {key:"provisório", pos:"A", axes:["configuration","tension"], v:{surda:"breve", sonora:"mutável", fricativa:"transitório"}},

    // ADV
    {key:"ainda", pos:"R", axes:["continuity","emergence"], v:{surda:"já", sonora:"agora", fricativa:"sempre"}},
    {key:"quase(adv)", pos:"R", axes:["emergence","rarefaction"], v:{surda:"logo", sonora:"perto", fricativa:"talvez"}},
    {key:"lentamente", pos:"R", axes:["continuity","care"], v:{surda:"aos poucos", sonora:"com calma", fricativa:"suavemente"}},
    {key:"por vezes", pos:"R", axes:["repetition","tension"], v:{surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente"}},
    {key:"sempre", pos:"R", axes:["repetition"], v:{surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente"}},
    {key:"raramente", pos:"R", axes:["rarefaction"], v:{surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente"}},
    {key:"talvez", pos:"R", axes:["tension","emergence"], v:{surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente"}},
    {key:"agora", pos:"R", axes:["presence"], v:{surda:"já", sonora:"neste momento", fricativa:"presentemente"}}
  ];

  // Build lookup by rendered word -> operator meta (we’ll attach spans anyway)
  const OPS = (() => {
    const out = [];
    for(const o of LEX) out.push(o);
    return out;
  })();

  function pick(arr, r){ return arr[Math.floor(r()*arr.length)]; }
  function byPos(pos){ return OPS.filter(o => o.pos===pos); }

  const Ns = byPos("N");
  const Vs = byPos("V");
  const As = byPos("A");
  const Rs = byPos("R");

  // -------------------------------
  // Phon type helper
  // -------------------------------
  function phonTypeFromVariantKey(k){
    if(k==="surda") return "surda";
    if(k==="sonora") return "sonora";
    return "fricativa";
  }

  // -------------------------------
  // Asset: Sui image
  // -------------------------------
  const SUI_URL = "../assets/sui/slot_053.jpg";
  const imgCache = new Map();

  function loadImage(url){
    if(imgCache.has(url)) return imgCache.get(url);
    const p = new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ok:true, img});
      img.onerror = () => resolve({ok:false, img:null});
      // avoid taint if we ever need canvas export on github
      img.crossOrigin = "anonymous";
      img.src = url;
    });
    imgCache.set(url, p);
    return p;
  }

  // -------------------------------
  // State machine
  // -------------------------------
  const state = {
    // global axis weights (0..1)
    axis: Object.fromEntries(AXES.map(a => [a, 0.18])),
    // mobile-local impulses
    imp: [Object.fromEntries(AXES.map(a => [a,0])), Object.fromEntries(AXES.map(a => [a,0])),
          Object.fromEntries(AXES.map(a => [a,0])), Object.fromEntries(AXES.map(a => [a,0]))],
    // phon bias for M4
    phon: {surda:0.33, sonora:0.33, fricativa:0.33},
    phonDom: "surda",
    phonHeat: 0.0,
    // counters for determinism
    step: [0,0,0,0],
    // M2 flip + object alt
    m2Flip: false,
    m2ObjAlt: 0,
    // caches
    finalSeed: null,
    finalCache: null,
    // slot picks
    m1Slots:[1,2,3],
    m2Slots:[12,18],
    m3Slots:[31,33,36,42,55,69,77],
    m4Slots:[91,96,104,112,53], // include Sui possibility (slot 53) later by draw
    // Sui availability
    suiOk: false
  };

  function decayWeight(from,to){
    if(from===to) return 1.0;
    if(to===from+1) return 0.45;
    return 0.18;
  }

  function applyImpulse(fromIdx, axes, amt){
    for(let to=0; to<4; to++){
      const w = decayWeight(fromIdx,to);
      for(const ax of axes){
        state.imp[to][ax] = clamp(state.imp[to][ax] + amt*w, 0, 1);
        state.axis[ax] = clamp(state.axis[ax] + (amt*w)*0.25, 0.05, 0.98);
      }
    }
    invalidateFinal();
  }

  function effAxis(mobileIdx, ax){
    return clamp(state.axis[ax] + state.imp[mobileIdx][ax], 0, 1);
  }

  function dampImpulses(){
    for(let m=0;m<4;m++){
      for(const ax of AXES){
        state.imp[m][ax] *= 0.86; // gentle fading to avoid runaway
      }
    }
  }

  function invalidateFinal(){
    state.finalSeed = null;
    state.finalCache = null;
    document.getElementById("shareFinal").style.display = "none";
    document.getElementById("shareText").style.display = "none";
  }

  // -------------------------------
  // Operator selection with axis + phon influence
  // -------------------------------
  function chooseVariantKey(r, mobileIdx){
    // M4 uses phon biases strongly; others slightly
    const s = state.phon;
    const bias = (mobileIdx===3) ? 0.88 : 0.55;
    const a = s.surda, b = a + s.sonora;
    const x = r();
    if(x < a*bias + a*(1-bias)*0.33) return "surda";
    if(x < b*bias + b*(1-bias)*0.66) return "sonora";
    return "fricativa";
  }

  function scoreOperator(op, mobileIdx){
    let sc = 0;
    for(const ax of op.axes){
      sc += effAxis(mobileIdx, ax);
    }
    // normalize
    sc = sc / Math.max(1, op.axes.length);
    return sc;
  }

  function chooseOp(list, mobileIdx, r){
    // weighted pick by axis score
    let sum = 0;
    const weights = list.map(op => {
      const w = 0.15 + 0.85 * scoreOperator(op, mobileIdx);
      sum += w;
      return w;
    });
    let t = r()*sum;
    for(let i=0;i<list.length;i++){
      t -= weights[i];
      if(t<=0) return list[i];
    }
    return list[list.length-1];
  }

  function renderToken(op, vKey){
    const txt = op.v[vKey];
    const axes = op.axes.join(",");
    const ph = phonTypeFromVariantKey(vKey);
    return {txt, axes, ph, opKey: op.key};
  }

  // -------------------------------
  // Text tokenization + rendering
  // -------------------------------
  function spansFromTokens(tokens, mobileIdx, clickHandlerName){
    // tokens: array of {txt, axes, ph, opKey} and string separators
    const parts = [];
    for(const t of tokens){
      if(typeof t === "string"){
        parts.push(t);
      }else{
        const safe = escapeHtml(t.txt);
        parts.push(`<span class="w" data-axes="${t.axes}" data-ph="${t.ph}" data-op="${escapeHtml(t.opKey)}" data-m="${mobileIdx}">${safe}</span>`);
      }
    }
    return parts.join("");
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, ch => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[ch]));
  }

  // -------------------------------
  // Draw fragments (procedural + optional image cover)
  // -------------------------------
  function coverDraw(ctx, img, x,y,w,h){
    const iw = img.width, ih = img.height;
    const r = Math.max(w/iw, h/ih);
    const nw = iw*r, nh = ih*r;
    const cx = x + (w-nw)/2;
    const cy = y + (h-nh)/2;
    ctx.drawImage(img, cx, cy, nw, nh);
  }

  function pastelByFamily(f){
    const map = {
      F1:["#f7d6ea","#e8fbf6","#d7dfff"],
      F2:["#ffe3d6","#ffd7ef","#e7dbff"],
      F3:["#d9fff0","#f7d6ea","#d8f0ff"],
      F4:["#fff0d6","#e8fbf6","#f7d6ea"],
      F5:["#ffd7ef","#ffe3d6","#d7dfff"],
      F6:["#e8fbf6","#d9fff0","#fff0d6"],
      F7:["#f9fbff","#f7d6ea","#e8fbf6"],
      F8:["#e7dbff","#d8f0ff","#ffd7ef"],
      F9:["#f1f3f8","#f9fbff","#e8fbf6"],
      F10:["#d8f0ff","#fff0d6","#e7dbff"],
      F11:["#ffe3d6","#f9fbff","#ffd7ef"],
      F12:["#fff0d6","#ffd7ef","#e7dbff"]
    };
    return map[f] || ["#f7d6ea","#e8fbf6","#d7dfff"];
  }

  function drawProcedural(ctx, x,y,w,h, f, seed){
    const r = mulberry32(seed);
    const cols = pastelByFamily(f);
    const bg = cols[Math.floor(r()*cols.length)];
    ctx.save();
    // card
    ctx.fillStyle = bg;
    ctx.strokeStyle = "rgba(20,20,30,.22)";
    ctx.lineWidth = 2;
    roundRect(ctx,x,y,w,h,14);
    ctx.fill();
    ctx.stroke();

    // inner “grammar”: vary by family
    const pad = 10;
    const ix = x+pad, iy=y+pad, iw=w-2*pad, ih=h-2*pad;

    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = "rgba(15,15,20,.18)";
    ctx.fillStyle = "rgba(15,15,20,.08)";
    ctx.lineWidth = 2;

    if(f==="F2"||f==="F5"||f==="F11"){
      // cuts / contours
      const k = 3 + Math.floor(r()*4);
      for(let i=0;i<k;i++){
        const xx = ix + r()*iw;
        ctx.beginPath();
        ctx.moveTo(xx, iy);
        ctx.lineTo(xx, iy+ih);
        ctx.stroke();
      }
    }else if(f==="F7"||f==="F9"){
      // rarefaction / neutral
      const k = 3 + Math.floor(r()*5);
      for(let i=0;i<k;i++){
        ctx.beginPath();
        const yy = iy + r()*ih;
        ctx.moveTo(ix, yy);
        ctx.lineTo(ix+iw, yy);
        ctx.stroke();
      }
    }else if(f==="F4"){
      // repetition / rhythm
      const k = 6 + Math.floor(r()*7);
      for(let i=0;i<k;i++){
        ctx.fillRect(ix + i*(iw/k), iy, 3, ih);
      }
    }else if(f==="F6"||f==="F12"){
      // density / mass
      const k = 12 + Math.floor(r()*20);
      for(let i=0;i<k;i++){
        const ww = 8 + r()*28;
        const hh = 8 + r()*28;
        ctx.fillRect(ix + r()*(iw-ww), iy + r()*(ih-hh), ww, hh);
      }
    }else if(f==="F3"||f==="F10"){
      // oblique / conflict
      const k = 3 + Math.floor(r()*5);
      for(let i=0;i<k;i++){
        ctx.beginPath();
        ctx.moveTo(ix, iy + r()*ih);
        ctx.lineTo(ix+iw, iy + r()*ih);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ix + r()*iw, iy);
        ctx.lineTo(ix + r()*iw, iy+ih);
        ctx.stroke();
      }
      ctx.globalAlpha = 0.45;
      ctx.beginPath();
      ctx.moveTo(ix,iy+ih);
      ctx.lineTo(ix+iw,iy);
      ctx.stroke();
    }else if(f==="F8"){
      // center unstable
      ctx.globalAlpha = 0.55;
      ctx.beginPath();
      ctx.arc(ix+iw*(0.35+r()*0.3), iy+ih*(0.35+r()*0.3), Math.min(iw,ih)*(0.12+r()*0.12), 0, Math.PI*2);
      ctx.stroke();
    }else{
      // continuity
      ctx.globalAlpha = 0.55;
      ctx.beginPath();
      ctx.moveTo(ix, iy+ih*0.5);
      ctx.bezierCurveTo(ix+iw*0.25, iy+ih*(0.15+r()*0.2), ix+iw*0.75, iy+ih*(0.85-r()*0.2), ix+iw, iy+ih*0.5);
      ctx.stroke();
    }

    ctx.restore();
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  async function drawSlot(ctx, x,y,w,h, slot, mobileIdx, seed){
    const fam = familyForSlot(slot);
    // Try Sui only if slot == 53 and loaded ok
    if(slot===53 && state.suiOk){
      const res = await loadImage(SUI_URL);
      if(res.ok){
        ctx.save();
        roundRect(ctx,x,y,w,h,14);
        ctx.clip();
        coverDraw(ctx,res.img,x,y,w,h);
        ctx.restore();

        // border
        ctx.save();
        ctx.strokeStyle = "rgba(20,20,30,.35)";
        ctx.lineWidth = 2;
        roundRect(ctx,x,y,w,h,14);
        ctx.stroke();
        ctx.restore();
        return;
      }
    }
    drawProcedural(ctx, x,y,w,h, fam, seed ^ (slot*9973) ^ (mobileIdx*1927));
  }

  // -------------------------------
  // Canvas sizing
  // -------------------------------
  function fitCanvas(canvas){
    const wrap = canvas.parentElement.getBoundingClientRect();
    const cssW = Math.max(320, Math.floor(wrap.width));
    // keep internal resolution for crispness
    const ratio = window.devicePixelRatio || 1;
    const baseW = canvas.getAttribute("width")|0;
    const baseH = canvas.getAttribute("height")|0;
    canvas.style.width = cssW + "px";
    const cssH = Math.floor(cssW * (baseH/baseW));
    canvas.style.height = cssH + "px";
    canvas.width = Math.floor(cssW * ratio);
    canvas.height = Math.floor(cssH * ratio);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(ratio,0,0,ratio,0,0);
    return {ctx, w: cssW, h: cssH};
  }

  // -------------------------------
  // Text generators per mobile
  // -------------------------------
  function genM1(r){
    const mobileIdx = 0;
    const vKey = chooseVariantKey(r, mobileIdx);

    const axisN = chooseOp(Ns, mobileIdx, r);
    const axisV = chooseOp(Vs, mobileIdx, r);
    const axisObj = chooseOp(Ns, mobileIdx, r);
    const adv = chooseOp(Rs, mobileIdx, r);

    const n = renderToken(axisN, vKey);
    const v = renderToken(axisV, vKey);
    const o = renderToken(axisObj, vKey);
    const a = renderToken(adv, vKey);

    // your preferred substantivation:
    // "O que nasce aqui é um sugerir-ruga, às vezes."
    const verbObj = `${v.txt}-${o.txt}`;

    const tokens = [
      "No começo, ", n, " aparece como eixo — e isso já inclina o campo. ",
      "O que nasce aqui é um ", {txt:verbObj, axes:[...axisV.axes,...axisObj.axes].join(","), ph:n.ph, opKey: axisV.key}, ", ", a, ". ",
      "O resto não some: fica como ", renderToken(chooseOp(Ns,mobileIdx,r), vKey),
      " à espera de outra tensão. ",
      "Se o campo endurece, não é ruído: é ", renderToken(chooseOp(Ns,mobileIdx,r), vKey), " em formação."
    ];
    return tokens;
  }

  function genM2(r){
    // Must be S–V–O in 3 modules; flip swaps module1<->module3; verb click changes object only
    const mobileIdx = 1;
    const vKey = chooseVariantKey(r, mobileIdx);

    // Subject and object are chosen and stored so flips are consistent
    // We'll keep two candidates for each side; flipping swaps which appears
    if(!state._m2){
      state._m2 = {
        subjA: chooseOp(Ns,mobileIdx,r),
        objA: chooseOp(Ns,mobileIdx,r),
        subjB: chooseOp(Ns,mobileIdx,r),
        objB: chooseOp(Ns,mobileIdx,r),
        advA: chooseOp(Rs,mobileIdx,r),
        adjA: chooseOp(As,mobileIdx,r),
        advB: chooseOp(Rs,mobileIdx,r),
        adjB: chooseOp(As,mobileIdx,r),
        verb: chooseOp(Vs,mobileIdx,r)
      };
    }

    // object alternation controlled by m2ObjAlt
    // Clicking verb rotates verb + object for the current "object side"
    const m = state._m2;

    // choose which side is "front" after flip
    const frontIsA = !state.m2Flip;

    const subjCore = frontIsA ? m.subjA : m.subjB;
    const objCore = frontIsA ? m.objA : m.objB;

    // optional adj/adv depend on axes intensity (presence/care etc)
    const useAdj = effAxis(mobileIdx,"tension") > 0.35 || effAxis(mobileIdx,"configuration") > 0.35;
    const useAdv = effAxis(mobileIdx,"continuity") > 0.35 || effAxis(mobileIdx,"rarefaction") > 0.35;

    const subjMods = [];
    if(useAdj) subjMods.push(renderToken(frontIsA ? m.adjA : m.adjB, vKey));
    if(useAdv) subjMods.push(renderToken(frontIsA ? m.advA : m.advB, vKey));

    // Verb adjusts depending on subject/object axes (without introducing new words)
    const verb = m.verb;
    const verbTok = renderToken(verb, vKey);

    const objMods = [];
    // verb click can change object only: we implement object pool per alt
    let objTok = renderToken(objCore, vKey);

    if(state.m2ObjAlt>0){
      // alternate object deterministically from axes profile
      const pool = Ns.filter(o => o !== objCore);
      const rr = mulberry32(hashStr(objCore.key + "|" + state.m2ObjAlt));
      const picked = pool[Math.floor(rr()*pool.length)];
      objTok = renderToken(picked, vKey);
    }
    if(useAdj) objMods.push(renderToken(chooseOp(As,mobileIdx,r), vKey));
    if(useAdv) objMods.push(renderToken(chooseOp(Rs,mobileIdx,r), vKey));

    // Module 1 and 3 swap on flip
    const mod1 = [renderToken(subjCore,vKey), ...subjMods];
    const mod3 = [objTok, ...objMods];

    const module1 = frontIsA ? mod1 : mod3;
    const module3 = frontIsA ? mod3 : mod1;

    const tokens = [
      ...module1, " ",
      {txt:verbTok.txt, axes:verb.axes.join(","), ph:verbTok.ph, opKey: verb.key, _verb:true},
      " ",
      ...module3
    ];
    return tokens;
  }

  function genM3(r){
    const mobileIdx = 2;
    const vKey = chooseVariantKey(r, mobileIdx);

    // build a longer curatorial paragraph, with clickable tokens
    const n1 = renderToken(chooseOp(Ns,mobileIdx,r), vKey);
    const a1 = renderToken(chooseOp(As,mobileIdx,r), vKey);
    const v1 = renderToken(chooseOp(Vs,mobileIdx,r), vKey);
    const n2 = renderToken(chooseOp(Ns,mobileIdx,r), vKey);
    const adv = renderToken(chooseOp(Rs,mobileIdx,r), vKey);

    const n3 = renderToken(chooseOp(Ns,mobileIdx,r), vKey);
    const a2 = renderToken(chooseOp(As,mobileIdx,r), vKey);
    const v2 = renderToken(chooseOp(Vs,mobileIdx,r), vKey);
    const n4 = renderToken(chooseOp(Ns,mobileIdx,r), vKey);

    const tokens = [
      "No campo, a ", n1, " ", a1, " parece aprender a ", v1, " a ", n2, "; ",
      adv, ", o ", n3, " ", a2, " insiste em ", v2, " o ", n4, ". ",
      "O que repetes ganha ", renderToken(chooseOp(Ns,mobileIdx,r), vKey),
      "; o que deixas passar volta como ", renderToken(chooseOp(Ns,mobileIdx,r), vKey), "."
    ];
    return tokens;
  }

  function genM4(r){
    const mobileIdx = 3;

    // phon dominance: choose variant key more strongly based on phonDom + heat
    const dom = state.phonDom;
    function vKeyDom(){
      const heat = clamp(state.phonHeat,0,1);
      const x = r();
      if(x < 0.15*(1-heat)) return "sonora"; // small variation early
      if(x < 0.30*(1-heat)) return "fricativa";
      return dom;
    }

    const make = (posList) => {
      const op = chooseOp(posList, mobileIdx, r);
      const vk = vKeyDom();
      return renderToken(op, vk);
    };

    // Template with many slots; verbs in infinitive are made acceptable by "a" / "um" framing
    // We avoid conjugation problems by using constructions:
    // "o gesto de VERBO", "a maneira de VERBO", "a tentar VERBO", "a VERBO"
    const n1 = make(Ns), a1=make(As), v1=make(Vs), n2=make(Ns);
    const n3 = make(Ns), a2=make(As), v2=make(Vs), n4=make(Ns);
    const adv = make(Rs);
    const n5 = make(Ns), v3=make(Vs), n6=make(Ns);
    const n7 = make(Ns), a3=make(As), v4=make(Vs);

    const tokens = [
      "No campo, a ", n1, " ", a1, " faz-se ", n2, " — ",
      "e a ", n3, " ", a2, " tenta ", {txt:"a "+v2.txt, axes:v2.axes.join(","), ph:v2.ph, opKey:v2.opKey}, " a ", n4,
      "; ", adv, ", a ", n5, " insiste em ", {txt:"a "+v3.txt, axes:v3.axes.join(","), ph:v3.ph, opKey:v3.opKey},
      " na ", n6, ", até que a ", n7, " ", a3, " se deixa ", {txt:"a "+v4.txt, axes:v4.axes.join(","), ph:v4.ph, opKey:v4.opKey}, "."
    ];
    return tokens;
  }

  // -------------------------------
  // Móbile drawing layouts
  // -------------------------------
  async function drawM1(){
    const canvas = document.getElementById("c1");
    const {ctx,w,h} = fitCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    // cradle mobile background
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(20,20,30,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(w*0.5, h*0.1, Math.min(w,h)*0.28, Math.PI, 2*Math.PI);
    ctx.stroke();
    ctx.restore();

    // 3 hanging cards
    const slots = state.m1Slots;
    const cardW = Math.min(220, Math.floor(w*0.24));
    const cardH = Math.floor(cardW*0.62);
    const xs = [w*0.32 - cardW/2, w*0.5 - cardW/2, w*0.68 - cardW/2];
    const ys = [h*0.25, h*0.17, h*0.25];

    for(let i=0;i<3;i++){
      ctx.save();
      ctx.strokeStyle="rgba(20,20,30,.25)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(w*0.5, h*0.1);
      ctx.lineTo(xs[i]+cardW/2, ys[i]);
      ctx.stroke();
      ctx.restore();

      await drawSlot(ctx, xs[i], ys[i], cardW, cardH, slots[i], 0, (state.step[0]+1)*1009+i*17);
    }
  }

  async function drawM2(){
    const canvas = document.getElementById("c2");
    const {ctx,w,h} = fitCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    // mountains
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(20,20,30,.12)";
    ctx.beginPath();
    ctx.moveTo(0,h*0.78);
    ctx.lineTo(w*0.2,h*0.55);
    ctx.lineTo(w*0.38,h*0.7);
    ctx.lineTo(w*0.55,h*0.48);
    ctx.lineTo(w*0.78,h*0.68);
    ctx.lineTo(w,h*0.52);
    ctx.lineTo(w,h);
    ctx.lineTo(0,h);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // two fragments: back smaller, front larger
    const backW = Math.min(240, Math.floor(w*0.26));
    const backH = Math.floor(backW*0.62);
    const frontW = Math.min(320, Math.floor(w*0.34));
    const frontH = Math.floor(frontW*0.62);

    const backX = w*0.58;
    const backY = h*0.22;
    const frontX = w*0.18;
    const frontY = h*0.42;

    // slots represent subject/object and swap on flip
    // keep fixed pair, just swap which slot draws front/back
    const sA = state.m2Slots[0];
    const sB = state.m2Slots[1];
    const frontSlot = state.m2Flip ? sB : sA;
    const backSlot  = state.m2Flip ? sA : sB;

    await drawSlot(ctx, backX, backY, backW, backH, backSlot, 1, 7001 + state.step[1]*31);
    await drawSlot(ctx, frontX, frontY, frontW, frontH, frontSlot, 1, 9001 + state.step[1]*37);

    // tiny animals (minimal)
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(20,20,30,.25)";
    ctx.lineWidth = 2;
    for(let i=0;i<4;i++){
      const xx = w*(0.62 + i*0.07);
      const yy = h*0.78 + (i%2)*6;
      ctx.beginPath();
      ctx.arc(xx, yy, 6, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(xx-6,yy+5); ctx.lineTo(xx+6,yy+5);
      ctx.stroke();
    }
    ctx.restore();
  }

  async function drawM3(){
    const canvas = document.getElementById("c3");
    const {ctx,w,h} = fitCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    // labyrinth grid
    ctx.save();
    ctx.globalAlpha=0.16;
    ctx.strokeStyle="rgba(20,20,30,.22)";
    ctx.lineWidth=2;
    const step = Math.max(34, Math.floor(w/18));
    for(let y=step; y<h; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    for(let x=step; x<w; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    ctx.restore();

    const slots = state.m3Slots;
    // positions distributed
    const positions = [
      [w*0.08,h*0.18],[w*0.32,h*0.12],[w*0.58,h*0.18],[w*0.78,h*0.12],
      [w*0.18,h*0.58],[w*0.52,h*0.62],[w*0.76,h*0.56],
    ];
    const cardW = Math.min(210, Math.floor(w*0.22));
    const cardH = Math.floor(cardW*0.62);

    for(let i=0;i<slots.length;i++){
      const [x,y] = positions[i];
      await drawSlot(ctx, x, y, cardW, cardH, slots[i], 2, 11001 + state.step[2]*41 + i*13);
    }
  }

  async function drawM4(){
    const canvas = document.getElementById("c4");
    const {ctx,w,h} = fitCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    // escher-ish stairs
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle="rgba(20,20,30,.25)";
    ctx.lineWidth=3;
    const baseX = w*0.12, baseY = h*0.82;
    const stairW = w*0.70, stairH = h*0.52;
    const steps = 7;
    for(let i=0;i<steps;i++){
      const x = baseX + i*(stairW/steps);
      const y = baseY - i*(stairH/steps);
      ctx.strokeRect(x,y, stairW/steps, stairH/steps);
    }
    ctx.restore();

    const slots = state.m4Slots.slice();
    // ensure slot 53 can appear (Sui), but not necessarily always—only if session says yes
    // we keep it as one of the five slots; if image fails, it becomes procedural
    const cardW = Math.min(220, Math.floor(w*0.23));
    const cardH = Math.floor(cardW*0.62);

    const pos = [
      [w*0.10,h*0.18],
      [w*0.32,h*0.10],
      [w*0.54,h*0.22],
      [w*0.22,h*0.56],
      [w*0.62,h*0.54],
    ];

    for(let i=0;i<5;i++){
      const [x,y] = pos[i];
      await drawSlot(ctx, x, y, cardW, cardH, slots[i], 3, 16001 + state.step[3]*53 + i*19);
    }
  }

  async function drawFinal(finalSlots){
    const canvas = document.getElementById("cf");
    const {ctx,w,h} = fitCanvas(canvas);
    ctx.clearRect(0,0,w,h);

    // 10 fragments arranged in two rows with overlap (constellation)
    const cardW = Math.min(240, Math.floor(w*0.26));
    const cardH = Math.floor(cardW*0.62);
    const gapX = Math.floor(cardW*0.18);
    const gapY = Math.floor(cardH*0.38);

    const startX = Math.max(10, Math.floor((w - (cardW*5 - gapX*4))/2));
    const startY = Math.floor(h*0.14);

    for(let i=0;i<10;i++){
      const row = Math.floor(i/5);
      const col = i%5;
      const x = startX + col*(cardW - gapX) + (row? 22:0);
      const y = startY + row*(cardH - gapY);
      await drawSlot(ctx, x, y, cardW, cardH, finalSlots[i], 9, (state.finalSeed||12345) + i*97);
    }
  }

  // -------------------------------
  // Interaction hit-tests for canvases
  // We make regions roughly match drawn cards.
  // -------------------------------
  function makeHitRegionsM2(canvas){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const backW = Math.min(240, Math.floor(w*0.26));
    const backH = Math.floor(backW*0.62);
    const frontW = Math.min(320, Math.floor(w*0.34));
    const frontH = Math.floor(frontW*0.62);
    const backX = w*0.58, backY = h*0.22;
    const frontX = w*0.18, frontY = h*0.42;
    return [
      {name:"back", x:backX, y:backY, w:backW, h:backH},
      {name:"front", x:frontX, y:frontY, w:frontW, h:frontH}
    ];
  }

  function makeHitRegionsM3(canvas){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const cardW = Math.min(210, Math.floor(w*0.22));
    const cardH = Math.floor(cardW*0.62);
    const positions = [
      [w*0.08,h*0.18],[w*0.32,h*0.12],[w*0.58,h*0.18],[w*0.78,h*0.12],
      [w*0.18,h*0.58],[w*0.52,h*0.62],[w*0.76,h*0.56],
    ];
    return positions.map((p,i)=>({i, x:p[0], y:p[1], w:cardW, h:cardH}));
  }

  // -------------------------------
  // Semantics: word click → axes; fragment click → family axes
  // -------------------------------
  function onWordClick(e){
    const el = e.target;
    if(!el.classList || !el.classList.contains("w")) return;
    const axes = (el.dataset.axes||"").split(",").filter(Boolean);
    const m = parseInt(el.dataset.m||"0",10);
    const ph = el.dataset.ph || "surda";

    // apply semantic impulse
    applyImpulse(m, axes, 0.22);

    // phon effect in M4
    if(m===3){
      // increase phon heat + bias toward clicked phon type
      state.phonHeat = clamp(state.phonHeat + 0.10, 0, 1);
      // raise chosen type, lower others slightly
      state.phon[ph] = clamp(state.phon[ph] + 0.12, 0.10, 0.85);
      const other = ["surda","sonora","fricativa"].filter(x=>x!==ph);
      for(const o of other) state.phon[o] = clamp(state.phon[o] - 0.06, 0.10, 0.80);

      // normalize
      const s = state.phon.surda + state.phon.sonora + state.phon.fricativa;
      state.phon.surda/=s; state.phon.sonora/=s; state.phon.fricativa/=s;

      // if saturated → collapse: rotate dom and reset heat partially
      if(state.phonHeat > 0.92){
        state.phonHeat = 0.25;
        state.phonDom = (state.phonDom==="surda") ? "sonora" : (state.phonDom==="sonora") ? "fricativa" : "surda";
        // re-center biases around new dom
        state.phon = {surda:0.33, sonora:0.33, fricativa:0.33};
        state.phon[state.phonDom] = 0.48;
        const ss = state.phon.surda + state.phon.sonora + state.phon.fricativa;
        state.phon.surda/=ss; state.phon.sonora/=ss; state.phon.fricativa/=ss;
      }
    }

    // local step for determinism + rerender
    state.step[m]++;

    dampImpulses();
    renderAll();
  }

  function onFragmentClickM3(slot){
    const fam = familyForSlot(slot);
    const axesObj = FAMILY_AXES[fam] || {};
    const axes = Object.keys(axesObj);
    applyImpulse(2, axes, 0.24);
    state.step[2]++;
    dampImpulses();
    renderAll();
  }

  // -------------------------------
  // Share: compose text + image
  // -------------------------------
  async function shareCanvas(canvas, text){
    const blob = await new Promise(res => canvas.toBlob(res, "image/png"));
    const file = blob ? new File([blob], "mobiles.png", {type:"image/png"}) : null;

    const url = location.href;
    const fullText = text + "\n\n" + "Faz a tua própria curadoria aqui: " + url;

    if(navigator.share && file){
      try{
        await navigator.share({text: fullText, files:[file], title:"MÓBILES"});
        return {ok:true, mode:"native"};
      }catch(err){
        // fall back
      }
    }
    // fallback: copy to clipboard
    try{
      await navigator.clipboard.writeText(fullText);
      return {ok:true, mode:"copy"};
    }catch(err){
      return {ok:false, mode:"none"};
    }
  }

  // -------------------------------
  // Render functions
  // -------------------------------
  function seedForMobile(i){
    // derive from axis weights + steps so it’s deterministic but responsive
    const key = AXES.map(a=>Math.round(state.axis[a]*100)).join(",") + "|" + state.step.join("|") + "|" + state.m2Flip + "|" + state.m2ObjAlt + "|" + state.phonDom + "|" + Math.round(state.phonHeat*100);
    return (hashStr(key) ^ (i*2654435761)) >>> 0;
  }

  function renderTextInto(el, tokens, mobileIdx){
    const r = mulberry32(seedForMobile(mobileIdx));
    // tokens may include objects created with merged axes; ensure proper shape
    const normalized = tokens.map(t => {
      if(typeof t==="string") return t;
      if(t._verb){
        // verb token clickable: mark special
        return {txt:t.txt, axes:t.axes, ph:t.ph, opKey:t.opKey};
      }
      // if custom token object is incomplete, keep it safe:
      return {txt:t.txt, axes:t.axes||"", ph:t.ph||chooseVariantKey(r,mobileIdx), opKey:t.opKey||""};
    });
    el.innerHTML = spansFromTokens(normalized, mobileIdx);
  }

  async function renderM1(){
    const r = mulberry32(seedForMobile(0));
    const tokens = genM1(r);
    renderTextInto(document.getElementById("t1"), tokens, 0);
    await drawM1();
  }

  async function renderM2(){
    const r = mulberry32(seedForMobile(1));
    const tokens = genM2(r);
    const el = document.getElementById("t2");

    // render with verb clickable: we attach handler by event delegation and detect verb span by opKey matching stored verb
    renderTextInto(el, tokens, 1);

    await drawM2();
  }

  async function renderM3(){
    const r = mulberry32(seedForMobile(2));
    const tokens = genM3(r);
    renderTextInto(document.getElementById("t3"), tokens, 2);
    await drawM3();
  }

  async function renderM4(){
    const r = mulberry32(seedForMobile(3));
    const tokens = genM4(r);
    renderTextInto(document.getElementById("t4"), tokens, 3);
    await drawM4();
  }

  function computeFinal(){
    // Deterministic final based on axis weights: pick families with weighted draw
    const base = seedForMobile(99);
    const r = mulberry32(base);

    // family weights from axes
    const famWeights = {};
    for(let i=1;i<=12;i++){
      const f = "F"+i;
      const ax = FAMILY_AXES[f] || {};
      let w = 0.12;
      for(const k of Object.keys(ax)){
        w += ax[k] * state.axis[k];
      }
      famWeights[f] = w;
    }

    function pickFamily(){
      const entries = Object.entries(famWeights);
      let sum = 0;
      for(const [,w] of entries) sum += w;
      let t = r()*sum;
      for(const [f,w] of entries){
        t -= w;
        if(t<=0) return f;
      }
      return "F1";
    }

    // choose 10 slots
    const slots = [];
    for(let i=0;i<10;i++){
      const f = pickFamily();
      const idx = parseInt(f.slice(1),10);
      const start = (idx-1)*10 + 1;
      const slot = start + Math.floor(r()*10);
      slots.push(slot);
    }

    // ensure Sui appears sometimes if available and session chose it
    // We'll do: if suiOk and r()<0.65, force one slot=53
    if(state.suiOk && r() < 0.65){
      slots[slots.length-1] = 53;
    }
    return {slots, seed: base};
  }

  function genFinalTexts(finalSlots){
    // style text must reflect axes
    const cut = state.axis.cut, cont = state.axis.continuity, den=state.axis.density, rar=state.axis.rarefaction, cen=state.axis.center, rep=state.axis.repetition;
    const dom = state.phonDom;

    const profile =
      (cut>cont && cut>0.45) ? "corte e decisão" :
      (cont>cut && cont>0.45) ? "passagens e sustentação" :
      (den>0.50) ? "densidade e matéria" :
      (rar>0.50) ? "suspensão e rarefação" :
      (cen>0.50) ? "centro instável e desvio" :
      (rep>0.50) ? "insistência e repetição" :
      "equilíbrio instável";

    const sound =
      (dom==="surda") ? "corte seco" :
      (dom==="sonora") ? "impacto cheio" :
      "passagem fluida";

    const style = `O teu estilo curatorial inclina-se para ${profile}, com um corpo sonoro de ${sound}.`;

    // critique text uses lexicon with deterministic seed from final
    const r = mulberry32(state.finalSeed ^ 0xABCDEF);
    const vk = chooseVariantKey(r, 0);
    const a1 = renderToken(chooseOp(As,0,r), vk).txt;
    const n1 = renderToken(chooseOp(Ns,0,r), vk).txt;
    const v1 = renderToken(chooseOp(Vs,0,r), vk).txt;
    const n2 = renderToken(chooseOp(Ns,0,r), vk).txt;
    const adv = renderToken(chooseOp(Rs,0,r), vk).txt;

    const critique =
      `Nesta constelação, a ${n1} ${a1} organiza um campo onde a ${n2} se deixa ${v1} por aproximações sucessivas. ` +
      `O resultado não fecha o sentido: mantém uma zona de resto, ${adv}, como se pedisse nova reentrada e outra leitura. ` +
      `Partilha — e vê que obras emergem para os outros, onde o teu olhar ainda não chegou.`;

    const share = `Eu gerei a minha curadoria no MÓBILES (suiornotsui). E a tua?`;

    return {style, critique, share};
  }

  async function renderFinal(){
    const box = document.getElementById("finalBox");
    const tf = document.getElementById("tf");
    const shareText = document.getElementById("shareText");
    const shareBtn = document.getElementById("shareFinal");

    if(!state.finalCache){
      const res = computeFinal();
      state.finalSeed = res.seed;
      state.finalCache = res;
    }
    const {slots} = state.finalCache;
    const texts = genFinalTexts(slots);

    box.style.display = "block";
    shareBtn.style.display = "inline-block";

    await drawFinal(slots);

    // build final text (clickable not necessary here)
    tf.innerHTML =
      `<div class="gen">${escapeHtml(texts.style)}</div>` +
      `<div class="gen" style="margin-top:10px;">${escapeHtml(texts.critique)}</div>`;

    const url = location.href;
    shareText.style.display = "none";
    shareText.textContent = texts.share + "\n\n" + texts.style + "\n\n" + texts.critique + "\n\n" + "Faz a tua própria curadoria: " + url;
  }

  // -------------------------------
  // Global render
  // -------------------------------
  let rendering = false;
  async function renderAll(){
    if(rendering) return;
    rendering = true;
    try{
      await renderM1();
      await renderM2();
      await renderM3();
      await renderM4();
    }finally{
      rendering = false;
    }
  }

  // -------------------------------
  // Event wiring
  // -------------------------------
  async function init(){
    // Sui load attempt (non-blocking)
    const suiBadge = document.getElementById("suiState");
    const res = await loadImage(SUI_URL);
    state.suiOk = res.ok;
    suiBadge.className = res.ok ? "ok" : "warn";
    suiBadge.textContent = res.ok ? "Sui: ok" : "Sui: fallback";
    if(res.ok){
      // decide per session: 90% chance of including Sui presence as "active"
      const sessKey = localStorage.getItem("mob_sui_session") || String(Math.random());
      localStorage.setItem("mob_sui_session", sessKey);
      const rr = mulberry32(hashStr(sessKey));
      // if active, keep slot 53 in m4 slots (already there) and allow final forcing sometimes
      // if not active, we'll still keep slot 53 but it will render procedural (since suiOk true though)
      // so for "90% probability", we treat "active" as 0.90:
      const active = rr() < 0.90;
      if(!active){
        // disable drawing Sui image even if loaded
        state.suiOk = false;
        suiBadge.className = "warn";
        suiBadge.textContent = "Sui: raro (sessão)";
      }
    }

    // M1 button
    document.getElementById("b1").addEventListener("click", () => {
      // change starting regime: reset a few axes in a meaningful way
      const r = mulberry32(seedForMobile(0) ^ (state.step[0]+1));
      // pick a family and bias axes
      const fam = "F" + (1 + Math.floor(r()*12));
      const ax = FAMILY_AXES[fam] || {};
      for(const k of Object.keys(ax)){
        applyImpulse(0, [k], 0.28*ax[k]);
      }
      // refresh slots
      state.m1Slots = [1+Math.floor(r()*40), 1+Math.floor(r()*60), 1+Math.floor(r()*80)].map(s => clamp(s,1,120));
      state.step[0]++;
      dampImpulses();
      renderAll();
    });

    // Word clicks (M1/M3/M4)
    document.getElementById("t1").addEventListener("click", onWordClick);
    document.getElementById("t3").addEventListener("click", onWordClick);
    document.getElementById("t4").addEventListener("click", onWordClick);

    // M2: clicking fragments swaps; clicking verb changes object alt
    const c2 = document.getElementById("c2");
    c2.addEventListener("click", (ev) => {
      const regs = makeHitRegionsM2(c2);
      const rect = c2.getBoundingClientRect();
      const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
      for(const r of regs){
        if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
          // swap front/back, thus swap module1/module3
          state.m2Flip = !state.m2Flip;
          applyImpulse(1, ["configuration","tension"], 0.18);
          state.step[1]++;
          dampImpulses();
          renderAll();
          return;
        }
      }
    });

    document.getElementById("t2").addEventListener("click", (ev) => {
      const el = ev.target;
      if(!el.classList || !el.classList.contains("w")) return;
      // treat ONLY the verb as special: in our render, verb token has opKey equal to stored verb key
      // we simply allow clicking any token, but only verb changes object alt
      const opKey = el.dataset.op || "";
      // heuristic: verb tokens came from Vs; check if key is in verbs
      const isVerb = Vs.some(v => v.key === opKey);
      if(!isVerb) return;

      // change object alt only
      state.m2ObjAlt = (state.m2ObjAlt + 1) % 6;
      applyImpulse(1, ["emergence","configuration"], 0.22);
      state.step[1]++;
      dampImpulses();
      renderAll();
    });

    // M3 fragment clicks
    const c3 = document.getElementById("c3");
    c3.addEventListener("click", (ev) => {
      const regs = makeHitRegionsM3(c3);
      const rect = c3.getBoundingClientRect();
      const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
      for(const rg of regs){
        if(x>=rg.x && x<=rg.x+rg.w && y>=rg.y && y<=rg.y+rg.h){
          const slot = state.m3Slots[rg.i];
          onFragmentClickM3(slot);
          return;
        }
      }
    });

    // Share buttons per mobile
    document.getElementById("s1").addEventListener("click", async () => {
      await shareCanvas(document.getElementById("c1"), document.getElementById("t1").innerText.trim());
    });
    document.getElementById("s2").addEventListener("click", async () => {
      await shareCanvas(document.getElementById("c2"), document.getElementById("t2").innerText.trim());
    });
    document.getElementById("s3").addEventListener("click", async () => {
      await shareCanvas(document.getElementById("c3"), document.getElementById("t3").innerText.trim());
    });
    document.getElementById("s4").addEventListener("click", async () => {
      await shareCanvas(document.getElementById("c4"), document.getElementById("t4").innerText.trim());
    });

    // Final generate + share
    document.getElementById("genFinal").addEventListener("click", async () => {
      await renderFinal();
    });

    document.getElementById("shareFinal").addEventListener("click", async () => {
      const shareText = document.getElementById("shareText");
      if(!state.finalCache){
        await renderFinal();
      }
      const {style, critique, share} = genFinalTexts(state.finalCache.slots);
      const url = location.href;
      const text = `${share}\n\n${style}\n\n${critique}\n\nFaz a tua própria curadoria: ${url}`;
      const result = await shareCanvas(document.getElementById("cf"), text);
      if(result.ok && result.mode==="copy"){
        shareText.style.display = "block";
        shareText.textContent = text + "\n\n(Copiado para a área de transferência — cola no WhatsApp/IG/etc.)";
      }
    });

    // resize
    window.addEventListener("resize", () => renderAll());

    // first render
    renderAll();
  }

  // Run
  init().catch(err => {
    // Never allow blank screen: show error minimally
    console.error(err);
    alert("Erro ao inicializar MÓBILES. Abre a consola (F12) para ver detalhes.");
  });

})();
</script>
</body>
</html>
