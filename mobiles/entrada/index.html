<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg:#f7f2f4;
      --ink:#181315;
      --muted:rgba(24,19,21,.60);
      --muted2:rgba(24,19,21,.45);
      --card:rgba(255,255,255,.55);
      --stroke:rgba(24,19,21,.16);
      --stroke2:rgba(24,19,21,.26);

      /* horror-pastel / bizarria doce */
      --p1: rgba(255,170,210,.35);
      --p2: rgba(170,215,255,.34);
      --p3: rgba(190,255,210,.28);
      --acid: rgba(160,210,120,.18);
      --bruise: rgba(180,150,210,.16);
      --smoke: rgba(40,30,38,.08);
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:
        radial-gradient(1200px 600px at 20% 10%, var(--p1), transparent 60%),
        radial-gradient(1100px 700px at 70% 15%, var(--p2), transparent 60%),
        radial-gradient(900px 700px at 40% 80%, var(--p3), transparent 55%),
        radial-gradient(700px 600px at 80% 85%, var(--bruise), transparent 65%),
        linear-gradient(180deg, rgba(255,255,255,.65), rgba(255,255,255,.45)),
        var(--bg);
      color:var(--ink);
      overflow-x:hidden;
    }

    .wrap{max-width:980px;margin:0 auto;padding:22px 18px 80px;}
    .brand{
      display:flex;align-items:flex-end;gap:10px;
      padding:10px 0 14px 0;
    }
    .brand .t{font-weight:900;letter-spacing:.08em}
    .brand .s{color:var(--muted);font-size:13px}

    .lead{
      margin:18px 0 22px;
      font-size:16px;
      line-height:1.55;
      color:rgba(24,19,21,.78);
      max-width:760px;
      white-space:pre-line;
    }

    .intro{
      margin:30px 0 10px;
      font-size:15px;
      line-height:1.5;
      color:rgba(24,19,21,.82);
      white-space:pre-line;
      max-width:760px;
    }

    .mobile{
      margin:18px 0 40px;
    }

    /* sem “salas”: ainda assim damos um leve “ar” de campo */
    .canvasShell{
      width:100%;
      border-radius:22px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.52), rgba(255,255,255,.26));
      box-shadow:
        0 18px 40px rgba(0,0,0,.06),
        inset 0 1px 0 rgba(255,255,255,.65);
      padding:14px;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:18px;
      background: rgba(255,255,255,.35);
      border:1px solid rgba(24,19,21,.10);
    }

    .row{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:12px;
      align-items:center;
    }

    .btn{
      appearance:none;border:1px solid var(--stroke2);
      background: rgba(255,255,255,.55);
      color:rgba(24,19,21,.90);
      padding:9px 12px;border-radius:999px;
      font-weight:700; font-size:13px;
      cursor:pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,.06);
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px);}
    .btn:active{transform: translateY(0px);}

    .pill{
      margin-left:auto;
      font-size:12px;
      color:var(--muted);
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(24,19,21,.10);
      background: rgba(255,255,255,.35);
    }

    .text{
      margin:14px 6px 0 6px;
      font-size:15px;
      line-height:1.55;
      color:rgba(24,19,21,.84);
      white-space:pre-line;
      max-width:860px;
    }

    .text .w{
      cursor:pointer;
      border-bottom:1px dashed rgba(24,19,21,.22);
      padding-bottom:1px;
    }
    .text .w:hover{
      background: rgba(255,255,255,.55);
      border-bottom-color: rgba(24,19,21,.38);
    }
    .text .verb{
      font-weight:900;
      border-bottom:1px solid rgba(24,19,21,.35);
    }
    .text .lock{
      color:rgba(24,19,21,.78);
    }

    .finalBlock{margin-top:18px;}
    .gate{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
    }

    /* overlay share */
    #overlay{
      position:fixed; inset:0;
      background: rgba(10,8,10,.58);
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      z-index:50;
    }
    .dlg{
      width:min(920px, 96vw);
      border-radius:22px;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.78);
      box-shadow: 0 30px 90px rgba(0,0,0,.28);
      overflow:hidden;
    }
    .dlgHead{
      padding:14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom:1px solid rgba(24,19,21,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.55));
    }
    .dlgHead .h{
      font-weight:900; letter-spacing:.02em;
    }
    .dlgBody{
      padding:14px 16px 16px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .shareGrid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width:860px){
      .shareGrid{grid-template-columns:1fr; }
      .pill{margin-left:0;}
    }
    .shareCanvasWrap{
      border-radius:18px;
      border:1px solid rgba(24,19,21,.12);
      background: rgba(255,255,255,.55);
      padding:10px;
    }
    #shareCanvas{width:100%;height:auto;display:block;border-radius:14px;}
    .shareText{
      width:100%;
      min-height:240px;
      resize:vertical;
      border-radius:14px;
      border:1px solid rgba(24,19,21,.18);
      background: rgba(255,255,255,.65);
      padding:10px 12px;
      font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      color:rgba(24,19,21,.88);
    }
    .shareBtns{display:flex; gap:10px; flex-wrap:wrap;}
    .toast{
      position:fixed;
      left:50%; bottom:14px;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius:999px;
      background: rgba(255,255,255,.85);
      border:1px solid rgba(24,19,21,.16);
      box-shadow: 0 16px 40px rgba(0,0,0,.20);
      font-size:13px;
      color:rgba(24,19,21,.88);
      display:none;
      z-index:60;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="brand">
    <div class="t">MÓBILES</div>
    <div class="s">entrada — máquina curatorial-semântica (suiornotsui)</div>
  </div>

  <div class="lead" id="leadText"></div>

  <!-- M1 -->
  <div class="mobile" id="m1">
    <div class="intro" id="introM1"></div>
    <div class="canvasShell">
      <canvas id="m1Canvas" width="940" height="430" aria-label="Móbile 1"></canvas>
      <div class="row">
        <button class="btn" id="m1Tension">Tensionar o início</button>
        <button class="btn" id="m1Share">Partilhar</button>
        <div class="pill" id="pillState">campo: …</div>
      </div>
      <div class="text" id="m1Text"></div>
    </div>
  </div>

  <!-- M2 -->
  <div class="mobile" id="m2">
    <div class="intro" id="introM2"></div>
    <div class="canvasShell">
      <canvas id="m2Canvas" width="940" height="430" aria-label="Móbile 2"></canvas>
      <div class="row">
        <button class="btn" id="m2Swap">Inverter frente ↔ fundo</button>
        <button class="btn" id="m2Share">Partilhar</button>
        <div class="pill">S–V–O (estrutura)</div>
      </div>
      <div class="text" id="m2Text"></div>
    </div>
  </div>

  <!-- M3 -->
  <div class="mobile" id="m3">
    <div class="intro" id="introM3"></div>
    <div class="canvasShell">
      <canvas id="m3Canvas" width="940" height="430" aria-label="Móbile 3"></canvas>
      <div class="row">
        <button class="btn" id="m3Share">Partilhar</button>
        <div class="pill">foco / estilo (intensificação)</div>
      </div>
      <div class="text" id="m3Text"></div>
    </div>
  </div>

  <!-- M4 -->
  <div class="mobile" id="m4">
    <div class="intro" id="introM4"></div>
    <div class="canvasShell">
      <canvas id="m4Canvas" width="940" height="430" aria-label="Móbile 4"></canvas>
      <div class="row">
        <button class="btn" id="m4Share">Partilhar</button>
        <div class="pill">corpo sonoro / colapso</div>
      </div>
      <div class="text" id="m4Text"></div>
    </div>
  </div>

  <!-- FINAL -->
  <div class="mobile finalBlock" id="final">
    <div class="intro" id="finalIntro"></div>
    <div class="canvasShell">
      <canvas id="finalCanvas" width="940" height="500" aria-label="Exposição final"></canvas>
      <div class="row">
        <button class="btn" id="btnFinalize">Gerar a minha exposição</button>
        <button class="btn" id="finalShare">Partilhar</button>
        <div class="pill">10 fragmentos</div>
      </div>
      <div class="text" id="finalText"></div>
      <div class="gate" id="weeklyGate"></div>
    </div>
  </div>
</div>

<div id="overlay">
  <div class="dlg">
    <div class="dlgHead">
      <div class="h" id="shareTitle">Partilhar</div>
      <button class="btn" onclick="closeShare()">Fechar</button>
    </div>
    <div class="dlgBody">
      <div style="color:rgba(24,19,21,.70);font-size:13px" id="shareNote"></div>

      <div class="shareGrid">
        <div class="shareCanvasWrap">
          <canvas id="shareCanvas" width="900" height="1200"></canvas>
        </div>
        <div>
          <textarea class="shareText" id="shareText"></textarea>
          <div class="shareBtns" style="margin-top:10px">
            <button class="btn" id="copyTextBtn">Copiar texto</button>
            <button class="btn" id="downloadBtn">Baixar imagem (PNG)</button>
            <button class="btn" id="nativeShareBtn">Partilhar…</button>
          </div>
          <div style="margin-top:10px;color:rgba(24,19,21,.55);font-size:12px">
            Dica: em alguns navegadores o botão “Partilhar…” só funciona no telemóvel.
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ============================================================
   CONFIG / PATHS (robusto para /mobiles/entrada/)
============================================================ */
const BASE_MOBILES = new URL("../", location.href);           // .../mobiles/
const SUI_JSON_URL = new URL("sui.json", BASE_MOBILES).toString();

/* ============================================================
   TEXTOS FIXOS (aprovados)
============================================================ */
const TEXT_OPENING =
`Operas aqui a tua própria curadoria.
A artista é suiornotsui.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.
Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto —
aquilo que nunca aparece —
sustenta o desejo de continuar.`;

const INTRO_M1 =
`Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.`;

const INTRO_M2 =
`Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.`;

const INTRO_M3 =
`O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.`;

const INTRO_M4 =
`Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.`;

const TEXT_FINAL_CLOSING =
`O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.`;

/* ============================================================
   UTIL
============================================================ */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function rnd(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

function toast(msg){
  const t=document.getElementById("toast");
  t.textContent=msg;
  t.style.display="block";
  clearTimeout(toast._tm);
  toast._tm=setTimeout(()=>t.style.display="none", 1600);
}

/* ============================================================
   CAMPO VISUAL (120 slots / 12 famílias)
============================================================ */
const FAMS = [
  {id:"F1", name:"continuidade linear", axes:{front:-0.2,dense:+0.1,cont:+0.8}},
  {id:"F2", name:"corte vertical",      axes:{front:+0.4,dense:+0.4,cont:-0.7}},
  {id:"F3", name:"deslocamento oblíquo",axes:{front:+0.6,dense:-0.2,cont:-0.2}},
  {id:"F4", name:"ritmo repetitivo",    axes:{front:-0.1,dense:+0.5,cont:+0.2}},
  {id:"F5", name:"ruptura",             axes:{front:+0.2,dense:+0.7,cont:-0.8}},
  {id:"F6", name:"densidade",           axes:{front:-0.1,dense:+0.9,cont:-0.2}},
  {id:"F7", name:"rarefação",           axes:{front:-0.3,dense:-0.9,cont:+0.4}},
  {id:"F8", name:"centro instável",     axes:{front:+0.2,dense:+0.5,cont:+0.1}},
  {id:"F9", name:"campo homogêneo",     axes:{front:+0.4,dense:+0.1,cont:-0.8}},
  {id:"F10",name:"direção múltipla",    axes:{front:+0.4,dense:-0.2,cont:-0.6}},
  {id:"F11",name:"contorno",            axes:{front:-0.1,dense:+0.6,cont:+0.2}},
  {id:"F12",name:"massa",               axes:{front:-0.1,dense:+0.8,cont:-0.4}},
];

function slotId(i){ return "slot_" + String(i).padStart(3,"0"); }

const FIELD = { slots:[] };
let SUI_MAP = null;

function buildField(){
  FIELD.slots = [];
  for(let i=1;i<=120;i++){
    const fam = FAMS[(i-1)%12];
    const v = Math.floor((i-1)/12) % 10;
    const t = (v-4.5)/4.5;
    const axes = {
      front: clamp(fam.axes.front + 0.18*t + rnd(-0.03,0.03), -1, 1),
      dense: clamp(fam.axes.dense + 0.22*t + rnd(-0.03,0.03), -1, 1),
      cont:  clamp(fam.axes.cont  - 0.20*t + rnd(-0.03,0.03), -1, 1),
    };
    FIELD.slots.push({ id:slotId(i), idx:i, fam:fam.id, famName:fam.name, v, axes, sui:null, _img:null });
  }
}

/* --- Sui: carrega /mobiles/sui.json ({"53":"assets/sui/slot_053.jpg"}) --- */
async function tryLoadSui(){
  try{
    const res = await fetch(SUI_JSON_URL + "?cache=" + Date.now(), { cache:"no-store" });
    if(!res.ok) throw new Error("sui.json não carregou");
    const data = await res.json();
    SUI_MAP = data;

    for(const s of FIELD.slots){
      const key = String(s.idx); // "53"
      if(SUI_MAP && SUI_MAP[key]){
        const rel = SUI_MAP[key]; // "assets/sui/slot_053.jpg"
        s.sui = { path: new URL(rel.replace(/^\.?\/*/,""), BASE_MOBILES).toString() };
      }
    }
  }catch(e){
    SUI_MAP = null;
  }

  // fallback mínimo: se falhou, ainda assim fixa o slot 53 no caminho conhecido
  const s53 = FIELD.slots[52];
  if(!s53.sui){
    s53.sui = { path: new URL("assets/sui/slot_053.jpg", BASE_MOBILES).toString() };
  }
}

/* ============================================================
   ESTADO GLOBAL (tensivo + fonográfico)
============================================================ */
const G = {
  front: 0.0,   // -1 fundo / +1 frente
  dense: 0.0,   // -1 rarefeito / +1 denso
  cont:  0.0,   // -1 corte / +1 continuidade
  ph: { dry:0, voiced:0, open:0 }, // surdas / sonoras / fricativas
  pressure: 0.0,
  birthMode: 0,
  collapse: 0,
};

const Mob = {
  m1:{ slots:null },
  m2:{ slots:null, flip:false, subjKey:null, objKey:null, verbKey:null, verbIx:0 },
  m3:{ slots:null, focusFam:null, intensity:0, clicks:0 },
  m4:{ slots:null, focusPh:null, intensity:0, clicks:0 },
  final:{ ready:false, slots:null }
};

function applyDelta(d){
  G.front = clamp(G.front + (d.front||0), -1, 1);
  G.dense = clamp(G.dense + (d.dense||0), -1, 1);
  G.cont  = clamp(G.cont  + (d.cont ||0), -1, 1);
  G.pressure = clamp(G.pressure + (d.pressure||0), 0, 3);

  if(d.ph){
    G.ph.dry    = clamp(G.ph.dry    + (d.ph.dry||0),    -1.2, 1.2);
    G.ph.voiced = clamp(G.ph.voiced + (d.ph.voiced||0), -1.2, 1.2);
    G.ph.open   = clamp(G.ph.open   + (d.ph.open||0),   -1.2, 1.2);
  }
  updatePill();
}

function updatePill(){
  const s = (x, a, b)=> x< -0.18 ? a : x>0.18 ? b : "meio";
  document.getElementById("pillState").textContent =
    `campo: ${s(G.front,"fundo","frente")} · ${s(G.dense,"rarefeito","denso")} · ${s(G.cont,"corte","contínuo")}`;
}

function phMode(){
  const d=Math.abs(G.ph.dry), v=Math.abs(G.ph.voiced), o=Math.abs(G.ph.open);
  if(d>=v && d>=o) return "surda";
  if(v>=d && v>=o) return "sonora";
  return "fricativa";
}

/* ============================================================
   SCORE / SAMPLE (seleção tensiva + “gramática visual”)
============================================================ */
function slotScore(slot){
  const dx =
    Math.abs(slot.axes.front - G.front) * 0.9 +
    Math.abs(slot.axes.dense - G.dense) * 0.7 +
    Math.abs(slot.axes.cont  - G.cont ) * 1.0;

  // afinidade fonográfica: dry ~ corte, open ~ continuidade
  const phBonus =
    (G.ph.dry    * (-slot.axes.cont))*0.25 +
    (G.ph.open   * ( slot.axes.cont))*0.22 +
    (G.ph.voiced * ( slot.axes.dense))*0.15;

  let score = -(dx) + phBonus + rnd(-0.06,0.06);

  // viés leve: Sui tem prioridade (mas não garante sozinha)
  if(slot.sui) score += 0.95;

  return score;
}

function sampleSlots(n){
  const pool = FIELD.slots.slice();
  pool.sort((a,b)=> slotScore(b) - slotScore(a));
  const K = Math.min(36, pool.length);
  const top = pool.slice(0,K);
  for(let i=top.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [top[i], top[j]] = [top[j], top[i]];
  }
  return top.slice(0,n);
}

/* --- regra Sui: em cada móbile, 90% força pelo menos 1 slot 53 --- */
function ensureSui(slots){
  const want = (Math.random() < 0.90);
  if(!want) return slots;

  const has = slots.some(s => s.idx===53 && s.sui);
  if(has) return slots;

  const s53 = FIELD.slots[52]; // idx 53
  if(!s53 || !s53.sui) return slots;

  // substitui o último (ou um aleatório) para manter o n
  const ix = Math.max(0, slots.length-1);
  const out = slots.slice();
  out[ix] = s53;
  return out;
}

/* ============================================================
   LÉXICO (70 operadores × 3 realizações) — exatamente como aprovado
============================================================ */
const LEX = {
  /* substantivos 1..28 */
  vestigio:{surda:"traço",sonora:"marca",fricativa:"sombra"},
  sopro:{surda:"pingo",sonora:"bafo",fricativa:"suspiro"},
  dobra:{surda:"prega",sonora:"curva",fricativa:"flexão"},
  canto:{surda:"quina",sonora:"beira",fricativa:"franja"},
  margem:{surda:"limite",sonora:"borda",fricativa:"fronteira"},
  poeira:{surda:"pó",sonora:"bruma",fricativa:"cinza"},
  silencio:{surda:"pausa",sonora:"calma",fricativa:"sussurro"},
  rastro:{surda:"pegada",sonora:"vesta",fricativa:"resíduo"},
  fragmento:{surda:"cortezinho",sonora:"bordado",fricativa:"desfiado"},
  detalhe:{surda:"ponto",sonora:"miolo",fricativa:"nuança"},
  lembranca:{surda:"nota",sonora:"memória",fricativa:"recordação"},
  demora:{surda:"pausa",sonora:"espera",fricativa:"suspensão"},
  intervalo:{surda:"corte",sonora:"entre",fricativa:"fresta"},
  eco:{surda:"toque",sonora:"resposta",fricativa:"ressonância"},
  resto:{surda:"ruga",sonora:"sobra",fricativa:"resíduo"},
  plano:{surda:"linha",sonora:"base",fricativa:"superfície"},
  camada:{surda:"capa",sonora:"nível",fricativa:"espessura"},
  textura:{surda:"trama",sonora:"tecido",fricativa:"fibra"},
  superficie:{surda:"pele",sonora:"face",fricativa:"película"},
  escala:{surda:"passo",sonora:"medida",fricativa:"proporção"},
  ritmo:{surda:"pulso",sonora:"cadência",fricativa:"fluência"},
  materia:{surda:"corpo",sonora:"substância",fricativa:"massa"},
  presenca:{surda:"toque",sonora:"vulto",fricativa:"sombra"},
  tensao:{surda:"nó",sonora:"peso",fricativa:"pressão"},
  campo:{surda:"plano",sonora:"território",fricativa:"ambiente"},
  emergencia:{surda:"salto",sonora:"aparição",fricativa:"insurgência"},
  configuracao:{surda:"forma",sonora:"estrutura",fricativa:"composição"},
  cessacao:{surda:"corte",sonora:"encerramento",fricativa:"silenciamento"},

  /* verbos 29..50 */
  aproximar:{surda:"chegar",sonora:"beirar",fricativa:"esfumar"},
  reparar:{surda:"notar",sonora:"observar",fricativa:"esmiuçar"},
  tocar:{surda:"tatear",sonora:"roçar",fricativa:"aflorar"},
  escutar:{surda:"ouvir",sonora:"acolher",fricativa:"sintonizar"},
  demorarV:{surda:"parar",sonora:"permanecer",fricativa:"alongar-se"},
  pousar:{surda:"cair",sonora:"assentar",fricativa:"deslizar"},
  acompanhar:{surda:"seguir",sonora:"amparar",fricativa:"entrelaçar"},
  cuidar:{surda:"zelar",sonora:"nutrir",fricativa:"suavizar"},

  recortar:{surda:"cortar",sonora:"delimitar",fricativa:"fissurar"},
  deslocar:{surda:"mover",sonora:"transferir",fricativa:"deslizar"},
  sustentar:{surda:"segurar",sonora:"manter",fricativa:"suspender"},
  distribuir:{surda:"partir",sonora:"organizar",fricativa:"espalhar"},
  sobrepor:{surda:"cobrir",sonora:"acumular",fricativa:"sobrefluir"},
  atravessar:{surda:"passar",sonora:"cruzar",fricativa:"permeiar"},
  insinuar:{surda:"sugerir",sonora:"indicar",fricativa:"sussurrar"},

  insistir:{surda:"bater",sonora:"persistir",fricativa:"ressoar"},
  interromper:{surda:"cortar",sonora:"cessar",fricativa:"esvair-se"},
  fixar:{surda:"marcar",sonora:"estabelecer",fricativa:"sedimentar"},
  suspender:{surda:"parar",sonora:"reter",fricativa:"flutuar"},
  reter:{surda:"prender",sonora:"guardar",fricativa:"conservar"},
  abandonar:{surda:"largar",sonora:"deixar",fricativa:"dissolver"},
  transformar:{surda:"romper",sonora:"converter",fricativa:"transfigurar"},

  /* adjetivos 51..62 */
  leve:{surda:"claro",sonora:"brando",fricativa:"suave"},
  minimo:{surda:"curto",sonora:"pequeno",fricativa:"sutil"},
  fragil:{surda:"ténue",sonora:"delicado",fricativa:"sensível"},
  tenue:{surda:"fino",sonora:"delgado",fricativa:"esfumado"},
  quaseAdj:{surda:"breve",sonora:"próximo",fricativa:"difuso"},

  opaco:{surda:"denso",sonora:"turvo",fricativa:"fosco"},
  poroso:{surda:"aberto",sonora:"vazado",fricativa:"permeável"},
  irregular:{surda:"torto",sonora:"instável",fricativa:"assimétrico"},
  difuso:{surda:"solto",sonora:"amplo",fricativa:"disperso"},

  latente:{surda:"oculto",sonora:"presente",fricativa:"subjacente"},
  instavel:{surda:"quebrado",sonora:"oscilante",fricativa:"flutuante"},
  provisorio:{surda:"breve",sonora:"mutável",fricativa:"transitório"},

  /* advérbios 63..70 */
  ainda:{surda:"já",sonora:"agora",fricativa:"sempre"},
  quaseAdv:{surda:"logo",sonora:"perto",fricativa:"talvez"},
  lentamente:{surda:"aos poucos",sonora:"com calma",fricativa:"suavemente"},
  porVezes:{surda:"às vezes",sonora:"frequentemente",fricativa:"ocasionalmente"},
  sempre:{surda:"toda vez",sonora:"continuamente",fricativa:"infinitamente"},
  raramente:{surda:"quase nunca",sonora:"poucas vezes",fricativa:"esporadicamente"},
  talvez:{surda:"quem sabe",sonora:"possivelmente",fricativa:"eventualmente"},
  agora:{surda:"já",sonora:"neste momento",fricativa:"presentemente"},
};

const N_SENS = ["vestigio","sopro","dobra","canto","margem","poeira","silencio","rastro","fragmento","detalhe"];
const N_MEM  = ["lembranca","demora","intervalo","eco","resto","cessacao"];
const N_PLAS = ["plano","camada","textura","superficie","escala","ritmo","materia"];
const N_CUR  = ["presenca","tensao","campo","emergencia","configuracao"];

const V_SENS = ["aproximar","reparar","tocar","escutar","demorarV","pousar","acompanhar","cuidar"];
const V_COMP = ["recortar","deslocar","sustentar","distribuir","sobrepor","atravessar","insinuar"];
const V_DEC  = ["insistir","interromper","fixar","suspender","reter","abandonar","transformar"];

const ADJ_S  = ["leve","minimo","fragil","tenue","quaseAdj"];
const ADJ_P  = ["opaco","poroso","irregular","difuso"];
const ADJ_C  = ["latente","instavel","provisorio"];

const ADV    = ["ainda","quaseAdv","lentamente","porVezes","sempre","raramente","talvez","agora"];

/* ============================================================
   REALIZAÇÃO (plano da expressão guiado pelo modo fonográfico)
============================================================ */
function realize(key){
  const mode = phMode();
  const row = LEX[key];
  if(!row) return key;
  if(mode==="surda") return row.surda;
  if(mode==="sonora") return row.sonora;
  return row.fricativa;
}

/* ============================================================
   GERADOR DE TEXTO (voz curatorial) — maior em M1/M3/M4
============================================================ */
function maybeAdj(){
  const p = clamp(0.18 + Math.abs(G.dense)*0.40 + Math.abs(G.front)*0.20, 0.10, 0.75);
  if(Math.random()>p) return null;
  const pool = (Math.abs(G.cont)>0.25) ? ADJ_S.concat(ADJ_P) : ADJ_P.concat(ADJ_C);
  return realize(pick(pool));
}
function maybeAdv(){
  const p = clamp(0.14 + Math.abs(G.cont)*0.35 + Math.abs(G.pressure)*0.10, 0.08, 0.60);
  if(Math.random()>p) return null;
  return realize(pick(ADV));
}
function Npick(pool){ return realize(pick(pool)); }
function Vpick(pool){ return realize(pick(pool)); }

function genCuratorialParagraph(kind){
  // linhas “catálogo”, sem virar aula
  const nA = (G.front>0.25) ? Npick(N_CUR) : Npick(N_SENS);
  const nB = (G.dense>0.25) ? Npick(N_PLAS) : Npick(N_MEM);
  const nC = (G.cont>0.20) ? Npick(N_SENS) : Npick(N_CUR);

  const vA = (G.cont>0.15) ? Vpick(V_SENS) : Vpick(V_COMP);
  const vB = (G.pressure>0.55) ? Vpick(V_DEC) : Vpick(V_COMP);

  const adj1 = maybeAdj();
  const adv1 = maybeAdv();

  const T = [];

  if(kind==="m1"){
    T.push(`No começo, ${nA}${adj1?(" "+adj1):""} aparece como eixo — e isso já inclina o campo.`);
    T.push(`O que nasce aqui ${vA} ${nB}${adv1?(", "+adv1):""}.`);
    T.push(`O resto não some: fica como ${Npick(N_MEM)} à espera de outra tensão.`);
    T.push(`Se o campo endurece, não é ruído: é ${Npick(["tensao","configuracao","cessacao"])} em formação.`);
    return T.join(" ");
  }

  if(kind==="m3"){
    T.push(`Onde tocas, ${nC} ganha relevo; onde evitas, ${Npick(N_CUR)} recua.`);
    T.push(`Insistir em ${Npick(N_PLAS)} faz ${Npick(N_SENS)} responder como estilo.`);
    T.push(`Aos poucos, a tua curadoria deixa de “escolher imagens” e começa a formar campo.`);
    T.push(`${Npick(["presenca","tensao","configuracao"])} não é tema: é consequência do teu gesto.`);
    return T.join(" ");
  }

  if(kind==="m4"){
    const mode = phMode();
    const label = (mode==="surda") ? "plosivas surdas (corte seco)" :
                  (mode==="sonora") ? "plosivas sonoras (massa e peso)" :
                  "fricativas (passagem e arranho)";
    T.push(`O regime atual: ${label}.`);
    T.push(`Quando repetes um corpo, o resto do campo se reescreve junto — até ceder.`);
    T.push(`Se satura, não é bug: é ${Npick(["cessacao","resto","intervalo"])} como evento.`);
    return T.join(" ");
  }

  return "";
}

/* ============================================================
   M2 — S–V–O (restrito) + regras estritas
============================================================ */
const M2_VERBS = [
  ...V_COMP, ...V_SENS, ...V_DEC
];

function m2InitIfNeeded(){
  if(Mob.m2.subjKey && Mob.m2.objKey && Mob.m2.verbKey) return;

  const subj = (G.front>0.22) ? pick(N_CUR) : pick(N_SENS);
  const obj  = (G.dense>0.22) ? pick(N_PLAS) : pick(N_MEM);
  Mob.m2.subjKey = subj;
  Mob.m2.objKey  = obj;

  Mob.m2.verbIx = (Math.random()*M2_VERBS.length)|0;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];
}

function m2Block(nKey){
  const n = realize(nKey);
  // adjs/advs dependem do estado global (como combinamos)
  const adjProb = clamp(0.22 + Math.abs(G.dense)*0.32 + Math.abs(G.front)*0.18, 0.18, 0.68);
  const advProb = clamp(0.12 + Math.abs(G.cont)*0.26, 0.10, 0.52);
  const adj = (Math.random()<adjProb) ? maybeAdj() : null;
  const adv = (Math.random()<advProb) ? maybeAdv() : null;

  let s = n;
  if(adj) s += " " + adj;
  if(adv) s += " " + adv;
  return s;
}

function renderM2Text(){
  m2InitIfNeeded();
  const el = document.getElementById("m2Text");
  el.innerHTML = "";

  // swap estrito do texto: bloco1<->bloco3 quando flip
  const subjKey = Mob.m2.flip ? Mob.m2.objKey : Mob.m2.subjKey;
  const objKey  = Mob.m2.flip ? Mob.m2.subjKey : Mob.m2.objKey;

  const block1 = m2Block(subjKey);
  const block3 = m2Block(objKey);

  const s1 = document.createElement("span");
  s1.className="lock";
  s1.textContent = block1 + " ";

  const sv = document.createElement("span");
  sv.className="w verb";
  sv.textContent = realize(Mob.m2.verbKey) + " ";
  sv.addEventListener("click", (e)=>{ e.stopPropagation(); doM2VerbClick(); });

  const s3 = document.createElement("span");
  s3.className="lock";
  s3.textContent = block3 + ".";

  el.appendChild(s1);
  el.appendChild(sv);
  el.appendChild(s3);
}

/* regra: inverter só troca posições; não reamostra */
function doM2Swap(){
  Mob.m2.flip = !Mob.m2.flip;
  applyDelta({ front: (Mob.m2.flip? -0.08:+0.08), pressure: 0.03, cont:rnd(-0.02,0.02) });
  rerenderM2(true); // redesenha, mas mantém slots
}

/* regra: clicar no verbo muda SOMENTE o objeto (bloco 3) */
function doM2VerbClick(){
  Mob.m2.verbIx = (Mob.m2.verbIx + 1) % M2_VERBS.length;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];

  const pool = (G.dense>0.18) ? N_PLAS.concat(N_MEM) : N_MEM.concat(N_SENS);
  Mob.m2.objKey = pick(pool);

  applyDelta({ pressure: 0.06, dense:rnd(-0.04,0.04), cont:rnd(-0.04,0.04) });
  rerenderM2(false);
}

/* ============================================================
   DESENHO (cenários + slots)
============================================================ */
function drawScene(ctx, key, W, H){
  ctx.clearRect(0,0,W,H);

  // “névoa” pastel + resto sombrio
  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.22)";
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  // manchas suaves
  const g1 = ctx.createRadialGradient(W*0.20,H*0.20,20, W*0.20,H*0.20, W*0.70);
  g1.addColorStop(0,"rgba(255,170,210,.28)");
  g1.addColorStop(1,"rgba(255,170,210,0)");
  ctx.fillStyle=g1; ctx.fillRect(0,0,W,H);

  const g2 = ctx.createRadialGradient(W*0.75,H*0.18,30, W*0.75,H*0.18, W*0.72);
  g2.addColorStop(0,"rgba(170,215,255,.26)");
  g2.addColorStop(1,"rgba(170,215,255,0)");
  ctx.fillStyle=g2; ctx.fillRect(0,0,W,H);

  // cenários visíveis + contornos demarcados (como você pediu)
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(24,19,21,.22)";
  ctx.fillStyle = "rgba(255,255,255,.10)";

  if(key==="m1"){
    // berço / arco do móbile
    ctx.beginPath();
    ctx.moveTo(W*0.10,H*0.18);
    ctx.quadraticCurveTo(W*0.50,H*0.04, W*0.90,H*0.18);
    ctx.stroke();
    // fios
    [0.18,0.50,0.82].forEach(x=>{
      ctx.beginPath();
      ctx.moveTo(W*x,H*0.18);
      ctx.lineTo(W*x,H*0.34);
      ctx.stroke();
    });
  }
  if(key==="m2"){
    // montanhas + horizonte
    ctx.beginPath();
    ctx.moveTo(0,H*0.58);
    ctx.lineTo(W*0.20,H*0.42);
    ctx.lineTo(W*0.38,H*0.58);
    ctx.lineTo(W*0.55,H*0.36);
    ctx.lineTo(W*0.76,H*0.58);
    ctx.lineTo(W,H*0.46);
    ctx.lineTo(W,H);
    ctx.lineTo(0,H);
    ctx.closePath();
    ctx.fillStyle="rgba(255,255,255,.12)";
    ctx.fill();
    ctx.strokeStyle="rgba(24,19,21,.18)";
    ctx.stroke();

    // “animais” mínimos
    ctx.strokeStyle="rgba(24,19,21,.20)";
    for(let i=0;i<7;i++){
      const x = W*(0.12 + i*0.12) + rnd(-8,8);
      const y = H*(0.70 + rnd(-0.02,0.02));
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+8,y-3);
      ctx.lineTo(x+14,y);
      ctx.stroke();
    }
  }
  if(key==="m3"){
    // labirinto
    ctx.strokeStyle="rgba(24,19,21,.18)";
    for(let y=0;y<7;y++){
      for(let x=0;x<11;x++){
        if(Math.random()<0.35){
          ctx.strokeRect(W*0.05 + x*(W*0.085), H*0.10 + y*(H*0.11), W*0.075, H*0.095);
        }
      }
    }
  }
  if(key==="m4"){
    // escadas escherianas
    ctx.strokeStyle="rgba(24,19,21,.20)";
    const steps=10;
    for(let i=0;i<steps;i++){
      const x = W*0.12 + i*(W*0.06);
      const y = H*0.65 - i*(H*0.04);
      ctx.strokeRect(x,y, W*0.12, H*0.06);
    }
    for(let i=0;i<steps;i++){
      const x = W*0.55 + i*(W*0.03);
      const y = H*0.28 + i*(H*0.05);
      ctx.strokeRect(x,y, W*0.14, H*0.06);
    }
  }
  ctx.restore();
}

function slotFamily(slot){
  // F1..F12 => número 1..12
  const n = parseInt((slot.fam||"F1").replace("F",""),10);
  return isNaN(n)?1:n;
}

async function preloadSlotImage(slot, onload){
  if(!slot.sui) return;
  if(slot._img) return;
  const img = new Image();
  img.crossOrigin="anonymous";
  // cache-buster leve para evitar “sumiu depois do F5”
  img.src = slot.sui.path + "?v=" + Date.now();
  slot._img = img;
  img.onload = onload;
}

function drawProcedural(ctx, slot, x,y,w,h){
  // gramática visual: famílias + variações; estilo horror-pastel
  const fam = slotFamily(slot);
  ctx.save();
  ctx.translate(x,y);

  // base
  ctx.fillStyle = "rgba(255,255,255,.55)";
  ctx.fillRect(0,0,w,h);

  // “resto mórbido”
  ctx.fillStyle = "rgba(40,30,38,.07)";
  ctx.fillRect(0,0,w,h);

  // cor por família (pastel estranho)
  const hue = (fam*27 + slot.v*11) % 360;
  ctx.fillStyle = `hsla(${hue}, 65%, 80%, 0.26)`;
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle = "rgba(24,19,21,.30)";
  ctx.lineWidth = 2;

  // desenha “regimes”
  if(fam===1){
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(0, h*(0.15+i*0.14));
      ctx.lineTo(w, h*(0.15+i*0.14)+rnd(-6,6));
      ctx.stroke();
    }
  } else if(fam===2){
    for(let i=0;i<5;i++){
      const xx = w*(0.18+i*0.16)+rnd(-6,6);
      ctx.beginPath();
      ctx.moveTo(xx,0);
      ctx.lineTo(xx,h);
      ctx.stroke();
    }
  } else if(fam===3){
    ctx.beginPath();
    ctx.moveTo(w*0.1,h*0.8);
    ctx.lineTo(w*0.9,h*0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w*0.15,h*0.55);
    ctx.lineTo(w*0.85,h*0.15);
    ctx.stroke();
  } else if(fam===4){
    for(let i=0;i<7;i++){
      ctx.beginPath();
      ctx.arc(w*(0.15+i*0.12), h*(0.55+rnd(-0.08,0.08)), 9+rnd(-3,3), 0, Math.PI*2);
      ctx.stroke();
    }
  } else if(fam===5){
    ctx.beginPath();
    ctx.moveTo(w*0.1,h*0.1);
    ctx.lineTo(w*0.9,h*0.9);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w*0.9,h*0.1);
    ctx.lineTo(w*0.1,h*0.9);
    ctx.stroke();
  } else if(fam===6){
    for(let i=0;i<10;i++){
      ctx.fillStyle = `rgba(24,19,21,${0.04+rnd(0,0.06)})`;
      ctx.fillRect(rnd(0,w), rnd(0,h), rnd(18,60), rnd(12,48));
    }
  } else if(fam===7){
    ctx.fillStyle="rgba(255,255,255,.62)";
    ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="rgba(24,19,21,.18)";
    ctx.strokeRect(w*0.10,h*0.18,w*0.80,h*0.64);
  } else if(fam===8){
    ctx.beginPath();
    ctx.strokeRect(w*0.18+rnd(-10,10), h*0.18+rnd(-10,10), w*0.64, h*0.64);
  } else if(fam===9){
    ctx.fillStyle="rgba(24,19,21,.06)";
    for(let i=0;i<60;i++){
      ctx.fillRect(rnd(0,w), rnd(0,h), 2, 2);
    }
  } else if(fam===10){
    ctx.beginPath();
    ctx.moveTo(w*0.15,h*0.25);
    ctx.lineTo(w*0.85,h*0.25);
    ctx.lineTo(w*0.50,h*0.85);
    ctx.closePath();
    ctx.stroke();
  } else if(fam===11){
    ctx.beginPath();
    ctx.strokeRect(w*0.12,h*0.12,w*0.76,h*0.76);
    ctx.beginPath();
    ctx.strokeRect(w*0.22,h*0.22,w*0.56,h*0.56);
  } else {
    ctx.fillStyle="rgba(24,19,21,.10)";
    ctx.fillRect(w*0.15,h*0.18,w*0.70,h*0.62);
  }

  ctx.restore();
}

function drawSlot(ctx, slot, x,y,w,h){
  // moldura MUITO visível (pedido)
  ctx.save();
  ctx.shadowColor="rgba(0,0,0,.12)";
  ctx.shadowBlur=18;
  ctx.shadowOffsetY=10;

  ctx.fillStyle="rgba(255,255,255,.60)";
  ctx.fillRect(x,y,w,h);

  ctx.shadowColor="transparent";
  ctx.lineWidth=3;
  ctx.strokeStyle="rgba(24,19,21,.34)";
  ctx.strokeRect(x,y,w,h);

  // interior
  if(slot.sui && slot._img && slot._img.complete && slot._img.naturalWidth){
    ctx.save();
    ctx.beginPath();
    ctx.rect(x+3,y+3,w-6,h-6);
    ctx.clip();
    ctx.drawImage(slot._img, x+3, y+3, w-6, h-6);
    ctx.restore();
  } else {
    drawProcedural(ctx, slot, x+3,y+3,w-6,h-6);
  }

  ctx.restore();
}

/* ============================================================
   DRAW MOBILE (com cache de slots por móbile)
============================================================ */
const HITS = { m1:[], m2:[], m3:[], m4:[], final:[] };

async function drawMobile(canvas, key, count){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  drawScene(ctx, key, W, H);

  // slots persistem por móbile (critico para M2 inverter)
  if(!Mob[key].slots){
    let slots = sampleSlots(count);
    slots = ensureSui(slots);
    Mob[key].slots = slots;
  }
  const slots = Mob[key].slots;

  // preload Sui (se presente)
  for(const s of slots){
    if(s.sui && !s._img){
      await preloadSlotImage(s, ()=>{
        // redesenha apenas o canvas atual quando a imagem carregar
        rerenderOne(key);
      });
    }
  }

  const hits = [];
  if(key==="m1"){
    const w = W*0.22, h = H*0.30;
    const xs = [W*0.18, W*0.50, W*0.82];
    const ys = [H*0.42, H*0.42, H*0.42];
    for(let i=0;i<3;i++){
      const x = xs[i]-w/2;
      const y = ys[i]-h/2;
      drawSlot(ctx, slots[i], x,y,w,h);
      hits.push({x,y,w,h,slot:slots[i]});
    }
  } else if(key==="m2"){
    const bigW=W*0.36, bigH=H*0.42;
    const smallW=W*0.26, smallH=H*0.30;

    // IMPORTANTÍSSIMO: NÃO reamostrar; usa o par fixo Mob.m2.slots
    const a = slots[0];
    const b = slots[1];

    const frontSlot = Mob.m2.flip ? b : a;
    const backSlot  = Mob.m2.flip ? a : b;

    let xB=W*0.66 - smallW/2;
    let yB=H*0.48 - smallH/2;
    drawSlot(ctx, backSlot, xB,yB,smallW,smallH);
    hits.push({x:xB,y:yB,w:smallW,h:smallH,slot:backSlot});

    let xF=W*0.30 - bigW/2;
    let yF=H*0.60 - bigH/2;
    drawSlot(ctx, frontSlot, xF,yF,bigW,bigH);
    hits.push({x:xF,y:yF,w:bigW,h:bigH,slot:frontSlot});
  } else if(key==="m3"){
    const baseW=W*0.18, baseH=H*0.24;
    for(let i=0;i<7;i++){
      const s=slots[i];
      const x = W*(0.10 + (i%4)*0.20) + rnd(-14,14);
      const y = H*(0.18 + Math.floor(i/4)*0.34) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.14);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.12);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  } else if(key==="m4"){
    const baseW=W*0.20, baseH=H*0.22;
    for(let i=0;i<5;i++){
      const s=slots[i];
      const x = W*(0.12 + i*0.17) + rnd(-10,10);
      const y = H*(0.22 + (i%2)*0.22) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.12);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.10);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  } else if(key==="final"){
    const baseW=W*0.19, baseH=H*0.22;
    for(let i=0;i<10;i++){
      const s=slots[i];
      const x = W*(0.08 + (i%5)*0.18) + rnd(-10,10);
      const y = H*(0.16 + Math.floor(i/5)*0.34) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.14);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.12);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  }

  HITS[key] = hits;
}

/* ============================================================
   TEXT RENDER (restrições por móbile)
============================================================ */
function setTextPlain(el, text){
  el.textContent = text;
}

function setTextInteractive(el, text, key){
  // M3: palavras clicáveis
  // M4: palavras clicáveis (com data-ph)
  el.innerHTML = "";
  const parts = text.split(/\s+/).filter(Boolean);
  for(const p of parts){
    const span = document.createElement("span");
    span.className="w";
    span.textContent = p + " ";
    if(key==="m4"){
      span.dataset.ph = phMode(); // etiqueta do regime atual (reforça)
    }
    el.appendChild(span);
  }
}

/* ============================================================
   RERENDER por partes
============================================================ */
async function rerenderOne(key){
  if(key==="m1") return rerenderM1();
  if(key==="m2") return rerenderM2(true);
  if(key==="m3") return rerenderM3();
  if(key==="m4") return rerenderM4(true);
  if(key==="final") return rerenderFinal();
}

async function rerenderM1(){
  await drawMobile(document.getElementById("m1Canvas"), "m1", 3);
  setTextPlain(document.getElementById("m1Text"), genCuratorialParagraph("m1"));
}

async function rerenderM2(){
  await drawMobile(document.getElementById("m2Canvas"), "m2", 2);
  renderM2Text();
}

async function rerenderM3(){
  await drawMobile(document.getElementById("m3Canvas"), "m3", 7);
  setTextInteractive(document.getElementById("m3Text"), genCuratorialParagraph("m3"), "m3");
}

async function rerenderM4(){
  await drawMobile(document.getElementById("m4Canvas"), "m4", 5);
  setTextInteractive(document.getElementById("m4Text"), genCuratorialParagraph("m4"), "m4");
}

async function rerenderFinal(){
  await drawMobile(document.getElementById("finalCanvas"), "final", 10);

  const A = buildFinalA();
  const B = buildFinalB();

  const shareInvite =
`Partilha a tua exposição.
Cada percurso faz emergir obras diferentes.
Outras pessoas verão imagens que talvez nunca tenhas conseguido alcançar.

E você — o que montaria aqui?
${location.href}`;

  const full = `${A}\n\n${B}\n\n${TEXT_FINAL_CLOSING}\n\n${shareInvite}`;
  document.getElementById("finalText").textContent = full;

  document.getElementById("weeklyGate").textContent =
`Para ver os demais estados expositivos da semana, faz primeiro a tua curadoria (gera a tua expo).`;
}

async function rerenderAll(){
  await rerenderM1();
  await rerenderM2();
  await rerenderM3();
  await rerenderM4();
  if(Mob.final.ready) await rerenderFinal();
}

/* ============================================================
   FINAL TEXTS (duas partes)
============================================================ */
function buildFinalA(){
  const pFront = (G.front>0.25) ? "frente / figura" : (G.front<-0.25) ? "fundo / atmosfera" : "equilíbrio de planos";
  const pDense = (G.dense>0.25) ? "densidade e peso" : (G.dense<-0.25) ? "rarefação e respiro" : "densidade contida";
  const pCont  = (G.cont>0.25)  ? "continuidade e fluxo" : (G.cont<-0.25) ? "corte e decisão" : "passagens cautelosas";
  const pPh    = phMode()==="surda" ? "corte seco (plosivas surdas)" : phMode()==="sonora" ? "massa/peso (plosivas sonoras)" : "passagem (fricativas)";

  return `O teu estilo curatorial inclina-se para ${pFront}, com ${pDense}. Predomina ${pCont}, sob um corpo sonoro de ${pPh}.`;
}

function buildFinalB(){
  const n1 = Npick(N_PLAS);
  const n2 = Npick(N_SENS);
  const n3 = Npick(N_MEM);
  const v1 = Vpick(V_COMP);
  const v2 = Vpick(V_SENS);
  const a1 = maybeAdj();
  const adv = maybeAdv();

  return `A exposição resultante ${v1} ${n1} como campo ${a1||Npick(N_CUR)}: ${n2} surge em primeiro plano, enquanto ${n3} permanece como resto${adv?(" — "+adv):""}.`;
}

function buildFinalText(){
  return `${buildFinalA()}\n\n${buildFinalB()}`;
}

/* ============================================================
   INTERAÇÕES (restritas como combinado)
============================================================ */
function bindCanvasClicks(key, canvas){
  canvas.addEventListener("click", (ev)=>{
    if(key==="m1" || key==="m4" || key==="final") return;

    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top)  * (canvas.height/ r.height);
    const hits = HITS[key] || [];
    const hit = hits.find(h => x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h);
    if(!hit) return;

    try{
      if(key==="m2"){ doM2Swap(); return; }

      if(key==="m3"){
        // intensifica família do fragmento clicado
        const slot = hit.slot;
        const fam = slotFamily(slot);

        Mob.m3.focusFam = fam;
        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.14, 0, 1);
        Mob.m3.clicks++;

        // mexe pouco, mostra muito
        applyDelta({
          pressure: 0.03,
          cont: (fam===1||fam===4||fam===7) ? +0.05 : -0.02,
          dense:(fam===6||fam===12) ? +0.05 : 0.00,
          front:(fam===2||fam===5) ? +0.05 : 0.00
        });

        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          Mob.m3.slots = null; // reamostra só o M3
          toast("M3: catástrofe — nova configuração.");
        }

        rerenderM3();
        // ressonância pequena no M4 (texto muda; imagens não precisam reamostrar)
        rerenderM4();
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no clique (ver consola).");
    }
  });
}

function bindTextClicks(key, textEl){
  textEl.addEventListener("click", (ev)=>{
    const t = ev.target;
    if(!t || !t.classList || !t.classList.contains("w")) return;

    try{
      if(key==="m3"){
        // palavra em M3 puxa eixo dominante (menos caótico)
        const axe = (Math.abs(G.cont)>Math.abs(G.front) && Math.abs(G.cont)>Math.abs(G.dense)) ? "cont"
                  : (Math.abs(G.dense)>Math.abs(G.front)) ? "dense" : "front";

        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.12, 0, 1);

        const delta = { front:0, dense:0, cont:0, pressure:0.025 };
        delta[axe] = 0.06;
        applyDelta(delta);

        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          Mob.m3.slots = null;
          toast("M3: catástrofe — nova configuração.");
        }

        rerenderM3();
        rerenderM4();
        return;
      }

      if(key==="m4"){
        // M4: clique só nas palavras — reforça perfil fonográfico
        const mode = phMode();

        Mob.m4.intensity = clamp(Mob.m4.intensity + 0.14, 0, 1);
        Mob.m4.clicks++;

        if(mode==="surda") applyDelta({ ph:{dry:+0.30}, pressure:+0.04, cont:-0.02 });
        else if(mode==="sonora") applyDelta({ ph:{voiced:+0.30}, pressure:+0.04, dense:+0.02 });
        else applyDelta({ ph:{open:+0.30}, pressure:+0.04, cont:+0.02 });

        if(Mob.m4.intensity >= 0.98){
          Mob.m4.intensity = 0;
          Mob.m4.focusPh = null;
          Mob.m4.slots = null; // reamostra só o M4
          toast("M4: colapso — o corpo sonoro virou regime.");
        }

        rerenderM4();
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no texto (ver consola).");
    }
  });
}

/* ============================================================
   BOTÕES / BOOT
============================================================ */
function openShare(title, note, text, srcCanvasId){
  document.getElementById("shareTitle").textContent = title;
  document.getElementById("shareNote").textContent = note;
  document.getElementById("shareText").value = text;

  const src = document.getElementById(srcCanvasId);
  const out = document.getElementById("shareCanvas");
  const ctx = out.getContext("2d");

  // compõe: imagem + texto
  ctx.clearRect(0,0,out.width,out.height);
  ctx.fillStyle = "rgba(255,255,255,.94)";
  ctx.fillRect(0,0,out.width,out.height);

  ctx.fillStyle = "rgba(24,19,21,.88)";
  ctx.font = "900 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("MÓBILES — suiornotsui", 42, 48);

  ctx.fillStyle = "rgba(24,19,21,.55)";
  ctx.font = "14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(new Date().toISOString().slice(0,19).replace("T"," "), 42, 72);

  // imagem
  const pad = 42;
  const targetW = out.width - pad*2;
  const ratio = src.height / src.width;
  const targetH = Math.min(out.height*0.56, targetW*ratio);
  const dx = pad;
  const dy = 96;
  ctx.drawImage(src, dx, dy, targetW, targetH);

  // texto
  const textTop = dy + targetH + 46;
  ctx.fillStyle = "rgba(24,19,21,.82)";
  ctx.font = "16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const lines = text.split("\n").join(" ").split(/(?<=\.)\s+/).slice(0,10);
  let y = textTop;
  for(const ln of lines){
    const s = ln.trim();
    if(!s) continue;
    wrapLine(ctx, s, pad, y, out.width - pad*2, 22);
    y += 28;
    if(y>out.height-40) break;
  }

  document.getElementById("overlay").style.display="flex";
}

function wrapLine(ctx, text, x, y, maxWidth, lineHeight){
  const words = text.split(" ");
  let line = "";
  for(let n=0;n<words.length;n++){
    const test = line + words[n] + " ";
    if(ctx.measureText(test).width > maxWidth && n>0){
      ctx.fillText(line, x, y);
      line = words[n] + " ";
      y += lineHeight;
    } else {
      line = test;
    }
  }
  ctx.fillText(line, x, y);
}

function closeShare(){ document.getElementById("overlay").style.display="none"; }

function canvasToDataURL(canvas){
  try{ return canvas.toDataURL("image/png"); }catch(e){ return ""; }
}

function shareTextFor(kind){
  const link = location.href;
  if(kind==="m1"){
    return `MÓBILES (entrada) — eu tensionei o nascimento do campo.\n\nNão escolhi “imagens”: escolhi posição.\n\nFaz o teu percurso aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m2"){
    return `MÓBILES — posição e estrutura (S–V–O).\nInverter troca sujeito↔objeto; clicar no verbo muda o objeto.\n\nFaz o teu aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m3"){
    return `MÓBILES — foco e estilo.\nOnde eu insisti, um traço cresceu; o resto recuou.\n\nTesta o teu gesto: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m4"){
    return `MÓBILES — corpo sonoro da linguagem.\nInsisti no som até o regime ceder.\n\nJoga também: ${link}\n\nassinatura: suiornotsui`;
  }
  return `MÓBILES — minha exposição provisória.\n\n${buildFinalText()}\n\n${link}\n\nassinatura: suiornotsui`;
}

function bindButtons(){
  document.getElementById("m1Tension").addEventListener("click", ()=>{
    // retensiona nascimento (mexe tudo)
    G.birthMode = (G.birthMode + 1) % 3;
    if(G.birthMode===0){
      applyDelta({ front:rnd(-0.25,0.25), dense:rnd(-0.15,0.15), cont:+0.20, ph:{open:+0.12}, pressure:0.10 });
    }else if(G.birthMode===1){
      applyDelta({ front:+0.28, dense:+0.10, cont:-0.25, ph:{dry:+0.16}, pressure:0.12 });
    }else{
      applyDelta({ front:-0.28, dense:-0.10, cont:+0.05, ph:{voiced:+0.16}, pressure:0.12 });
    }

    // reamostra TODOS (novo regime)
    Mob.m1.slots=null;
    Mob.m2.slots=null; Mob.m2.subjKey=null; Mob.m2.objKey=null; Mob.m2.verbKey=null;
    Mob.m3.slots=null; Mob.m3.intensity=0;
    Mob.m4.slots=null; Mob.m4.intensity=0;
    Mob.final.slots=null;

    rerenderAll();
  });

  document.getElementById("m2Swap").addEventListener("click", doM2Swap);

  document.getElementById("btnFinalize").addEventListener("click", ()=>{
    Mob.final.ready = true;
    Mob.final.slots = null;
    // fixa slots do final na geração (não muda ao rolar)
    Mob.final.slots = ensureSui(sampleSlots(10));
    rerenderFinal();
    toast("Exposição gerada.");
  });

  document.getElementById("m1Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 1", "imagem + texto", shareTextFor("m1"), "m1Canvas");
  });
  document.getElementById("m2Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 2", "imagem + texto", shareTextFor("m2"), "m2Canvas");
  });
  document.getElementById("m3Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 3", "imagem + texto", shareTextFor("m3"), "m3Canvas");
  });
  document.getElementById("m4Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 4", "imagem + texto", shareTextFor("m4"), "m4Canvas");
  });
  document.getElementById("finalShare").addEventListener("click", ()=>{
    if(!Mob.final.ready){
      toast("Gera a tua exposição primeiro.");
      return;
    }
    openShare("Partilhar — Exposição", "imagem + texto", shareTextFor("final"), "finalCanvas");
  });

  // share dialog controls
  document.getElementById("copyTextBtn").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(document.getElementById("shareText").value);
      toast("Texto copiado.");
    }catch(e){
      toast("Não foi possível copiar.");
    }
  });

  document.getElementById("downloadBtn").addEventListener("click", ()=>{
    const c = document.getElementById("shareCanvas");
    const a = document.createElement("a");
    a.download = "mobiles.png";
    a.href = canvasToDataURL(c);
    a.click();
  });

  document.getElementById("nativeShareBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("shareText").value;
    const c = document.getElementById("shareCanvas");
    if(!navigator.share){
      toast("Partilha nativa indisponível aqui.");
      return;
    }
    try{
      const blob = await (await fetch(c.toDataURL("image/png"))).blob();
      const file = new File([blob], "mobiles.png", {type:"image/png"});
      await navigator.share({ text, files:[file] });
    }catch(e){
      toast("Partilha cancelada ou indisponível.");
    }
  });
}

/* ============================================================
   BOOT
============================================================ */
async function boot(){
  // fixa textos
  document.getElementById("leadText").textContent = TEXT_OPENING;
  document.getElementById("introM1").textContent = INTRO_M1;
  document.getElementById("introM2").textContent = INTRO_M2;
  document.getElementById("introM3").textContent = INTRO_M3;
  document.getElementById("introM4").textContent = INTRO_M4;
  document.getElementById("finalIntro").textContent = "Depois do último móbile, encerra — e gera a tua exposição.";

  buildField();
  await tryLoadSui();

  // bind
  bindButtons();
  bindCanvasClicks("m1", document.getElementById("m1Canvas"));
  bindCanvasClicks("m2", document.getElementById("m2Canvas"));
  bindCanvasClicks("m3", document.getElementById("m3Canvas"));
  bindCanvasClicks("m4", document.getElementById("m4Canvas"));
  bindCanvasClicks("final", document.getElementById("finalCanvas"));

  bindTextClicks("m3", document.getElementById("m3Text"));
  bindTextClicks("m4", document.getElementById("m4Text"));

  updatePill();
  await rerenderAll();
}

boot();
</script>
</body>
</html>
