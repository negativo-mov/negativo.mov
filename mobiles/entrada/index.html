<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg:#fbf4f4;
      --ink:#141416;
      --muted:rgba(20,20,22,.68);
      --hair:rgba(20,20,22,.14);

      /* “horror-pastel” */
      --p1:#ffe1ea;
      --p2:#dff3ff;
      --p3:#e7ffe8;
      --p4:#fff2d6;
      --acid:#a7ffb2;
      --bruise:#c9b2ff;
      --soot:rgba(12,12,14,.78);
      --ghost:rgba(255,255,255,.86);

      --card:rgba(255,255,255,.66);
      --shadow:0 18px 60px rgba(10,10,14,.09);
      --radius:22px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 12% 6%, var(--p2), transparent 65%),
        radial-gradient(900px 620px at 88% 18%, var(--p1), transparent 62%),
        radial-gradient(880px 720px at 22% 88%, var(--p3), transparent 60%),
        radial-gradient(900px 700px at 84% 88%, var(--bruise), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.03));
      min-height:100vh;
    }

    a{color:inherit}
    .wrap{
      width:min(1120px, 92vw);
      margin: 22px auto 56px;
    }

    header{
      padding: 16px 2px 10px;
    }
    header h1{
      margin:0 0 8px;
      font-size: 22px;
      letter-spacing:.2px;
      font-weight: 700;
    }
    header p{
      margin:0;
      max-width: 78ch;
      color:var(--muted);
      line-height:1.45;
      font-size:14px;
    }
    .sig{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .pill{
      border:1px solid var(--hair);
      background: rgba(255,255,255,.58);
      padding:6px 10px;
      border-radius:999px;
      box-shadow: 0 10px 30px rgba(0,0,0,.06);
      backdrop-filter: blur(8px);
    }

    .card{
      margin-top: 18px;
      border: 1px solid rgba(20,20,22,.12);
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
    }
    .head{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      padding: 14px 16px;
      border-bottom:1px solid rgba(20,20,22,.10);
      background:
        linear-gradient(90deg, rgba(255,255,255,.66), rgba(255,255,255,.36));
    }
    .t b{
      display:block;
      font-size:14px;
      letter-spacing:.2px;
      margin-bottom:4px;
    }
    .t small{
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      display:block;
      max-width: 70ch;
    }
    .mini{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button{
      border:1px solid rgba(20,20,22,.16);
      background: rgba(255,255,255,.72);
      color:var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
      letter-spacing:.1px;
      box-shadow: 0 12px 34px rgba(0,0,0,.08);
    }
    button:hover{transform: translateY(-1px)}
    button:active{transform: translateY(0px); opacity:.88}

    .stage{
      padding: 14px 16px 18px;
    }

    .fixedIntro{font-size:14px;line-height:1.35;color:var(--ink);margin:2px 0 14px 0;opacity:.92}
    canvas{
      width:100%;
      height:auto;
      border-radius: 18px;
      border: 1px solid rgba(20,20,22,.16);
      background:
        radial-gradient(700px 420px at 30% 35%, rgba(255,255,255,.55), rgba(255,255,255,.20) 62%, rgba(0,0,0,.02)),
        linear-gradient(135deg, rgba(255,220,235,.28), rgba(223,243,255,.28), rgba(231,255,232,.22));
      box-shadow: 0 20px 70px rgba(0,0,0,.08);
    }
    .txt{
      margin-top: 10px;
      font-size: 14px;
      line-height: 1.55;
      color: rgba(20,20,22,.86);
      letter-spacing:.1px;
    }
    .w{
      cursor:pointer;
      border-radius: 6px;
      padding: 0 2px;
    }
    .w:hover{
      background: rgba(167,255,178,.18);
      outline: 1px dashed rgba(20,20,22,.18);
    }
    .verb{
      background: rgba(201,178,255,.18);
      outline: 1px dashed rgba(20,20,22,.18);
    }
    .lock{
      opacity:.92;
    }

    .hint{
      margin-top:10px;
      font-size: 12px;
      color: var(--muted);
    }

    .finalGridNote{
      margin-top:10px;
      font-size:12px;
      color: var(--muted);
    }

    footer{
      margin-top: 26px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
    }

    /* modal share */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.42);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 999;
    }
    .modal{
      width: min(980px, 96vw);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(20,20,22,.16);
      border-radius: 18px;
      box-shadow: 0 30px 120px rgba(0,0,0,.28);
      overflow:hidden;
      backdrop-filter: blur(12px);
    }
    .mhead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 12px 14px;
      border-bottom:1px solid rgba(20,20,22,.12);
      background: linear-gradient(90deg, rgba(255,255,255,.82), rgba(255,255,255,.62));
    }
    .mcontent{
      padding: 14px;
      display:grid;
      gap: 12px;
      grid-template-columns: 1.2fr .8fr;
    }
    .mcontent textarea{
      width:100%;
      min-height: 160px;
      border-radius: 14px;
      padding: 10px;
      border: 1px solid rgba(20,20,22,.18);
      outline:none;
      font-size: 13px;
      line-height:1.45;
      resize: vertical;
      background: rgba(255,255,255,.82);
    }
    .mcontent .imgbox{
      border: 1px solid rgba(20,20,22,.14);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(255,255,255,.84);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px;
    }
    .mcontent img{max-width:100%; height:auto; border-radius:12px}
    .mfoot{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding: 12px 14px;
      border-top:1px solid rgba(20,20,22,.12);
      background: rgba(255,255,255,.82);
      flex-wrap:wrap;
    }
    .toast{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      background: rgba(20,20,22,.88);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 1000;
      box-shadow: 0 18px 60px rgba(0,0,0,.28);
    }
    .toast.on{opacity:1; transform: translateX(-50%) translateY(-2px)}
    @media (max-width: 900px){
      .mcontent{grid-template-columns: 1fr}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>MÓBILES — entrada</h1>
      <p>
        Operas aqui a tua própria curadoria. A artista é <b>suiornotsui</b>.
        Mas as obras que vês nunca são todas. O que aparece depende do modo como entras,
        de onde começas, do gesto que insistes em repetir, do que escolhes tocar e do que deixas passar.
        Por trás do que vês, há sempre mais. Algumas imagens só surgem sob certas tensões.
        Outras resistem, permanecem ausentes, como se aguardassem um olhar que ainda não chegou.
        Esse resto — aquilo que nunca aparece — sustenta o desejo de continuar.
      </p>
      <div class="sig">
        <span class="pill">NEGATIVO.mov · MÓBILES</span>
        <span class="pill">curadoria como posição</span>
        <span class="pill">resto como motor</span>
        <span class="pill">assinatura: <b>suiornotsui</b></span>
      </div>
    </header>

    <section class="card" id="m1">
      <div class="head">
        <div class="t">
          <b>Móbile 1 — Nascimento do campo</b>
          <small>3 fragmentos · o ponto de partida regula tudo o que poderá emergir depois</small>
        </div>
        <div class="mini">
          <button id="m1Tension">Tensionar nascimento</button>
          <button id="m1Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m1Fixed">Tudo começa aqui.<br>Três formas pendem no campo,<br>leves, ainda indecisas.<br>Cada tensão desloca o lugar de onde partes.<br>Não é escolha de imagens.<br>É escolha de posição.<br>E o modo como começas<br>inclina todo o percurso.</div>
        <canvas id="m1Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m1Text"></div>
        <div class="hint">M1: <b>só</b> o botão tensiona. O texto aqui é voz do campo, não interface.</div>
      </div>
    </section>

    <section class="card" id="m2">
      <div class="head">
        <div class="t">
          <b>Móbile 2 — Posição e estrutura (S–V–O)</b>
          <small>2 fragmentos · frente/fundo = sujeito/objeto; <b>verbo</b> é a única saída do binário</small>
        </div>
        <div class="mini">
          <button id="m2Swap">Inverter</button>
          <button id="m2Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m2Fixed">Agora há relação.<br>Algo ocupa a frente.<br>Algo permanece no fundo.<br>Trocar de lugar muda o sentido,<br>mas não liberta da forma.<br>Há posições que se repetem.<br>Só o gesto —<br>o que fazes —<br>abre outra possibilidade.</div>
        <canvas id="m2Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m2Text"></div>
        <div class="hint">M2: você só pode (1) inverter frente↔fundo, e (2) clicar no <b>verbo</b>.</div>
      </div>
    </section>

    <section class="card" id="m3">
      <div class="head">
        <div class="t">
          <b>Móbile 3 — Formação do gesto (estilo)</b>
          <small>7 fragmentos · clique em fragmentos/palavras intensifica traços e inclina o campo</small>
        </div>
        <div class="mini">
          <button id="m3Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m3Fixed">O campo começa a responder ao teu gesto.<br>Onde insistes, algo cresce.<br>O que tocas torna-se mais visível.<br>O que ignoras afasta-se.<br>Sem perceber, vais formando um modo de ver.<br>Um estilo.<br>Uma inclinação do mundo.</div>
        <canvas id="m3Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m3Text"></div>
        <div class="hint">M3: <b>sem botões</b> além de partilhar. Só clicar em fragmentos/palavras.</div>
      </div>
    </section>

    <section class="card" id="m4">
      <div class="head">
        <div class="t">
          <b>Móbile 4 — Corpo da linguagem (fonografia) + colapso</b>
          <small>5 fragmentos · <b>só as palavras</b> são clicáveis: insistir num corpo sonoro inclina tudo até saturar</small>
        </div>
        <div class="mini">
          <button id="m4Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m4Fixed">Agora já não operas imagens.<br>Operas a própria linguagem.<br>Cada palavra carrega um corpo.<br>Um peso.<br>Um som.<br>Uma força.<br>Insistir numa forma faz o campo inteiro ceder.<br>Até que, em excesso,<br>algo colapsa<br>e o regime muda.</div>
        <canvas id="m4Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m4Text"></div>
        <div class="hint">M4: clique apenas nas palavras. O canvas é <b>mudo</b> aqui.</div>
      </div>
    </section>

    <section class="card" id="final">
      <div class="head">
        <div class="t">
          <b>Estado alcançado — tua exposição provisória</b>
          <small>10 fragmentos · gera texto (estilo curatorial + crítica), pronto pra partilhar</small>
        </div>
        <div class="mini">
          <button id="btnFinalize">Gerar a minha expo</button>
          <button id="finalShare">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="finalFixed">O que construíste aqui não é um resultado neutro.<br>Revela algo do teu modo de ver,<br>do teu modo de escolher,<br>do teu modo de insistir.<br>Esta é a tua curadoria possível —<br>não a melhor,<br>não a definitiva,<br>mas a que emergiu das tuas decisões.<br>Outras teriam produzido outras constelações.<br>E ainda assim,<br>algo ficou sempre de fora.<br>Esse resto —<br>o que não conseguiste alcançar —<br>é o que mantém o desejo vivo.<br>Partilha o teu percurso.<br>Não como resposta,<br>mas como pergunta aberta aos outros.</div>
        <canvas id="finalCanvas" width="1000" height="640"></canvas>
        <div class="txt" id="finalText"></div>
        <div class="finalGridNote" id="weeklyGate"></div>
        <div class="hint">Depois a gente liga aqui o forms/endpoint: “para ver semanal, faz antes a tua curadoria”.</div>
      </div>
    </section>

    <footer>
      MÓBILES · entrada — dispositivo tensivo de emergência, espraiamento e circulação do improvável · NEGATIVO.mov
    </footer>
  </div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="mhead">
        <b id="shareTitle">Partilhar</b>
        <div style="margin-top:4px;color:var(--muted);font-size:12px" id="shareNote"></div>
        <button id="closeShare">Fechar</button>
      </div>
      <div class="mcontent">
        <div>
          <textarea id="shareText"></textarea>
          <div style="margin-top:10px;color:var(--muted);font-size:12px">
            Dica: em desktop, você pode copiar texto + baixar imagem. Em mobile, salvar a imagem e colar o texto funciona bem.
          </div>
        </div>
        <div class="imgbox">
          <img id="shareImg" alt="imagem para partilha" />
        </div>
      </div>
      <div class="mfoot">
        <button id="copyText">Copiar texto</button>
        <button id="downloadImg">Baixar imagem</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   LÉXICO COMPLETO — 70 operadores × 3 realizações (surda/sonora/fricativa)
   (exatamente o que você colou; sem faltar nenhum)
============================================================ */
const LEX = {
  /* SUBSTANTIVOS (1–28) */
  vestigio:{ surda:"traço", sonora:"marca", fricativa:"sombra" },
  sopro:{ surda:"pingo", sonora:"bafo", fricativa:"suspiro" },
  dobra:{ surda:"prega", sonora:"curva", fricativa:"flexão" },
  canto:{ surda:"quina", sonora:"beira", fricativa:"franja" },
  margem:{ surda:"limite", sonora:"borda", fricativa:"fronteira" },
  poeira:{ surda:"pó", sonora:"bruma", fricativa:"cinza" },
  silencio:{ surda:"pausa", sonora:"calma", fricativa:"sussurro" },
  rastro:{ surda:"pegada", sonora:"vesta", fricativa:"resíduo" },
  fragmento:{ surda:"cortezinho", sonora:"bordado", fricativa:"desfiado" },
  detalhe:{ surda:"ponto", sonora:"miolo", fricativa:"nuança" },

  lembranca:{ surda:"nota", sonora:"memória", fricativa:"recordação" },
  demora:{ surda:"pausa", sonora:"espera", fricativa:"suspensão" },
  intervalo:{ surda:"corte", sonora:"entre", fricativa:"fresta" },
  eco:{ surda:"toque", sonora:"resposta", fricativa:"ressonância" },
  resto:{ surda:"ruga", sonora:"sobra", fricativa:"resíduo" },

  plano:{ surda:"linha", sonora:"base", fricativa:"superfície" },
  camada:{ surda:"capa", sonora:"nível", fricativa:"espessura" },
  textura:{ surda:"trama", sonora:"tecido", fricativa:"fibra" },
  superficie:{ surda:"pele", sonora:"face", fricativa:"película" },
  escala:{ surda:"passo", sonora:"medida", fricativa:"proporção" },
  ritmo:{ surda:"pulso", sonora:"cadência", fricativa:"fluência" },
  materia:{ surda:"corpo", sonora:"substância", fricativa:"massa" },

  presenca:{ surda:"toque", sonora:"vulto", fricativa:"sombra" },
  tensao:{ surda:"nó", sonora:"peso", fricativa:"pressão" },
  campo:{ surda:"plano", sonora:"território", fricativa:"ambiente" },
  emergencia:{ surda:"salto", sonora:"aparição", fricativa:"insurgência" },
  configuracao:{ surda:"forma", sonora:"estrutura", fricativa:"composição" },
  cessacao:{ surda:"corte", sonora:"encerramento", fricativa:"silenciamento" },

  /* VERBOS (29–50) */
  aproximar:{ surda:"chegar", sonora:"beirar", fricativa:"esfumar" },
  reparar:{ surda:"notar", sonora:"observar", fricativa:"esmiuçar" },
  tocar:{ surda:"tatear", sonora:"roçar", fricativa:"aflorar" },
  escutar:{ surda:"ouvir", sonora:"acolher", fricativa:"sintonizar" },
  demorar_v:{ surda:"parar", sonora:"permanecer", fricativa:"alongar-se" },
  pousar:{ surda:"cair", sonora:"assentar", fricativa:"deslizar" },
  acompanhar:{ surda:"seguir", sonora:"amparar", fricativa:"entrelaçar" },
  cuidar:{ surda:"zelar", sonora:"nutrir", fricativa:"suavizar" },

  recortar:{ surda:"cortar", sonora:"delimitar", fricativa:"fissurar" },
  deslocar:{ surda:"mover", sonora:"transferir", fricativa:"deslizar" },
  sustentar:{ surda:"segurar", sonora:"manter", fricativa:"suspender" },
  distribuir:{ surda:"partir", sonora:"organizar", fricativa:"espalhar" },
  sobrepor:{ surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir" },
  atravessar:{ surda:"passar", sonora:"cruzar", fricativa:"permeiar" },
  insinuar:{ surda:"sugerir", sonora:"indicar", fricativa:"sussurrar" },

  insistir:{ surda:"bater", sonora:"persistir", fricativa:"ressoar" },
  interromper:{ surda:"cortar", sonora:"cessar", fricativa:"esvair-se" },
  fixar:{ surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar" },
  suspender:{ surda:"parar", sonora:"reter", fricativa:"flutuar" },
  reter:{ surda:"prender", sonora:"guardar", fricativa:"conservar" },
  abandonar:{ surda:"largar", sonora:"deixar", fricativa:"dissolver" },
  transformar:{ surda:"romper", sonora:"converter", fricativa:"transfigurar" },

  /* ADJETIVOS (51–62) */
  leve:{ surda:"claro", sonora:"brando", fricativa:"suave" },
  minimo:{ surda:"curto", sonora:"pequeno", fricativa:"sutil" },
  fragil:{ surda:"ténue", sonora:"delicado", fricativa:"sensível" },
  tenue:{ surda:"fino", sonora:"delgado", fricativa:"esfumado" },
  quase_a:{ surda:"breve", sonora:"próximo", fricativa:"difuso" },

  opaco:{ surda:"denso", sonora:"turvo", fricativa:"fosco" },
  poroso:{ surda:"aberto", sonora:"vazado", fricativa:"permeável" },
  irregular:{ surda:"torto", sonora:"instável", fricativa:"assimétrico" },
  difuso:{ surda:"solto", sonora:"amplo", fricativa:"disperso" },

  latente:{ surda:"oculto", sonora:"presente", fricativa:"subjacente" },
  instavel:{ surda:"quebrado", sonora:"oscilante", fricativa:"flutuante" },
  provisorio:{ surda:"breve", sonora:"mutável", fricativa:"transitório" },

  /* ADVÉRBIOS (63–70) */
  ainda:{ surda:"já", sonora:"agora", fricativa:"sempre" },
  quase:{ surda:"logo", sonora:"perto", fricativa:"talvez" },
  lentamente:{ surda:"aos poucos", sonora:"com calma", fricativa:"suavemente" },
  por_vezes:{ surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente" },
  sempre:{ surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente" },
  raramente:{ surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente" },
  talvez:{ surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente" },
  agora:{ surda:"já", sonora:"neste momento", fricativa:"presentemente" },
};

/* ============================================================
   GRUPOS (conteúdo / funções) — 70 operadores organizados
============================================================ */
const N_SENS = ["vestigio","sopro","dobra","canto","margem","poeira","silencio","rastro","fragmento","detalhe"];
const N_MEM  = ["lembranca","demora","intervalo","eco","resto","cessacao"];
const N_PLAS = ["plano","camada","textura","superficie","escala","ritmo","materia"];
const N_CUR  = ["presenca","tensao","campo","emergencia","configuracao"];

const V_SENS = ["aproximar","reparar","tocar","escutar","demorar_v","pousar","acompanhar","cuidar"];
const V_COMP = ["recortar","deslocar","sustentar","distribuir","sobrepor","atravessar","insinuar"];
const V_DEC  = ["insistir","interromper","fixar","suspender","reter","abandonar","transformar"];

const A_SENS = ["leve","minimo","fragil","tenue","quase_a"];
const A_VIS  = ["opaco","poroso","irregular","difuso"];
const A_CRIT = ["latente","instavel","provisorio"];

const ADV    = ["ainda","quase","lentamente","por_vezes","sempre","raramente","talvez","agora"];

/* ============================================================
   ESTADO GLOBAL (campo)
============================================================ */
const G = {
  front: 0.0,
  dense: 0.0,
  cont:  0.0,
  pressure: 0.10,
  ph: { dry:0.0, voiced:0.0, open:0.0 },
  collapse: 0,
};

const Mob = {
  m1:{ seed:1 },
  m2:{ flip:false, verbBias:0 },
  m3:{ clicks:0 },
  m4:{ clicks:0 },
  final:{ ready:false, cfg:null },
};

/* ============================================================
   UTIL
============================================================ */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rnd   = (a,b)=>a + Math.random()*(b-a);

function toast(msg){
  const t=document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("on");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.classList.remove("on"), 1200);
}

function pick(arr){
  return arr[(Math.random()*arr.length)|0];
}

function realize(key){
  // realiza segundo o regime fonográfico predominante atual (surda/sonora/fricativa)
  const o = LEX[key];
  if(!o) return key;
  const mode = phMode();
  if(mode==="surda") return o.surda || o.sonora || o.fricativa;
  if(mode==="sonora") return o.sonora || o.surda || o.fricativa;
  if(mode==="fricativa") return o.fricativa || o.sonora || o.surda;
  // neutro: escolhe ponderado pelo estado
  const wDry = Math.max(0.01, 0.34 + G.ph.dry*0.18);
  const wVoi = Math.max(0.01, 0.34 + G.ph.voiced*0.18);
  const wOpn = Math.max(0.01, 0.34 + G.ph.open*0.18);
  const s = wDry+wVoi+wOpn;
  const r = Math.random()*s;
  if(r<wDry) return o.surda;
  if(r<wDry+wVoi) return o.sonora;
  return o.fricativa;
}

function phMode(){
  const {dry, voiced, open} = G.ph;
  const m = Math.max(dry, voiced, open);
  if(m < 0.22) return "neutro";
  if(m===dry) return "surda";
  if(m===voiced) return "sonora";
  return "fricativa";
}

function applyDelta(src, delta){
  if(typeof delta.front==="number") G.front = clamp(G.front + delta.front, -1, 1);
  if(typeof delta.dense==="number") G.dense = clamp(G.dense + delta.dense, -1, 1);
  if(typeof delta.cont ==="number") G.cont  = clamp(G.cont  + delta.cont,  -1, 1);
  if(typeof delta.pressure==="number") G.pressure = clamp(G.pressure + delta.pressure, 0, 1);

  if(delta.ph){
    if(typeof delta.ph.dry==="number") G.ph.dry = clamp(G.ph.dry + delta.ph.dry, -1, 1);
    if(typeof delta.ph.voiced==="number") G.ph.voiced = clamp(G.ph.voiced + delta.ph.voiced, -1, 1);
    if(typeof delta.ph.open==="number") G.ph.open = clamp(G.ph.open + delta.ph.open, -1, 1);
  }
}

/* ============================================================
   TEXTO (voz curatorial) — sem intro fixo embutido
============================================================ */
function maybeAdj(){
  if(Math.random() < 0.48) return null;
  const key = pick(A_SENS.concat(A_VIS).concat(A_CRIT));
  return realize(key);
}
function maybeAdv(){
  if(Math.random() < 0.60) return null;
  return realize(pick(ADV));
}
function pickN(group){ return pick(group); }
function pickV(group){ return pick(group); }
function pickA(group){ return realize(pick(group)); }

function genCuratorialLine(kind){
  // kind: "m1Body" "m3Body" "m4Body" "finalA" "finalB"
  const adj1 = maybeAdj();
  const adv1 = maybeAdv();

  const nA = (G.front>0.25) ? pickN(N_CUR) : pickN(N_SENS);
  const nB = (G.dense>0.25) ? pickN(N_PLAS) : pickN(N_MEM);
  const nC = (G.cont>0.20) ? pickN(N_SENS) : pickN(N_CUR);

  const vA = (G.cont>0.15) ? pickV(V_SENS) : pickV(V_COMP);

  const T = [];

  if(kind==="m1Body"){
    T.push(`Entre ${realize(nA)} e ${realize(nB)}, o campo começa a ${realize(vA)}${adv1?(" "+adv1):""}.`);
    T.push(`A ${realize(nC)}${adj1?(" "+adj1):""} não explica: ela inclina.`);
    if(G.pressure>0.35) T.push(`Há um ${realize(pickN(N_MEM))} que insiste como condição de partida.`);
  }

  if(kind==="m3Body"){
    T.push(`${realize(pickN(N_CUR))}${maybeAdj()?(" "+maybeAdj()):""} ${realize(pickV(V_COMP))} ${realize(pickN(N_PLAS))}${maybeAdv()?(" "+maybeAdv()):""}.`);
    T.push(`O que ganhaste de ${realize(pickN(N_SENS))} vira ${realize(pickN(N_CUR))} — e o resto muda de lugar.`);
    if(G.dense>0.25) T.push(`A ${realize(pickN(N_PLAS))} torna-se ${pickA(A_VIS)}: o teu foco tem peso.`);
  }

  if(kind==="m4Body"){
    const mode = phMode();
    const tag = (mode==="surda") ? "seco" : (mode==="sonora" ? "sonoro" : (mode==="fricativa" ? "arranhado" : "neutro"));
    T.push(`A frase começa a soar ${tag}: corpo da palavra como operador do campo.`);
    T.push(`Insistir numa forma muda ${realize(pickN(N_CUR))} e reorganiza ${realize(pickN(N_PLAS))}.`);
    if(G.collapse>0) T.push(`Há ${realize(pickN(N_MEM))} depois do colapso: não é fim, é resto operável.`);
  }

  if(kind==="finalA"){
    T.push(`O teu estilo curatorial tende a ${realize(pickV(V_COMP))} ${realize(pickN(N_PLAS))} com ${realize(pickN(N_CUR))}${maybeAdv()?(" "+maybeAdv()):""}.`);
    T.push(`Há preferência por ${pickA(A_SENS)} e por ${realize(pickN(N_SENS))} — e isso produz ${realize(pickN(N_CUR))}.`);
  }

  if(kind==="finalB"){
    T.push(`A exposição monta uma ${realize(pickN(N_CUR))} ${pickA(A_CRIT)}: entre ${realize(pickN(N_PLAS))} e ${realize(pickN(N_MEM))}, o campo não se fecha.`);
    T.push(`O que aparece se sustenta como ${realize(pickN(N_SENS))}, mas deixa ${realize(pickN(N_MEM))} como pergunta.`);
  }

  return T.join(" ");
}

/* ============================================================
   RICH TEXT (m3/m4 com metadata)
============================================================ */
function setRichText(el, text, clickable){
  const parts = text.split(/(\s+)/);
  el.innerHTML = "";
  for(const p of parts){
    if(p.trim()===""){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    if(!clickable){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    const span = document.createElement("span");
    span.className = "w";
    span.textContent = p;
    span.dataset.token = p.toLowerCase();
    el.appendChild(span);
  }
}

/* --- Rich text com metadados (restrições por móbile) --- */
let SURFACE_PH = null;
function buildSurfacePhMap(){
  const m = new Map();
  for(const k of Object.keys(LEX)){
    const o = LEX[k];
    if(!o || typeof o!=="object") continue;
    if(o.surda) m.set(String(o.surda).toLowerCase(), "surda");
    if(o.sonora) m.set(String(o.sonora).toLowerCase(), "sonora");
    if(o.fricativa) m.set(String(o.fricativa).toLowerCase(), "fricativa");
  }
  return m;
}
function inferPh(token){
  if(!SURFACE_PH) SURFACE_PH = buildSurfacePhMap();
  const t = String(token||"").toLowerCase().replace(/[.,;:!?]/g,"");
  return SURFACE_PH.get(t) || null;
}
function setRichTextWithMeta(el, text, key){
  const parts = text.split(/(\s+)/);
  el.innerHTML = "";
  for(const p of parts){
    if(p.trim()===""){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    const span = document.createElement("span");
    span.className = "w";
    span.textContent = p;
    const clean = p.toLowerCase().replace(/[.,;:!?]/g,"");
    span.dataset.token = clean;

    if(key==="m3"){
      let axe = "front";
      if(surfaceInGroups(clean, GROUP_SURF.dense)) axe="dense";
      else if(surfaceInGroups(clean, GROUP_SURF.cont)) axe="cont";
      else if(surfaceInGroups(clean, GROUP_SURF.front)) axe="front";
      else axe = (Math.random()<0.34) ? "front" : (Math.random()<0.5 ? "dense" : "cont");
      span.dataset.axe = axe;
      span.dataset.dir = (Math.random()<0.5) ? "pos" : "neg";
    }

    if(key==="m4"){
      const ph = inferPh(clean) || (Math.random()<0.34 ? "surda" : (Math.random()<0.5 ? "sonora" : "fricativa"));
      span.dataset.ph = ph;
    }

    el.appendChild(span);
  }
}

// grupos de superfície (para heurística do m3)
const GROUP_SURF = { front:new Set(), dense:new Set(), cont:new Set() };
function addAllVariantsToSet(set, obj){
  if(!obj) return;
  if(obj.surda) set.add(String(obj.surda).toLowerCase());
  if(obj.sonora) set.add(String(obj.sonora).toLowerCase());
  if(obj.fricativa) set.add(String(obj.fricativa).toLowerCase());
}
function surfaceInGroups(tok, set){
  return set.has(tok);
}
function buildGroupSurface(){
  for(const k of N_CUR.concat(N_MEM)){ addAllVariantsToSet(GROUP_SURF.front, LEX[k]); }
  for(const k of N_PLAS){ addAllVariantsToSet(GROUP_SURF.dense, LEX[k]); }
  for(const k of N_SENS){ addAllVariantsToSet(GROUP_SURF.cont, LEX[k]); }
  for(const k of V_DEC){ addAllVariantsToSet(GROUP_SURF.front, LEX[k]); }
  for(const k of V_COMP){ addAllVariantsToSet(GROUP_SURF.dense, LEX[k]); }
  for(const k of V_SENS){ addAllVariantsToSet(GROUP_SURF.cont, LEX[k]); }
}
buildGroupSurface();

/* ============================================================
   M2 S–V–O (curto) + verbo como única saída
============================================================ */
function genM2SVO(){
  const subjKeyA = (G.front>0.25) ? pickN(N_CUR) : pickN(N_SENS);
  const objKeyB  = (G.dense>0.25) ? pickN(N_PLAS) : pickN(N_MEM);

  const subj = Mob.m2.flip ? objKeyB : subjKeyA;
  const obj  = Mob.m2.flip ? subjKeyA : objKeyB;

  const baseV1 = pickV(V_COMP);
  const baseV2 = pickV(V_SENS);
  let verb = (Mob.m2.verbBias%3===0) ? baseV1 : baseV2;

  if(Mob.m2.verbBias>0 && (Mob.m2.verbBias%2===1)){
    verb = pickV(V_DEC);
  }

  return { subj: realize(subj), verb: realize(verb), obj: realize(obj) };
}

function renderM2Text(el, m2){
  el.innerHTML = "";
  const s1 = document.createElement("span"); s1.textContent = m2.subj+" "; s1.className="lock";
  const sv = document.createElement("span"); sv.textContent = m2.verb+" "; sv.className="w verb";
  const s2 = document.createElement("span"); s2.textContent = m2.obj+"."; s2.className="lock";
  el.appendChild(s1); el.appendChild(sv); el.appendChild(s2);
}

/* ============================================================
   IMAGENS / FRAGMENTOS (slots 1..120) + Sui (53)
============================================================ */
const BASE_SLOTS = 120;
const SUI_SLOT = 53;

function slotFamily(slot){
  if(slot>=1 && slot<=10) return 1;
  if(slot<=20) return 2;
  if(slot<=30) return 3;
  if(slot<=40) return 4;
  if(slot<=50) return 5;
  if(slot<=60) return 6;
  if(slot<=70) return 7;
  if(slot<=80) return 8;
  if(slot<=90) return 9;
  if(slot<=100) return 10;
  if(slot<=110) return 11;
  return 12;
}

// probabilidade “aparecer Sui quase sempre” (mas não sempre)
function shouldForceSui(){
  // 90% de chance de forçar ao menos 1 slot com Sui na composição de cada móbile (quando disponível)
  return Math.random() < 0.90;
}

function pickSlotWeighted(count){
  const arr=[];
  for(let i=1;i<=BASE_SLOTS;i++){
    let w=1;

    // peso tensivo por estado global (simplificado)
    const fam = slotFamily(i);
    if(G.cont>0.20 && fam===1) w+=1.6;
    if(G.pressure>0.55 && (fam===2||fam===5)) w+=1.7;
    if(Math.abs(G.front)>0.35 && fam===3) w+=1.2;
    if(G.dense>0.25 && fam===6) w+=1.5;
    if(G.dense<-0.15 && fam===7) w+=1.2;
    if(G.front<-0.25 && fam===8) w+=1.0;
    if(G.cont<-0.15 && fam===12) w+=1.0;

    // paleta / “docemente mórbido”: tende a empurrar para famílias 4/10/11 também
    if(fam===4 || fam===10 || fam===11) w+=0.35;

    // pequena penalidade para a própria Sui NÃO dominar tudo
    if(i===SUI_SLOT) w+=0.35;

    const k=Math.max(1, Math.floor(w*6));
    for(let j=0;j<k;j++) arr.push(i);
  }
  // sample sem reposição
  const out=[];
  const pool=[...arr];
  while(out.length<count && pool.length){
    const idx=(Math.random()*pool.length)|0;
    out.push(pool[idx]);
    pool.splice(idx,1);
  }
  // fallback
  while(out.length<count) out.push( ((Math.random()*BASE_SLOTS)|0)+1 );
  return out;
}

function slotUrl(slot){
  // imagens genéricas: usa placeholders gerados no próprio canvas (não dependem do repo)
  // mas o slot 53 usa o caminho real de Sui (sui.json -> assets/sui/slot_053.jpg)
  if(slot===SUI_SLOT){
    return "assets/sui/slot_053.jpg";
  }
  return null; // será desenhado procedimentalmente
}

/* ============================================================
   DESENHO (cenários visíveis + contornos fortes dos fragmentos)
============================================================ */
const HITS = { m1:[], m2:[], m3:[], m4:[], final:[] };

function clearHits(key){ HITS[key]=[]; }

function drawFrame(ctx, x,y,w,h, style){
  ctx.save();
  ctx.fillStyle = style.fill;
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.line || 3.0;
  ctx.shadowColor = style.shadow || "rgba(0,0,0,.12)";
  ctx.shadowBlur = style.blur || 18;
  ctx.shadowOffsetY = style.offy || 8;
  ctx.beginPath();
  const r=16;
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
}

function drawHorrorPastelBG(ctx, W,H, mood){
  ctx.save();
  ctx.clearRect(0,0,W,H);

  // fundo “mórbido-doce”
  const g=ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0, "rgba(255,225,234,.62)");
  g.addColorStop(0.45, "rgba(223,243,255,.55)");
  g.addColorStop(1, "rgba(231,255,232,.52)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  // manchas “bruise/acid”
  for(let i=0;i<10;i++){
    const x=rnd(0,W), y=rnd(0,H), r=rnd(90,220);
    const gg=ctx.createRadialGradient(x,y,0,x,y,r);
    gg.addColorStop(0, (Math.random()<0.5) ? "rgba(201,178,255,.22)" : "rgba(167,255,178,.16)");
    gg.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle=gg;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // “fiapos” leves
  ctx.strokeStyle="rgba(20,20,22,.08)";
  ctx.lineWidth=1;
  for(let i=0;i<14;i++){
    ctx.beginPath();
    ctx.moveTo(rnd(0,W), rnd(0,H));
    ctx.bezierCurveTo(rnd(0,W),rnd(0,H), rnd(0,W),rnd(0,H), rnd(0,W),rnd(0,H));
    ctx.stroke();
  }

  // cenário específico
  if(mood==="crib"){
    ctx.strokeStyle="rgba(20,20,22,.10)";
    ctx.lineWidth=3;
    // arco do berço
    ctx.beginPath();
    ctx.arc(W*0.5, H*0.04, W*0.55, Math.PI*0.08, Math.PI*0.92);
    ctx.stroke();
    // cordas
    for(const k of [0.33,0.5,0.67]){
      ctx.beginPath();
      ctx.moveTo(W*0.5, H*0.06);
      ctx.lineTo(W*k, H*0.22);
      ctx.stroke();
    }
  }
  if(mood==="mountains"){
    ctx.fillStyle="rgba(20,20,22,.06)";
    // montanhas
    ctx.beginPath();
    ctx.moveTo(0,H*0.70);
    ctx.lineTo(W*0.18,H*0.52);
    ctx.lineTo(W*0.32,H*0.66);
    ctx.lineTo(W*0.52,H*0.44);
    ctx.lineTo(W*0.70,H*0.62);
    ctx.lineTo(W*0.86,H*0.50);
    ctx.lineTo(W,H*0.68);
    ctx.lineTo(W,H);
    ctx.lineTo(0,H);
    ctx.closePath();
    ctx.fill();

    // “animais” minimalistas
    ctx.strokeStyle="rgba(20,20,22,.16)";
    ctx.lineWidth=2;
    for(const px of [0.22,0.42,0.62,0.78]){
      const x=W*px, y=H*0.78 + rnd(-6,6);
      ctx.beginPath();
      ctx.moveTo(x-10,y);
      ctx.lineTo(x+10,y);
      ctx.moveTo(x-6,y);
      ctx.lineTo(x-10,y+10);
      ctx.moveTo(x+6,y);
      ctx.lineTo(x+10,y+10);
      ctx.stroke();
    }
  }
  if(mood==="maze"){
    ctx.strokeStyle="rgba(20,20,22,.14)";
    ctx.lineWidth=2;
    const step=44;
    for(let y=24;y<H-24;y+=step){
      for(let x=24;x<W-24;x+=step){
        if(Math.random()<0.55){
          ctx.beginPath();
          ctx.moveTo(x,y);
          ctx.lineTo(x+step*(Math.random()<0.5?1:0), y+step*(Math.random()<0.5?1:0));
          ctx.stroke();
        }
      }
    }
  }
  if(mood==="stairs"){
    ctx.strokeStyle="rgba(20,20,22,.16)";
    ctx.lineWidth=3;
    for(let i=0;i<7;i++){
      const x=rnd(W*0.08,W*0.86);
      const y=rnd(H*0.10,H*0.86);
      const w=rnd(120,240);
      const h=rnd(60,110);
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x,y+h);
      ctx.lineTo(x+w*0.25,y+h*0.72);
      ctx.lineTo(x+w*0.5,y+h);
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawProceduralFragment(ctx, x,y,w,h, slot){
  // forma “mais nítida” (contrastada) + variação por família
  const fam = slotFamily(slot);

  // cores por família (horror pastel)
  const pals = [
    ["rgba(255,225,234,.80)","rgba(20,20,22,.55)"],
    ["rgba(223,243,255,.78)","rgba(20,20,22,.58)"],
    ["rgba(231,255,232,.78)","rgba(20,20,22,.58)"],
    ["rgba(255,242,214,.76)","rgba(20,20,22,.58)"],
    ["rgba(201,178,255,.72)","rgba(20,20,22,.62)"],
    ["rgba(167,255,178,.68)","rgba(20,20,22,.62)"],
  ];
  const [fillBase, ink] = pals[(fam-1)%pals.length];

  drawFrame(ctx, x,y,w,h, {
    fill: fillBase,
    stroke: "rgba(20,20,22,.55)",
    line: 3.2,
    shadow: "rgba(0,0,0,.16)",
    blur: 20,
    offy: 10
  });

  ctx.save();
  ctx.beginPath();
  const r=14;
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.clip();

  // padrões por família (nítidos, não apagados)
  ctx.strokeStyle = ink;
  ctx.fillStyle = ink;
  ctx.lineWidth = 2.4;

  if(fam===1){
    // continuidade linear
    for(let i=0;i<9;i++){
      const yy = y + (i+1)*(h/10);
      ctx.beginPath();
      ctx.moveTo(x+10, yy);
      ctx.bezierCurveTo(x+w*0.35, yy-10, x+w*0.65, yy+10, x+w-10, yy);
      ctx.stroke();
    }
  }else if(fam===2){
    // corte vertical
    for(let i=0;i<5;i++){
      const xx = x + (i+2)*(w/7);
      ctx.beginPath();
      ctx.moveTo(xx, y+10);
      ctx.lineTo(xx, y+h-10);
      ctx.stroke();
    }
  }else if(fam===3){
    // oblíquo
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(x-20, y + i*(h/5));
      ctx.lineTo(x+w+20, y + i*(h/5) + 22);
      ctx.stroke();
    }
  }else if(fam===4){
    // ritmo repetitivo
    for(let i=0;i<8;i++){
      const cx = x + (i+1)*(w/9);
      ctx.beginPath();
      ctx.arc(cx, y+h*0.55, 10, 0, Math.PI*2);
      ctx.stroke();
    }
  }else if(fam===5){
    // ruptura
    for(let i=0;i<8;i++){
      ctx.beginPath();
      ctx.moveTo(x+rnd(0,w), y+rnd(0,h));
      ctx.lineTo(x+rnd(0,w), y+rnd(0,h));
      ctx.stroke();
    }
  }else if(fam===6){
    // densidade
    for(let i=0;i<30;i++){
      ctx.globalAlpha = 0.55;
      ctx.fillRect(x+rnd(0,w), y+rnd(0,h), rnd(4,10), rnd(4,10));
    }
    ctx.globalAlpha = 1;
  }else if(fam===7){
    // rarefação
    ctx.strokeStyle="rgba(20,20,22,.22)";
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.arc(x+w*0.5, y+h*0.5, 30+i*18, 0, Math.PI*2);
      ctx.stroke();
    }
  }else if(fam===8){
    // centro instável
    ctx.beginPath();
    ctx.arc(x+w*0.55, y+h*0.48, 46, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x+w*0.42, y+h*0.58, 28, 0, Math.PI*2);
    ctx.stroke();
  }else if(fam===9){
    // homogêneo
    ctx.globalAlpha=0.18;
    ctx.fillRect(x+10,y+10,w-20,h-20);
    ctx.globalAlpha=1;
  }else if(fam===10){
    // direção múltipla
    for(let i=0;i<10;i++){
      ctx.beginPath();
      ctx.moveTo(x+w*0.5, y+h*0.5);
      ctx.lineTo(x+rnd(0,w), y+rnd(0,h));
      ctx.stroke();
    }
  }else if(fam===11){
    // contorno
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.rect(x+18,y+18,w-36,h-36);
    ctx.stroke();
    ctx.beginPath();
    ctx.rect(x+32,y+32,w-64,h-64);
    ctx.stroke();
  }else{
    // massa
    ctx.fillStyle="rgba(20,20,22,.32)";
    ctx.fillRect(x+18, y+18, w-36, h-36);
  }

  ctx.restore();

  // etiqueta mínima (só como resto)
  ctx.save();
  ctx.fillStyle="rgba(20,20,22,.50)";
  ctx.font="12px ui-sans-serif";
  ctx.fillText(String(slot).padStart(3,"0"), x+14, y+22);
  ctx.restore();
}

async function drawImageInto(ctx, imgUrl, x,y,w,h){
  return new Promise((resolve)=>{
    const im = new Image();
    im.crossOrigin="anonymous";
    im.onload=()=>{
      ctx.save();
      drawFrame(ctx,x,y,w,h,{ fill:"rgba(255,255,255,.86)", stroke:"rgba(20,20,22,.65)", line:3.2, shadow:"rgba(0,0,0,.16)", blur:22, offy:10 });
      ctx.beginPath();
      const r=14;
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(im, x, y, w, h);
      ctx.restore();
      resolve(true);
    };
    im.onerror=()=>{
      resolve(false);
    };
    im.src=imgUrl + (imgUrl.includes("?") ? "" : ("?v="+Date.now()));
  });
}

/* ============================================================
   COMPOSIÇÕES (móbiles) — cenários e hits
============================================================ */
function sampleSlots(n){
  let slots = pickSlotWeighted(n);

  // força 1 Sui em 90% dos casos, sem dominar tudo
  if(shouldForceSui()){
    if(!slots.includes(SUI_SLOT)){
      slots[0] = SUI_SLOT;
    }
  }
  // embaralha
  for(let i=slots.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [slots[i],slots[j]]=[slots[j],slots[i]];
  }
  return slots;
}

async function drawMobile(canvas, key, n){
  const ctx=canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  clearHits(key);

  const mood = (key==="m1")?"crib":(key==="m2")?"mountains":(key==="m3")?"maze":(key==="m4")?"stairs":"maze";
  drawHorrorPastelBG(ctx,W,H,mood);

  // slots fixos por móbile
  const slots = sampleSlots(n);

  // layout por móbile
  let rects=[];
  if(key==="m1"){
    rects = [
      {x:W*0.18,y:H*0.22,w:W*0.24,h:H*0.42, z:1},
      {x:W*0.38,y:H*0.24,w:W*0.24,h:H*0.42, z:2},
      {x:W*0.58,y:H*0.22,w:W*0.24,h:H*0.42, z:3},
    ];
  }else if(key==="m2"){
    rects = [
      {x:W*0.14,y:H*0.30,w:W*0.34,h:H*0.46, z:2}, // fundo (menor)
      {x:W*0.52,y:H*0.22,w:W*0.36,h:H*0.54, z:3}, // frente (maior)
    ];
  }else if(key==="m3"){
    const pts=[
      [0.12,0.25],[0.33,0.20],[0.54,0.24],[0.76,0.18],
      [0.18,0.58],[0.46,0.62],[0.74,0.55]
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.18+rnd(-0.02,0.02)), h:H*(0.26+rnd(-0.03,0.03)), z:i+1
    }));
  }else if(key==="m4"){
    const pts=[
      [0.18,0.24],[0.52,0.18],[0.68,0.44],[0.34,0.50],[0.10,0.58],
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.22+rnd(-0.02,0.02)), h:H*(0.28+rnd(-0.03,0.03)), z:i+1
    }));
  }else{
    // final: 10 fragmentos em constelação
    const pts=[
      [0.10,0.18],[0.28,0.12],[0.50,0.16],[0.72,0.10],[0.82,0.28],
      [0.62,0.36],[0.38,0.34],[0.16,0.40],[0.24,0.62],[0.62,0.62],
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.20+rnd(-0.02,0.02)), h:H*(0.26+rnd(-0.03,0.03)), z:i+1
    }));
  }

  // ordena por z
  rects.sort((a,b)=>a.z-b.z);

  // desenha
  for(let i=0;i<rects.length;i++){
    const r=rects[i];
    const slot=slots[i];
    const url=slotUrl(slot);

    if(url){
      const ok = await drawImageInto(ctx, url, r.x, r.y, r.w, r.h);
      if(!ok){
        drawProceduralFragment(ctx, r.x, r.y, r.w, r.h, slot);
      }
    }else{
      drawProceduralFragment(ctx, r.x, r.y, r.w, r.h, slot);
    }

    // hitbox (só onde o móbile permite)
    HITS[key].push({x:r.x,y:r.y,w:r.w,h:r.h,slot:{id:slot, axes:{
      front: (slotFamily(slot)%2===0)? 0.9 : -0.6,
      dense: (slotFamily(slot)%3===0)? 0.8 : -0.4,
      cont:  (slotFamily(slot)%4===0)? 0.7 : -0.5,
    }}});
  }

  // guarda slots no estado pra share
  if(key==="m1") Mob.m1.slots = slots;
  if(key==="m2") Mob.m2.slots = slots;
  if(key==="m3") Mob.m3.slots = slots;
  if(key==="m4") Mob.m4.slots = slots;
  if(key==="final") Mob.final.slots = slots;
}

/* ============================================================
   CLIQUES (restrições por móbile) — CORRIGIDO
============================================================ */
function bindCanvasClicks(key, canvas){
  canvas.addEventListener("click", (ev)=>{
    // Restrições por móbile:
    // M1: só botão (canvas não responde)
    // M2: clicar em qualquer fragmento = inverter frente/fundo
    // M3: clicar em fragmento intensifica
    // M4: canvas não responde (só palavras)
    // FINAL: canvas não responde
    if(key==="m1" || key==="m4" || key==="final") return;

    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top)  * (canvas.height/ r.height);
    const hits = HITS[key] || [];
    const hit = hits.find(h => x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h);
    if(!hit) return;

    try{
      if(key==="m2"){
        doM2Swap(); // única ação no canvas do M2
        return;
      }
      if(key==="m3"){
        // intensifica a partir do fragmento clicado
        Mob.m3.clicks++;
        const a = hit.slot?.axes || {front:rnd(-1,1), dense:rnd(-1,1), cont:rnd(-1,1)};
        applyDelta("m3", {
          front: 0.18 * a.front,
          dense: 0.18 * a.dense,
          cont:  0.18 * a.cont,
          pressure: 0.06
        });
        rerenderAll();
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no clique (ver consola).");
    }
  });
}

function bindTextClicks(key, textEl){
  textEl.addEventListener("click", (ev)=>{
    const t = ev.target;
    // Restrições por móbile:
    // M1: texto não é clicável
    // M2: só o VERBO é clicável (span.verb)
    // M3: palavras clicáveis
    // M4: palavras clicáveis (reforça corpo sonoro)
    if(!t || !t.classList) return;

    if(key==="m1") return;

    if(key==="m2"){
      if(!t.classList.contains("verb")) return;
      try{
        // “fuga”: clicar no verbo troca o verbo e empurra o objeto para fora da dupla binária
        Mob.m2.verbBias += 1;
        applyDelta("m2", { front:rnd(-0.10,0.10), cont:rnd(-0.10,0.10), pressure:0.10 });
        rerenderAll();
      }catch(e){
        console.error(e);
        toast("Erro no verbo (ver consola).");
      }
      return;
    }

    // m3/m4: exige span.w
    if(!t.classList.contains("w")) return;

    try{
      if(key==="m3"){
        // M3: foco / estilo — clique em palavra inclina eixos levemente
        Mob.m3.clicks++;
        const axe = t.dataset.axe || "front";
        const dir = (t.dataset.dir==="neg") ? -1 : 1;
        const mag = 0.12;
        const delta = {front:0,dense:0,cont:0,pressure:0.05};
        delta[axe] = mag * dir;
        applyDelta("m3", delta);
        rerenderAll();
        return;
      }

      if(key==="m4"){
        // M4: só palavras — reforça perfil fonético da palavra clicada e aproxima colapso
        const ph = t.dataset.ph; // "surda" | "sonora" | "fricativa"
        if(ph==="surda") applyDelta("m4",{ph:{dry:+0.30}, cont:-0.06, pressure:+0.09});
        else if(ph==="sonora") applyDelta("m4",{ph:{voiced:+0.30}, dense:+0.06, pressure:+0.09});
        else applyDelta("m4",{ph:{open:+0.30}, cont:+0.06, pressure:+0.09});

        // limiar/colapso
        Mob.m4.clicks++;
        if(Math.abs(G.pressure) > 0.92 || Mob.m4.clicks >= 14){
          Mob.m4.clicks = 0;
          G.collapse = clamp(G.collapse+1,0,3);
          applyDelta("m4", {
            front: rnd(-0.35,0.35),
            dense: rnd(-0.35,0.35),
            cont:  (G.cont>0? -0.55 : +0.55),
            ph: { dry:rnd(-0.35,0.35), voiced:rnd(-0.35,0.35), open:rnd(-0.35,0.35) },
            pressure: 0.18
          });
          toast("Colapso: o regime mudou.");
        }

        rerenderAll();
        return;
      }
    }catch(e){
      toast("Erro no texto: ver consola");
      console.error(e);
    }
  });
}

/* ============================================================
   M2 ações
============================================================ */
function doM2Swap(){
  Mob.m2.flip = !Mob.m2.flip;
  applyDelta("m2", { front: (Mob.m2.flip? -0.20:+0.20), pressure: 0.08, cont:rnd(-0.06,0.06) });
  rerenderAll();
}

/* ============================================================
   RENDER
============================================================ */
async function rerenderM1(){
  const c=document.getElementById("m1Canvas");
  await drawMobile(c,"m1",3);
  const text = genCuratorialLine("m1Body");
  setRichText(document.getElementById("m1Text"), text, false); // M1 não clicável
}
async function rerenderM2(){
  const c=document.getElementById("m2Canvas");
  await drawMobile(c,"m2",2);
  const m2 = genM2SVO();
  renderM2Text(document.getElementById("m2Text"), m2);
}
async function rerenderM3(){
  const c=document.getElementById("m3Canvas");
  await drawMobile(c,"m3",7);
  const text = genCuratorialLine("m3Body");
  setRichTextWithMeta(document.getElementById("m3Text"), text, "m3");
}
async function rerenderM4(){
  const c=document.getElementById("m4Canvas");
  await drawMobile(c,"m4",5);
  const text = genCuratorialLine("m4Body");
  setRichTextWithMeta(document.getElementById("m4Text"), text, "m4");
}

function buildFinalText(){
  const a = genCuratorialLine("finalA");
  const b = genCuratorialLine("finalB");
  const link = location.href;
  const call = `\n\nPartilha e convida: “faz a tua curadoria aqui → ${link}”.`;
  return `${a}\n\n${b}${call}`;
}

async function rerenderFinal(){
  const c=document.getElementById("finalCanvas");
  await drawMobile(c,"final",10);
  const txt = buildFinalText();
  document.getElementById("finalText").textContent = txt;

  const gate = document.getElementById("weeklyGate");
  gate.textContent = "Para ver os estados expositivos semanais, faz primeiro a tua curadoria (gera a tua expo).";
}

/* ============================================================
   SHARE (canvas -> imagem + texto)
============================================================ */
function openShare(title, note, text, dataUrl){
  document.getElementById("shareTitle").textContent = title;
  document.getElementById("shareNote").textContent = note || "";
  document.getElementById("shareText").value = text || "";
  document.getElementById("shareImg").src = dataUrl || "";
  document.getElementById("overlay").style.display="flex";
}
function closeShare(){ document.getElementById("overlay").style.display="none"; }

function canvasToDataUrl(id){
  const c=document.getElementById(id);
  try{
    return c.toDataURL("image/png");
  }catch(e){
    console.warn(e);
    return "";
  }
}

function shareTextFor(kind){
  const link = location.href;
  if(kind==="m1"){
    return `MÓBILES (entrada) — eu tensionei o nascimento do campo.\n\nO que apareceu não é “tudo”: é posição.\n\nFaz o teu percurso aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m2"){
    return `MÓBILES — posição e estrutura (S–V–O).\nTroquei frente/fundo e cliquei no verbo para escapar do binário.\n\nFaz o teu aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m3"){
    return `MÓBILES — foco e estilo.\nOnde eu insisti, o campo cresceu.\n\nTesta o teu gesto: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m4"){
    return `MÓBILES — corpo sonoro da linguagem.\nCliquei nas palavras até o campo ceder.\n\nJoga também: ${link}\n\nassinatura: suiornotsui`;
  }
  return `MÓBILES — minha exposição provisória.\n\n${buildFinalText()}\n\nFaz a tua curadoria: ${link}\n\nassinatura: suiornotsui`;
}

/* ============================================================
   BOTÕES / BOOT
============================================================ */
function bindButtons(){
  document.getElementById("m1Tension").addEventListener("click", ()=>{
    // M1: muda tudo de uma vez (posição de nascimento)
    applyDelta("m1", {
      front: rnd(-0.55,0.55),
      dense: rnd(-0.50,0.50),
      cont:  rnd(-0.55,0.55),
      pressure: 0.12,
      ph: { dry:rnd(-0.25,0.25), voiced:rnd(-0.25,0.25), open:rnd(-0.25,0.25) }
    });
    rerenderAll();
  });

  document.getElementById("m2Swap").addEventListener("click", doM2Swap);

  document.getElementById("btnFinalize").addEventListener("click", ()=>{
    Mob.final.ready = true;
    rerenderFinal();
    toast("Exposição gerada.");
  });

  // shares
  document.getElementById("m1Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 1", "imagem + texto", shareTextFor("m1"), canvasToDataUrl("m1Canvas"));
  });
  document.getElementById("m2Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 2", "imagem + texto", shareTextFor("m2"), canvasToDataUrl("m2Canvas"));
  });
  document.getElementById("m3Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 3", "imagem + texto", shareTextFor("m3"), canvasToDataUrl("m3Canvas"));
  });
  document.getElementById("m4Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 4", "imagem + texto", shareTextFor("m4"), canvasToDataUrl("m4Canvas"));
  });
  document.getElementById("finalShare").addEventListener("click", ()=>{
    if(!Mob.final.ready){
      toast("Primeiro: gerar a tua expo.");
      return;
    }
    openShare("Partilhar — tua exposição provisória", "imagem + texto", shareTextFor("final"), canvasToDataUrl("finalCanvas"));
  });

  // modal
  document.getElementById("closeShare").addEventListener("click", closeShare);
  document.getElementById("overlay").addEventListener("click", (e)=>{
    if(e.target && e.target.id==="overlay") closeShare();
  });
  document.getElementById("copyText").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(document.getElementById("shareText").value);
      toast("Texto copiado.");
    }catch(e){
      toast("Não consegui copiar (permissão).");
    }
  });
  document.getElementById("downloadImg").addEventListener("click", ()=>{
    const url = document.getElementById("shareImg").src;
    if(!url){ toast("Sem imagem."); return; }
    const a=document.createElement("a");
    a.href=url;
    a.download="mobiles.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });
}

function bindAllClicks(){
  bindCanvasClicks("m1", document.getElementById("m1Canvas"));
  bindCanvasClicks("m2", document.getElementById("m2Canvas"));
  bindCanvasClicks("m3", document.getElementById("m3Canvas"));
  bindCanvasClicks("m4", document.getElementById("m4Canvas"));
  bindCanvasClicks("final", document.getElementById("finalCanvas"));

  bindTextClicks("m1", document.getElementById("m1Text"));
  bindTextClicks("m2", document.getElementById("m2Text"));
  bindTextClicks("m3", document.getElementById("m3Text"));
  bindTextClicks("m4", document.getElementById("m4Text"));
  bindTextClicks("final", document.getElementById("finalText"));
}

async function rerenderAll(){
  await rerenderM1();
  await rerenderM2();
  await rerenderM3();
  await rerenderM4();
  if(Mob.final.ready) await rerenderFinal();
}

(async function boot(){
  bindButtons();
  bindAllClicks();
  await rerenderAll();
})();
</script>
</body>
</html>
