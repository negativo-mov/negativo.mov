<!doctype html>
<html lang="pt">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MÓBILES — entrada</title>
<style>
  :root{
    --bg:#fbf7fb;
    --ink:rgba(24,19,21,.88);
    --muted:rgba(24,19,21,.58);
    --card:rgba(255,255,255,.72);
    --stroke:rgba(24,19,21,.22);
    --stroke2:rgba(24,19,21,.34);
    --shadow:rgba(0,0,0,.10);
    --pink:rgba(255,170,210,.55);
    --blue:rgba(170,215,255,.55);
    --acid:rgba(190,255,210,.20);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(900px 450px at 20% 10%, rgba(255,170,210,.18), transparent 60%),
      radial-gradient(900px 450px at 80% 12%, rgba(170,215,255,.18), transparent 60%),
      radial-gradient(900px 650px at 50% 90%, rgba(190,255,210,.10), transparent 55%),
      var(--bg);
    color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    line-height:1.55;
  }

  .wrap{max-width:980px; margin:0 auto; padding:28px 16px 70px}
  .top{
    display:flex; gap:16px; align-items:flex-start; justify-content:space-between;
    padding:8px 0 16px;
  }
  .title{
    font-weight:900; letter-spacing:.4px; font-size:22px;
  }
  .pill{
    font-size:12px; color:var(--muted);
    padding:8px 10px; border:1px solid var(--stroke);
    border-radius:999px; background:rgba(255,255,255,.55);
    box-shadow:0 8px 22px var(--shadow);
    white-space:nowrap;
  }

  .lead{
    margin:14px 0 26px;
    font-size:16px;
    color:rgba(24,19,21,.80);
  }
  .sig{
    margin-top:8px;
    color:rgba(24,19,21,.55);
    font-size:13px;
  }

  .section{ margin:28px 0 0; }
  .intro{
    margin: 0 0 10px;
    font-size:15px;
    color:rgba(24,19,21,.78);
    white-space:pre-line;
  }
  .canvasBox{
    margin: 10px 0 10px;
    width:100%;
    border-radius:22px;
    background:rgba(255,255,255,.60);
    border:1px solid var(--stroke);
    box-shadow: 0 20px 50px var(--shadow);
    padding:14px;
  }
  canvas{
    width:100%;
    height:auto;
    display:block;
    border-radius:18px;
    background:rgba(255,255,255,.35);
  }
  .textgen{
    margin:10px 6px 0;
    color:rgba(24,19,21,.82);
    font-size:15px;
  }

  .controls{
    display:flex; gap:10px; flex-wrap:wrap;
    margin:12px 4px 2px;
    align-items:center;
  }
  button{
    appearance:none;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.70);
    color:rgba(24,19,21,.86);
    border-radius:999px;
    padding:10px 14px;
    font-weight:700;
    cursor:pointer;
    box-shadow: 0 10px 24px var(--shadow);
    transition: transform .06s ease, background .15s ease;
  }
  button:active{ transform: translateY(1px); }
  button:hover{ background:rgba(255,255,255,.82); }
  .btnQuiet{
    background:rgba(255,255,255,.45);
  }

  .w{cursor:pointer; text-decoration: none; border-bottom:1px dotted rgba(24,19,21,.18)}
  .w:hover{ border-bottom-color: rgba(24,19,21,.40); }
  .verb{
    border-bottom: 2px solid rgba(24,19,21,.35);
    font-weight:900;
  }
  .lock{cursor:default; border-bottom:none}

  .footerBlock{
    margin-top:26px;
    padding-top:10px;
  }
  .finalActions{
    display:flex; gap:12px; flex-wrap:wrap; margin-top:12px;
  }
  .gate{
    margin-top:12px;
    color:rgba(24,19,21,.60);
    font-size:14px;
    white-space:pre-line;
  }

  /* overlay share */
  .overlay{
    position:fixed; inset:0;
    background:rgba(10,10,12,.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
    z-index:9999;
  }
  .modal{
    width:min(980px, 96vw);
    border-radius:22px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(255,255,255,.40);
    box-shadow: 0 30px 90px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .modalHead{
    display:flex; align-items:flex-start; justify-content:space-between;
    gap:12px;
    padding:14px 16px;
    border-bottom:1px solid rgba(24,19,21,.10);
  }
  .modalTitle{ font-weight:900; }
  .modalNote{ font-size:13px; color:rgba(24,19,21,.60); margin-top:2px; }
  .modalBody{ padding:14px 16px; }
  .shareGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:12px;
  }
  @media (min-width:900px){
    .shareGrid{ grid-template-columns: 1.1fr .9fr; }
  }
  .shareCanvasBox{
    border-radius:18px;
    border:1px solid rgba(24,19,21,.14);
    background:rgba(255,255,255,.75);
    padding:12px;
  }
  .shareCanvasBox canvas{ border-radius:14px; }
  textarea{
    width:100%;
    min-height:260px;
    border-radius:16px;
    border:1px solid rgba(24,19,21,.14);
    padding:12px;
    resize:vertical;
    font-size:14px;
    color:rgba(24,19,21,.84);
    background:rgba(255,255,255,.78);
    outline:none;
  }
  .modalFoot{
    display:flex; gap:10px; flex-wrap:wrap;
    padding:12px 16px 16px;
    border-top:1px solid rgba(24,19,21,.10);
  }
  .toast{
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background:rgba(255,255,255,.86);
    border:1px solid rgba(24,19,21,.12);
    border-radius:999px;
    padding:10px 14px;
    box-shadow:0 16px 40px rgba(0,0,0,.18);
    color:rgba(24,19,21,.82);
    font-size:14px;
    display:none;
    z-index:99999;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div>
      <div class="title">MÓBILES — entrada</div>
      <div class="sig">assinatura: suiornotsui</div>
    </div>
    <div class="pill" id="pillState">campo: meio · meio · meio</div>
  </div>

  <div class="lead" id="leadText"></div>

  <!-- M1 -->
  <div class="section" id="m1">
    <div class="intro" id="introM1"></div>
    <div class="canvasBox">
      <canvas id="m1Canvas" width="1100" height="520"></canvas>
      <div class="controls">
        <button id="m1Tension">Tensionar o início</button>
        <button class="btnQuiet" id="m1Share">Partilhar este móbile</button>
      </div>
      <div class="textgen" id="m1Text"></div>
    </div>
  </div>

  <!-- M2 -->
  <div class="section" id="m2">
    <div class="intro" id="introM2"></div>
    <div class="canvasBox">
      <canvas id="m2Canvas" width="1100" height="520"></canvas>
      <div class="controls">
        <button id="m2Swap">Trocar frente ↔ fundo</button>
        <button class="btnQuiet" id="m2Share">Partilhar este móbile</button>
      </div>
      <div class="textgen" id="m2Text"></div>
    </div>
  </div>

  <!-- M3 -->
  <div class="section" id="m3">
    <div class="intro" id="introM3"></div>
    <div class="canvasBox">
      <canvas id="m3Canvas" width="1100" height="560"></canvas>
      <div class="controls">
        <button class="btnQuiet" id="m3Share">Partilhar este móbile</button>
      </div>
      <div class="textgen" id="m3Text"></div>
    </div>
  </div>

  <!-- M4 -->
  <div class="section" id="m4">
    <div class="intro" id="introM4"></div>
    <div class="canvasBox">
      <canvas id="m4Canvas" width="1100" height="560"></canvas>
      <div class="controls">
        <button class="btnQuiet" id="m4Share">Partilhar este móbile</button>
      </div>
      <div class="textgen" id="m4Text"></div>
    </div>
  </div>

  <!-- Final -->
  <div class="section footerBlock" id="final">
    <div class="intro" id="finalIntro"></div>
    <div class="canvasBox">
      <div class="intro" style="margin:0 6px 12px; color:rgba(24,19,21,.74)" id="closingText"></div>
      <div class="finalActions">
        <button id="btnFinalize">Gerar a minha exposição</button>
        <button class="btnQuiet" id="finalShare">Partilhar a exposição</button>
      </div>
      <div style="margin-top:12px"></div>
      <canvas id="finalCanvas" width="1100" height="620"></canvas>
      <div class="textgen" id="finalText" style="white-space:pre-line"></div>
      <div class="gate" id="weeklyGate"></div>
    </div>
  </div>
</div>

<!-- Share overlay -->
<div class="overlay" id="overlay" onclick="closeShare()">
  <div class="modal" onclick="event.stopPropagation()">
    <div class="modalHead">
      <div>
        <div class="modalTitle" id="shareTitle">Partilhar</div>
        <div class="modalNote" id="shareNote"></div>
      </div>
      <button class="btnQuiet" onclick="closeShare()">Fechar</button>
    </div>
    <div class="modalBody">
      <div class="shareGrid">
        <div class="shareCanvasBox">
          <canvas id="shareCanvas" width="1200" height="900"></canvas>
        </div>
        <div>
          <textarea id="shareText"></textarea>
        </div>
      </div>
    </div>
    <div class="modalFoot">
      <button id="copyTextBtn">Copiar texto</button>
      <button id="downloadBtn">Baixar imagem</button>
      <button id="nativeShareBtn">Partilhar (telemóvel)</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ============================================================
   CONFIG / PATHS (robusto para /mobiles/entrada/)
============================================================ */
const BASE_MOBILES = (() => {
  // tenta localizar o diretório /mobiles/ a partir da URL atual (GitHub Pages)
  const u = new URL(location.href);
  const parts = u.pathname.split("/").filter(Boolean);
  const i = parts.lastIndexOf("mobiles");
  if(i >= 0){
    u.pathname = "/" + parts.slice(0, i+1).join("/") + "/";
    u.search = ""; u.hash = "";
    return u;
  }
  // fallback: sobe um nível a partir de /entrada/
  return new URL("../", location.href);
})();
const SUI_JSON_URL = new URL("sui.json", BASE_MOBILES).toString();

/* ===================
   COPY FIXED TEXTS
=================== */
const TEXT_OPENING =
`Operas aqui a tua própria curadoria.
A artista é suiornotsui.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.
Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto —
aquilo que nunca aparece —
sustenta o desejo de continuar.`;

const INTRO_M1 =
`Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.`;

const INTRO_M2 =
`Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.`;

const INTRO_M3 =
`O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.`;

const INTRO_M4 =
`Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.`;

const TEXT_FINAL_CLOSING =
`O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.`;

/* ============================================================
   UTILS
============================================================ */
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const rnd = (a,b)=>a+Math.random()*(b-a);
const pick = (arr)=>arr[(Math.random()*arr.length)|0];

function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.style.display="block";
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ t.style.display="none"; }, 1500);
}

/* ============================================================
   FIELD (120 slots + “gramática visual”)
============================================================ */
const FAMILIES = [
  {name:"F1", front:-0.2, dense:-0.2, cont:+0.9},
  {name:"F2", front:+0.6, dense:+0.1, cont:-0.9},
  {name:"F3", front:+0.2, dense:-0.1, cont:-0.2},
  {name:"F4", front:+0.0, dense:+0.0, cont:+0.5},
  {name:"F5", front:+0.4, dense:+0.3, cont:-0.6},
  {name:"F6", front:+0.1, dense:+0.9, cont:+0.1},
  {name:"F7", front:-0.6, dense:-0.9, cont:+0.2},
  {name:"F8", front:+0.2, dense:+0.1, cont:-0.1},
  {name:"F9", front:-0.1, dense:-0.1, cont:+0.0},
  {name:"F10",front:+0.3, dense:+0.2, cont:-0.2},
  {name:"F11",front:+0.5, dense:-0.1, cont:-0.4},
  {name:"F12",front:+0.1, dense:+0.8, cont:-0.7},
];

const FIELD = { slots:[] };

// Sui map
let SUI_MAP = null;

function buildField(){
  FIELD.slots = [];
  for(let i=1;i<=120;i++){
    const famIndex = Math.min(11, Math.floor((i-1)/10));
    const fam = FAMILIES[famIndex];
    FIELD.slots.push({
      idx:i,
      fam:fam.name,
      v: (i-1)%10,
      axes:{
        front: clamp(fam.front + rnd(-0.18,0.18), -1, 1),
        dense: clamp(fam.dense + rnd(-0.18,0.18), -1, 1),
        cont:  clamp(fam.cont  + rnd(-0.18,0.18), -1, 1),
      },
      sui: null,
      _img: null
    });
  }
}

/* ============================================================
   LOAD SUI MAP (robusto + fallback pro slot 53)
============================================================ */
async function tryLoadSui(){
  // tenta carregar o mapeamento /mobiles/sui.json e, em qualquer caso, garante um fallback robusto para o slot 53
  const probeImage = (url) => new Promise((resolve)=>{
    const img = new Image();
    img.onload = ()=> resolve(true);
    img.onerror = ()=> resolve(false);
    img.src = url + "?probe=" + Date.now();
  });

  try{
    const res = await fetch(SUI_JSON_URL + "?cache=" + Date.now(), { cache:"no-store" });
    if(!res.ok) throw new Error("sui.json não carregou");
    const data = await res.json();
    SUI_MAP = data;

    for(const s of FIELD.slots){
      const key = String(s.idx); // "53"
      if(SUI_MAP && SUI_MAP[key]){
        const rel = SUI_MAP[key]; // "assets/sui/slot_053.jpg"
        s.sui = { path: new URL(String(rel).replace(/^\.\?\/*/,"").replace(/^\.?\/*/,""), BASE_MOBILES).toString() };
      }
    }
  }catch(e){
    SUI_MAP = null;
  }

  // fallback mínimo: se falhou (ou se o caminho/ extensão divergir), ainda assim fixa o slot 53 em um dos caminhos prováveis
  const s53 = FIELD.slots[52];
  if(!s53.sui){
    const candidates = [
      "assets/sui/slot_053.jpg",
      "assets/sui/slot_053.JPG",
      "assets/sui/slot_053.jpeg",
      "assets/sui/slot_053.JPEG",
      "assets/sui/slot_053.png",
      "assets/sui/slot_053.PNG",
    ].map(p => new URL(p, BASE_MOBILES).toString());

    for(const u of candidates){
      if(await probeImage(u)){
        s53.sui = { path: u };
        break;
      }
    }
    if(!s53.sui){
      s53.sui = { path: candidates[0] };
    }
  }
}

/* ============================================================
   ESTADO GLOBAL (tensivo + fonográfico)
============================================================ */
const G = {
  front: 0,
  dense: 0,
  cont: 0,
  pressure: 0.35,
  birthMode: 0,
  ph:{ dry:0, voiced:0, open:0 }
};

const Mob = {
  m1:{ slots:null },
  m2:{ slots:null, flip:false, subjKey:null, objKey:null, verbKey:null, verbIx:0 },
  m3:{ slots:null, focusFam:null, intensity:0, clicks:0 },
  m4:{ slots:null, focusPh:null, intensity:0, clicks:0 },
  final:{ ready:false, slots:null }
};

function applyDelta(d){
  G.front = clamp(G.front + (d.front||0), -1, 1);
  G.dense = clamp(G.dense + (d.dense||0), -1, 1);
  G.cont  = clamp(G.cont  + (d.cont ||0), -1, 1);
  G.pressure = clamp(G.pressure + (d.pressure||0), 0, 3);

  if(d.ph){
    G.ph.dry    = clamp(G.ph.dry    + (d.ph.dry||0),    -1.2, 1.2);
    G.ph.voiced = clamp(G.ph.voiced + (d.ph.voiced||0), -1.2, 1.2);
    G.ph.open   = clamp(G.ph.open   + (d.ph.open||0),   -1.2, 1.2);
  }
  updatePill();
}

function updatePill(){
  const s = (x, a, b)=> x< -0.18 ? a : x>0.18 ? b : "meio";
  document.getElementById("pillState").textContent =
    `campo: ${s(G.front,"fundo","frente")} · ${s(G.dense,"rarefeito","denso")} · ${s(G.cont,"corte","contínuo")}`;
}

function phMode(){
  const d=Math.abs(G.ph.dry), v=Math.abs(G.ph.voiced), o=Math.abs(G.ph.open);
  if(d>=v && d>=o) return "surda";
  if(v>=d && v>=o) return "sonora";
  return "fricativa";
}

/* ============================================================
   SCORE / SAMPLE (seleção tensiva + “gramática visual”)
============================================================ */
function slotScore(slot){
  const dx =
    Math.abs(slot.axes.front - G.front) * 0.9 +
    Math.abs(slot.axes.dense - G.dense) * 0.7 +
    Math.abs(slot.axes.cont  - G.cont ) * 1.0;

  const phBonus =
    (G.ph.dry    * (-slot.axes.cont))*0.25 +
    (G.ph.open   * ( slot.axes.cont))*0.22 +
    (G.ph.voiced * ( slot.axes.dense))*0.15;

  let score = -(dx) + phBonus + rnd(-0.06,0.06);

  if(slot.sui) score += 0.95;

  return score;
}

function sampleSlots(n){
  const pool = FIELD.slots.slice();
  pool.sort((a,b)=> slotScore(b) - slotScore(a));
  const K = Math.min(36, pool.length);
  const top = pool.slice(0,K);
  for(let i=top.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [top[i], top[j]] = [top[j], top[i]];
  }
  return top.slice(0,n);
}

/* --- regra Sui: em cada móbile, 90% força pelo menos 1 slot 53 --- */
function ensureSui(slots){
  const want = (Math.random() < 0.90);
  if(!want) return slots;

  const has = slots.some(s => s.idx===53 && s.sui);
  if(has) return slots;

  const s53 = FIELD.slots[52];
  if(!s53 || !s53.sui) return slots;

  const ix = Math.max(0, slots.length-1);
  const out = slots.slice();
  out[ix] = s53;
  return out;
}

/* ============================================================
   LÉXICO (70 operadores × 3 realizações) — exatamente como aprovado
============================================================ */
const LEX = {
  vestigio:{surda:"traço",sonora:"marca",fricativa:"sombra"},
  sopro:{surda:"pingo",sonora:"bafo",fricativa:"suspiro"},
  dobra:{surda:"prega",sonora:"curva",fricativa:"flexão"},
  canto:{surda:"quina",sonora:"beira",fricativa:"franja"},
  margem:{surda:"limite",sonora:"borda",fricativa:"fronteira"},
  poeira:{surda:"pó",sonora:"bruma",fricativa:"cinza"},
  silencio:{surda:"pausa",sonora:"calma",fricativa:"sussurro"},
  rastro:{surda:"pegada",sonora:"vesta",fricativa:"resíduo"},
  fragmento:{surda:"cortezinho",sonora:"bordado",fricativa:"desfiado"},
  detalhe:{surda:"ponto",sonora:"miolo",fricativa:"nuança"},
  lembranca:{surda:"nota",sonora:"memória",fricativa:"recordação"},
  demora:{surda:"pausa",sonora:"espera",fricativa:"suspensão"},
  intervalo:{surda:"corte",sonora:"entre",fricativa:"fresta"},
  eco:{surda:"toque",sonora:"resposta",fricativa:"ressonância"},
  resto:{surda:"ruga",sonora:"sobra",fricativa:"resíduo"},
  plano:{surda:"linha",sonora:"base",fricativa:"superfície"},
  camada:{surda:"capa",sonora:"nível",fricativa:"espessura"},
  textura:{surda:"trama",sonora:"tecido",fricativa:"fibra"},
  superficie:{surda:"pele",sonora:"face",fricativa:"película"},
  escala:{surda:"passo",sonora:"medida",fricativa:"proporção"},
  ritmo:{surda:"pulso",sonora:"cadência",fricativa:"fluência"},
  materia:{surda:"corpo",sonora:"substância",fricativa:"massa"},
  presenca:{surda:"toque",sonora:"vulto",fricativa:"sombra"},
  tensao:{surda:"nó",sonora:"peso",fricativa:"pressão"},
  campo:{surda:"plano",sonora:"território",fricativa:"ambiente"},
  emergencia:{surda:"salto",sonora:"aparição",fricativa:"insurgência"},
  configuracao:{surda:"forma",sonora:"estrutura",fricativa:"composição"},
  cessacao:{surda:"corte",sonora:"encerramento",fricativa:"silenciamento"},

  aproximar:{surda:"chegar",sonora:"beirar",fricativa:"esfumar"},
  reparar:{surda:"notar",sonora:"observar",fricativa:"esmiuçar"},
  tocar:{surda:"tatear",sonora:"roçar",fricativa:"aflorar"},
  escutar:{surda:"ouvir",sonora:"acolher",fricativa:"sintonizar"},
  demorarV:{surda:"parar",sonora:"permanecer",fricativa:"alongar-se"},
  pousar:{surda:"cair",sonora:"assentar",fricativa:"deslizar"},
  acompanhar:{surda:"seguir",sonora:"amparar",fricativa:"entrelaçar"},
  cuidar:{surda:"zelar",sonora:"nutrir",fricativa:"suavizar"},

  recortar:{surda:"cortar",sonora:"delimitar",fricativa:"fissurar"},
  deslocar:{surda:"mover",sonora:"transferir",fricativa:"deslizar"},
  sustentar:{surda:"segurar",sonora:"manter",fricativa:"suspender"},
  distribuir:{surda:"partir",sonora:"organizar",fricativa:"espalhar"},
  sobrepor:{surda:"cobrir",sonora:"acumular",fricativa:"sobrefluir"},
  atravessar:{surda:"passar",sonora:"cruzar",fricativa:"permeiar"},
  insinuar:{surda:"sugerir",sonora:"indicar",fricativa:"sussurrar"},

  insistir:{surda:"bater",sonora:"persistir",fricativa:"ressoar"},
  interromper:{surda:"cortar",sonora:"cessar",fricativa:"esvair-se"},
  fixar:{surda:"marcar",sonora:"estabelecer",fricativa:"sedimentar"},
  suspender:{surda:"parar",sonora:"reter",fricativa:"flutuar"},
  reter:{surda:"prender",sonora:"guardar",fricativa:"conservar"},
  abandonar:{surda:"largar",sonora:"deixar",fricativa:"dissolver"},
  transformar:{surda:"romper",sonora:"converter",fricativa:"transfigurar"},

  leve:{surda:"claro",sonora:"brando",fricativa:"suave"},
  minimo:{surda:"curto",sonora:"pequeno",fricativa:"sutil"},
  fragil:{surda:"ténue",sonora:"delicado",fricativa:"sensível"},
  tenue:{surda:"fino",sonora:"delgado",fricativa:"esfumado"},
  quaseAdj:{surda:"breve",sonora:"próximo",fricativa:"difuso"},

  opaco:{surda:"denso",sonora:"turvo",fricativa:"fosco"},
  poroso:{surda:"aberto",sonora:"vazado",fricativa:"permeável"},
  irregular:{surda:"torto",sonora:"instável",fricativa:"assimétrico"},
  difuso:{surda:"solto",sonora:"amplo",fricativa:"disperso"},

  latente:{surda:"oculto",sonora:"presente",fricativa:"subjacente"},
  instavel:{surda:"quebrado",sonora:"oscilante",fricativa:"flutuante"},
  provisorio:{surda:"breve",sonora:"mutável",fricativa:"transitório"},

  ainda:{surda:"já",sonora:"agora",fricativa:"sempre"},
  quaseAdv:{surda:"logo",sonora:"perto",fricativa:"talvez"},
  lentamente:{surda:"aos poucos",sonora:"com calma",fricativa:"suavemente"},
  porVezes:{surda:"às vezes",sonora:"frequentemente",fricativa:"ocasionalmente"},
  sempre:{surda:"toda vez",sonora:"continuamente",fricativa:"infinitamente"},
  raramente:{surda:"quase nunca",sonora:"poucas vezes",fricativa:"esporadicamente"},
  talvez:{surda:"quem sabe",sonora:"possivelmente",fricativa:"eventualmente"},
  agora:{surda:"já",sonora:"neste momento",fricativa:"presentemente"},
};

const N_SENS = ["vestigio","sopro","dobra","canto","margem","poeira","silencio","rastro","fragmento","detalhe"];
const N_MEM  = ["lembranca","demora","intervalo","eco","resto","cessacao"];
const N_PLAS = ["plano","camada","textura","superficie","escala","ritmo","materia"];
const N_CUR  = ["presenca","tensao","campo","emergencia","configuracao"];

const V_SENS = ["aproximar","reparar","tocar","escutar","demorarV","pousar","acompanhar","cuidar"];
const V_COMP = ["recortar","deslocar","sustentar","distribuir","sobrepor","atravessar","insinuar"];
const V_DEC  = ["insistir","interromper","fixar","suspender","reter","abandonar","transformar"];

const ADJ_S  = ["leve","minimo","fragil","tenue","quaseAdj"];
const ADJ_P  = ["opaco","poroso","irregular","difuso"];
const ADJ_C  = ["latente","instavel","provisorio"];

const ADV    = ["ainda","quaseAdv","lentamente","porVezes","sempre","raramente","talvez","agora"];

/* ============================================================
   REALIZAÇÃO (plano da expressão guiado pelo modo fonográfico)
============================================================ */
function realize(key){
  const mode = phMode();
  const row = LEX[key];
  if(!row) return key;
  if(mode==="surda") return row.surda;
  if(mode==="sonora") return row.sonora;
  return row.fricativa;
}

/* ============================================================
   GERADOR DE TEXTO (voz curatorial) — maior em M1/M3/M4
============================================================ */
function maybeAdj(){
  const p = clamp(0.18 + Math.abs(G.dense)*0.40 + Math.abs(G.front)*0.20, 0.10, 0.75);
  if(Math.random()>p) return null;
  const pool = (Math.abs(G.cont)>0.25) ? ADJ_S.concat(ADJ_P) : ADJ_P.concat(ADJ_C);
  return realize(pick(pool));
}
function maybeAdv(){
  const p = clamp(0.14 + Math.abs(G.cont)*0.35 + Math.abs(G.pressure)*0.10, 0.08, 0.60);
  if(Math.random()>p) return null;
  return realize(pick(ADV));
}
function Npick(pool){ return realize(pick(pool)); }
function Vpick(pool){ return realize(pick(pool)); }

function genCuratorialParagraph(kind){
  const nA = (G.front>0.25) ? Npick(N_CUR) : Npick(N_SENS);
  const nB = (G.dense>0.25) ? Npick(N_PLAS) : Npick(N_MEM);
  const nC = (G.cont>0.20) ? Npick(N_SENS) : Npick(N_CUR);

  const vA = (G.cont>0.15) ? Vpick(V_SENS) : Vpick(V_COMP);

  const adj1 = maybeAdj();
  const adv1 = maybeAdv();

  const T = [];

  if(kind==="m1"){
    T.push(`No começo, ${nA}${adj1?(" "+adj1):""} aparece como eixo — e isso já inclina o campo.`);
    T.push(`O que nasce aqui ${vA} ${nB}${adv1?(", "+adv1):""}.`);
    T.push(`O resto não some: fica como ${Npick(N_MEM)} à espera de outra tensão.`);
    T.push(`Se o campo endurece, não é ruído: é ${Npick(["tensao","configuracao","cessacao"])} em formação.`);
    return T.join(" ");
  }

  if(kind==="m3"){
    T.push(`Onde tocas, ${nC} ganha relevo; onde evitas, ${Npick(N_CUR)} recua.`);
    T.push(`Insistir em ${Npick(N_PLAS)} faz ${Npick(N_SENS)} responder como estilo.`);
    T.push(`Aos poucos, a tua curadoria deixa de “escolher imagens” e começa a formar campo.`);
    T.push(`${Npick(["presenca","tensao","configuracao"])} não é tema: é consequência do teu gesto.`);
    return T.join(" ");
  }

  if(kind==="m4"){
    const mode = phMode();
    const label = (mode==="surda") ? "plosivas surdas (corte seco)" :
                  (mode==="sonora") ? "plosivas sonoras (massa e peso)" :
                  "fricativas (passagem e arranho)";
    T.push(`O regime atual: ${label}.`);
    T.push(`Quando repetes um corpo, o resto do campo se reescreve junto — até ceder.`);
    T.push(`Se satura, não é bug: é ${Npick(["cessacao","resto","intervalo"])} como evento.`);
    return T.join(" ");
  }

  return "";
}

/* ============================================================
   M2 — S–V–O (restrito) + regras estritas
============================================================ */
const M2_VERBS = [
  ...V_COMP, ...V_SENS, ...V_DEC
];

function m2InitIfNeeded(){
  if(Mob.m2.subjKey && Mob.m2.objKey && Mob.m2.verbKey) return;

  const subj = (G.front>0.22) ? pick(N_CUR) : pick(N_SENS);
  const obj  = (G.dense>0.22) ? pick(N_PLAS) : pick(N_MEM);
  Mob.m2.subjKey = subj;
  Mob.m2.objKey  = obj;

  Mob.m2.verbIx = (Math.random()*M2_VERBS.length)|0;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];
}

function m2Block(nKey){
  const n = realize(nKey);
  const adjProb = clamp(0.22 + Math.abs(G.dense)*0.32 + Math.abs(G.front)*0.18, 0.18, 0.68);
  const advProb = clamp(0.12 + Math.abs(G.cont)*0.26, 0.10, 0.52);
  const adj = (Math.random()<adjProb) ? maybeAdj() : null;
  const adv = (Math.random()<advProb) ? maybeAdv() : null;

  let s = n;
  if(adj) s += " " + adj;
  if(adv) s += " " + adv;
  return s;
}

function renderM2Text(){
  m2InitIfNeeded();
  const el = document.getElementById("m2Text");
  el.innerHTML = "";

  const subjKey = Mob.m2.flip ? Mob.m2.objKey : Mob.m2.subjKey;
  const objKey  = Mob.m2.flip ? Mob.m2.subjKey : Mob.m2.objKey;

  const block1 = m2Block(subjKey);
  const block3 = m2Block(objKey);

  const s1 = document.createElement("span");
  s1.className="lock";
  s1.textContent = block1 + " ";

  const sv = document.createElement("span");
  sv.className="w verb";
  sv.textContent = realize(Mob.m2.verbKey) + " ";
  sv.addEventListener("click", (e)=>{ e.stopPropagation(); doM2VerbClick(); });

  const s3 = document.createElement("span");
  s3.className="lock";
  s3.textContent = block3 + ".";

  el.appendChild(s1);
  el.appendChild(sv);
  el.appendChild(s3);
}

/* regra: inverter só troca posições; não reamostra */
function doM2Swap(){
  Mob.m2.flip = !Mob.m2.flip;
  applyDelta({ front: (Mob.m2.flip? -0.08:+0.08), pressure: 0.03, cont:rnd(-0.02,0.02) });
  rerenderM2(true);
}

/* regra: clicar no verbo muda SOMENTE o objeto (bloco 3) */
function doM2VerbClick(){
  Mob.m2.verbIx = (Mob.m2.verbIx + 1) % M2_VERBS.length;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];

  const pool = (G.dense>0.18) ? N_PLAS.concat(N_MEM) : N_MEM.concat(N_SENS);
  Mob.m2.objKey = pick(pool);

  applyDelta({ pressure: 0.06, dense:rnd(-0.04,0.04), cont:rnd(-0.04,0.04) });
  rerenderM2(false);
}

/* ============================================================
   DESENHO (cenários + slots)
============================================================ */
function drawScene(ctx, key, W, H){
  ctx.clearRect(0,0,W,H);

  ctx.save();
  ctx.fillStyle = "rgba(255,255,255,.22)";
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  const g1 = ctx.createRadialGradient(W*0.20,H*0.20,20, W*0.20,H*0.20, W*0.70);
  g1.addColorStop(0,"rgba(255,170,210,.28)");
  g1.addColorStop(1,"rgba(255,170,210,0)");
  ctx.fillStyle=g1; ctx.fillRect(0,0,W,H);

  const g2 = ctx.createRadialGradient(W*0.75,H*0.18,30, W*0.75,H*0.18, W*0.72);
  g2.addColorStop(0,"rgba(170,215,255,.26)");
  g2.addColorStop(1,"rgba(170,215,255,0)");
  ctx.fillStyle=g2; ctx.fillRect(0,0,W,H);

  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(24,19,21,.22)";
  ctx.fillStyle = "rgba(255,255,255,.10)";

  if(key==="m1"){
    ctx.beginPath();
    ctx.moveTo(W*0.10,H*0.18);
    ctx.quadraticCurveTo(W*0.50,H*0.04, W*0.90,H*0.18);
    ctx.stroke();
    [0.18,0.50,0.82].forEach(x=>{
      ctx.beginPath();
      ctx.moveTo(W*x,H*0.18);
      ctx.lineTo(W*x,H*0.34);
      ctx.stroke();
    });
  }
  if(key==="m2"){
    ctx.beginPath();
    ctx.moveTo(0,H*0.58);
    ctx.lineTo(W*0.20,H*0.42);
    ctx.lineTo(W*0.38,H*0.58);
    ctx.lineTo(W*0.55,H*0.36);
    ctx.lineTo(W*0.76,H*0.58);
    ctx.lineTo(W,H*0.46);
    ctx.lineTo(W,H);
    ctx.lineTo(0,H);
    ctx.closePath();
    ctx.fillStyle="rgba(255,255,255,.12)";
    ctx.fill();
    ctx.strokeStyle="rgba(24,19,21,.18)";
    ctx.stroke();

    ctx.strokeStyle="rgba(24,19,21,.20)";
    for(let i=0;i<7;i++){
      const x = W*(0.12 + i*0.12) + rnd(-8,8);
      const y = H*(0.70 + rnd(-0.02,0.02));
      ctx.beginPath();
      ctx.moveTo(x,y);
      ctx.lineTo(x+8,y-3);
      ctx.lineTo(x+14,y);
      ctx.stroke();
    }
  }
  if(key==="m3"){
    ctx.strokeStyle="rgba(24,19,21,.18)";
    for(let y=0;y<7;y++){
      for(let x=0;x<11;x++){
        if(Math.random()<0.35){
          ctx.strokeRect(W*0.05 + x*(W*0.085), H*0.10 + y*(H*0.11), W*0.075, H*0.095);
        }
      }
    }
  }
  if(key==="m4"){
    ctx.strokeStyle="rgba(24,19,21,.20)";
    const steps=10;
    for(let i=0;i<steps;i++){
      const x = W*0.12 + i*(W*0.06);
      const y = H*0.65 - i*(H*0.04);
      ctx.strokeRect(x,y, W*0.12, H*0.06);
    }
    for(let i=0;i<steps;i++){
      const x = W*0.55 + i*(W*0.03);
      const y = H*0.28 + i*(H*0.05);
      ctx.strokeRect(x,y, W*0.14, H*0.06);
    }
  }
  ctx.restore();
}

function slotFamily(slot){
  const n = parseInt((slot.fam||"F1").replace("F",""),10);
  return isNaN(n)?1:n;
}

async function preloadSlotImage(slot, onload){
  if(!slot.sui) return;
  if(slot._img) return;

  const img = new Image();
  img.crossOrigin = "anonymous";

  let tried = 0;
  const load = () => {
    tried++;
    img.src = tried === 1 ? (slot.sui.path + "?v=" + Date.now()) : slot.sui.path;
  };

  img.onload = onload;
  img.onerror = () => {
    if(tried < 2){
      load();
      return;
    }
    console.warn("Falha ao carregar imagem da Sui:", slot.sui.path);
  };

  slot._img = img;
  load();
}

function drawProcedural(ctx, slot, x,y,w,h){
  const fam = slotFamily(slot);
  ctx.save();
  ctx.translate(x,y);

  ctx.fillStyle = "rgba(255,255,255,.55)";
  ctx.fillRect(0,0,w,h);

  ctx.fillStyle = "rgba(40,30,38,.07)";
  ctx.fillRect(0,0,w,h);

  const hue = (fam*27 + slot.v*11) % 360;
  ctx.fillStyle = `hsla(${hue}, 65%, 80%, 0.26)`;
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle = "rgba(24,19,21,.30)";
  ctx.lineWidth = 2;

  if(fam===1){
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(0, h*(0.15+i*0.14));
      ctx.lineTo(w, h*(0.15+i*0.14)+rnd(-6,6));
      ctx.stroke();
    }
  } else if(fam===2){
    for(let i=0;i<5;i++){
      const xx = w*(0.18+i*0.16)+rnd(-6,6);
      ctx.beginPath();
      ctx.moveTo(xx,0);
      ctx.lineTo(xx,h);
      ctx.stroke();
    }
  } else if(fam===3){
    ctx.beginPath();
    ctx.moveTo(w*0.1,h*0.8);
    ctx.lineTo(w*0.9,h*0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w*0.15,h*0.55);
    ctx.lineTo(w*0.85,h*0.15);
    ctx.stroke();
  } else if(fam===4){
    for(let i=0;i<7;i++){
      ctx.beginPath();
      ctx.arc(w*(0.15+i*0.12), h*(0.55+rnd(-0.08,0.08)), 9+rnd(-3,3), 0, Math.PI*2);
      ctx.stroke();
    }
  } else if(fam===5){
    ctx.beginPath();
    ctx.moveTo(w*0.1,h*0.1);
    ctx.lineTo(w*0.9,h*0.9);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w*0.9,h*0.1);
    ctx.lineTo(w*0.1,h*0.9);
    ctx.stroke();
  } else if(fam===6){
    for(let i=0;i<10;i++){
      ctx.fillStyle = `rgba(24,19,21,${0.04+rnd(0,0.06)})`;
      ctx.fillRect(rnd(0,w), rnd(0,h), rnd(18,60), rnd(12,48));
    }
  } else if(fam===7){
    ctx.fillStyle="rgba(255,255,255,.62)";
    ctx.fillRect(0,0,w,h);
    ctx.strokeStyle="rgba(24,19,21,.18)";
    ctx.strokeRect(w*0.10,h*0.18,w*0.80,h*0.64);
  } else if(fam===8){
    ctx.beginPath();
    ctx.strokeRect(w*0.18+rnd(-10,10), h*0.18+rnd(-10,10), w*0.64, h*0.64);
  } else if(fam===9){
    ctx.fillStyle="rgba(24,19,21,.06)";
    for(let i=0;i<60;i++){
      ctx.fillRect(rnd(0,w), rnd(0,h), 2, 2);
    }
  } else if(fam===10){
    ctx.beginPath();
    ctx.moveTo(w*0.15,h*0.25);
    ctx.lineTo(w*0.85,h*0.25);
    ctx.lineTo(w*0.50,h*0.85);
    ctx.closePath();
    ctx.stroke();
  } else if(fam===11){
    ctx.beginPath();
    ctx.strokeRect(w*0.12,h*0.12,w*0.76,h*0.76);
    ctx.beginPath();
    ctx.strokeRect(w*0.22,h*0.22,w*0.56,h*0.56);
  } else {
    ctx.fillStyle="rgba(24,19,21,.10)";
    ctx.fillRect(w*0.15,h*0.18,w*0.70,h*0.62);
  }

  ctx.restore();
}

function drawSlot(ctx, slot, x,y,w,h){
  ctx.save();
  ctx.shadowColor="rgba(0,0,0,.12)";
  ctx.shadowBlur=18;
  ctx.shadowOffsetY=10;

  ctx.fillStyle="rgba(255,255,255,.60)";
  ctx.fillRect(x,y,w,h);

  ctx.shadowColor="transparent";
  ctx.lineWidth=3;
  ctx.strokeStyle="rgba(24,19,21,.34)";
  ctx.strokeRect(x,y,w,h);

  if(slot.sui && slot._img && slot._img.complete && slot._img.naturalWidth){
    ctx.save();
    ctx.beginPath();
    ctx.rect(x+3,y+3,w-6,h-6);
    ctx.clip();
    ctx.drawImage(slot._img, x+3, y+3, w-6, h-6);
    ctx.restore();
  } else {
    drawProcedural(ctx, slot, x+3,y+3,w-6,h-6);
  }

  ctx.restore();
}

/* ============================================================
   DRAW MOBILE (com cache de slots por móbile)
============================================================ */
const HITS = { m1:[], m2:[], m3:[], m4:[], final:[] };

async function drawMobile(canvas, key, count){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  drawScene(ctx, key, W, H);

  if(!Mob[key].slots){
    let slots = sampleSlots(count);
    slots = ensureSui(slots);
    Mob[key].slots = slots;
  }
  const slots = Mob[key].slots;

  for(const s of slots){
    if(s.sui && !s._img){
      await preloadSlotImage(s, ()=>{ rerenderOne(key); });
    }
  }

  const hits = [];
  if(key==="m1"){
    const w = W*0.22, h = H*0.30;
    const xs = [W*0.18, W*0.50, W*0.82];
    const ys = [H*0.42, H*0.42, H*0.42];
    for(let i=0;i<3;i++){
      const x = xs[i]-w/2;
      const y = ys[i]-h/2;
      drawSlot(ctx, slots[i], x,y,w,h);
      hits.push({x,y,w,h,slot:slots[i]});
    }
  } else if(key==="m2"){
    const bigW=W*0.36, bigH=H*0.42;
    const smallW=W*0.26, smallH=H*0.30;

    const a = slots[0];
    const b = slots[1];

    const frontSlot = Mob.m2.flip ? b : a;
    const backSlot  = Mob.m2.flip ? a : b;

    let xB=W*0.66 - smallW/2;
    let yB=H*0.48 - smallH/2;
    drawSlot(ctx, backSlot, xB,yB,smallW,smallH);
    hits.push({x:xB,y:yB,w:smallW,h:smallH,slot:backSlot});

    let xF=W*0.30 - bigW/2;
    let yF=H*0.60 - bigH/2;
    drawSlot(ctx, frontSlot, xF,yF,bigW,bigH);
    hits.push({x:xF,y:yF,w:bigW,h:bigH,slot:frontSlot});
  } else if(key==="m3"){
    const baseW=W*0.18, baseH=H*0.24;
    for(let i=0;i<7;i++){
      const s=slots[i];
      const x = W*(0.10 + (i%4)*0.20) + rnd(-14,14);
      const y = H*(0.18 + Math.floor(i/4)*0.34) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.14);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.12);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  } else if(key==="m4"){
    const baseW=W*0.20, baseH=H*0.22;
    for(let i=0;i<5;i++){
      const s=slots[i];
      const x = W*(0.12 + i*0.17) + rnd(-10,10);
      const y = H*(0.22 + (i%2)*0.22) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.12);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.10);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  } else if(key==="final"){
    const baseW=W*0.19, baseH=H*0.22;
    for(let i=0;i<10;i++){
      const s=slots[i];
      const x = W*(0.08 + (i%5)*0.18) + rnd(-10,10);
      const y = H*(0.16 + Math.floor(i/5)*0.34) + rnd(-10,10);
      const w = baseW * (0.92 + (s.axes.front+1)*0.14);
      const h = baseH * (0.92 + (s.axes.dense+1)*0.12);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  }

  HITS[key] = hits;
}

/* ============================================================
   TEXT RENDER (restrições por móbile)
============================================================ */
function setTextPlain(el, text){
  el.textContent = text;
}

function setTextInteractive(el, text){
  el.innerHTML = "";
  const parts = text.split(/\s+/).filter(Boolean);
  for(const p of parts){
    const span = document.createElement("span");
    span.className="w";
    span.textContent = p + " ";
    el.appendChild(span);
  }
}

/* ============================================================
   RERENDER por partes
============================================================ */
async function rerenderOne(key){
  if(key==="m1") return rerenderM1();
  if(key==="m2") return rerenderM2();
  if(key==="m3") return rerenderM3();
  if(key==="m4") return rerenderM4();
  if(key==="final") return rerenderFinal();
}

async function rerenderM1(){
  await drawMobile(document.getElementById("m1Canvas"), "m1", 3);
  setTextPlain(document.getElementById("m1Text"), genCuratorialParagraph("m1"));
}

async function rerenderM2(){
  await drawMobile(document.getElementById("m2Canvas"), "m2", 2);
  renderM2Text();
}

async function rerenderM3(){
  await drawMobile(document.getElementById("m3Canvas"), "m3", 7);
  setTextInteractive(document.getElementById("m3Text"), genCuratorialParagraph("m3"));
}

async function rerenderM4(){
  await drawMobile(document.getElementById("m4Canvas"), "m4", 5);
  setTextInteractive(document.getElementById("m4Text"), genCuratorialParagraph("m4"));
}

async function rerenderFinal(){
  await drawMobile(document.getElementById("finalCanvas"), "final", 10);

  const A = buildFinalA();
  const B = buildFinalB();

  const shareInvite =
`Partilha a tua exposição.
Cada percurso faz emergir obras diferentes.
Outras pessoas verão imagens que talvez nunca tenhas conseguido alcançar.

E você — o que montaria aqui?
${location.href}`;

  const full = `${A}\n\n${B}\n\n${TEXT_FINAL_CLOSING}\n\n${shareInvite}`;
  document.getElementById("finalText").textContent = full;

  document.getElementById("weeklyGate").textContent =
`Para ver os demais estados expositivos da semana, faz primeiro a tua curadoria (gera a tua expo).`;
}

async function rerenderAll(){
  await rerenderM1();
  await rerenderM2();
  await rerenderM3();
  await rerenderM4();
  if(Mob.final.ready) await rerenderFinal();
}

/* ============================================================
   FINAL TEXTS (duas partes)
============================================================ */
function buildFinalA(){
  const pFront = (G.front>0.25) ? "frente / figura" : (G.front<-0.25) ? "fundo / atmosfera" : "equilíbrio de planos";
  const pDense = (G.dense>0.25) ? "densidade e peso" : (G.dense<-0.25) ? "rarefação e respiro" : "densidade contida";
  const pCont  = (G.cont>0.25)  ? "continuidade e fluxo" : (G.cont<-0.25) ? "corte e decisão" : "passagens cautelosas";
  const pPh    = phMode()==="surda" ? "corte seco (plosivas surdas)" : phMode()==="sonora" ? "massa/peso (plosivas sonoras)" : "passagem (fricativas)";

  return `O teu estilo curatorial inclina-se para ${pFront}, com ${pDense}. Predomina ${pCont}, sob um corpo sonoro de ${pPh}.`;
}

function buildFinalB(){
  const n1 = Npick(N_PLAS);
  const n2 = Npick(N_SENS);
  const n3 = Npick(N_MEM);
  const v1 = Vpick(V_COMP);
  const a1 = maybeAdj();
  const adv = maybeAdv();

  return `A exposição resultante ${v1} ${n1} como campo ${a1||Npick(N_CUR)}: ${n2} surge em primeiro plano, enquanto ${n3} permanece como resto${adv?(" — "+adv):""}.`;
}

function buildFinalText(){
  return `${buildFinalA()}\n\n${buildFinalB()}`;
}

/* ============================================================
   INTERAÇÕES (restritas como combinado)
============================================================ */
function bindCanvasClicks(key, canvas){
  canvas.addEventListener("click", (ev)=>{
    if(key==="m1" || key==="m4" || key==="final") return;

    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top)  * (canvas.height/ r.height);
    const hits = HITS[key] || [];
    const hit = hits.find(h => x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h);
    if(!hit) return;

    try{
      if(key==="m2"){ doM2Swap(); return; }

      if(key==="m3"){
        const slot = hit.slot;
        const fam = slotFamily(slot);

        Mob.m3.focusFam = fam;
        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.14, 0, 1);
        Mob.m3.clicks++;

        applyDelta({
          pressure: 0.03,
          cont: (fam===1||fam===4||fam===7) ? +0.05 : -0.02,
          dense:(fam===6||fam===12) ? +0.05 : 0.00,
          front:(fam===2||fam===5) ? +0.05 : 0.00
        });

        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          Mob.m3.slots = null;
          toast("M3: catástrofe — nova configuração.");
        }

        rerenderM3();
        rerenderM4();
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no clique (ver consola).");
    }
  });
}

function bindTextClicks(key, textEl){
  textEl.addEventListener("click", (ev)=>{
    const t = ev.target;
    if(!t || !t.classList || !t.classList.contains("w")) return;

    try{
      if(key==="m3"){
        const axe = (Math.abs(G.cont)>Math.abs(G.front) && Math.abs(G.cont)>Math.abs(G.dense)) ? "cont"
                  : (Math.abs(G.dense)>Math.abs(G.front)) ? "dense" : "front";

        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.12, 0, 1);

        const delta = { front:0, dense:0, cont:0, pressure:0.025 };
        delta[axe] = 0.06;
        applyDelta(delta);

        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          Mob.m3.slots = null;
          toast("M3: catástrofe — nova configuração.");
        }

        rerenderM3();
        rerenderM4();
        return;
      }

      if(key==="m4"){
        Mob.m4.intensity = clamp(Mob.m4.intensity + 0.14, 0, 1);
        Mob.m4.clicks++;

        const mode = phMode();
        if(mode==="surda") applyDelta({ ph:{dry:+0.30}, pressure:+0.04, cont:-0.02 });
        else if(mode==="sonora") applyDelta({ ph:{voiced:+0.30}, pressure:+0.04, dense:+0.02 });
        else applyDelta({ ph:{open:+0.30}, pressure:+0.04, cont:+0.02 });

        if(Mob.m4.intensity >= 0.98){
          Mob.m4.intensity = 0;
          Mob.m4.focusPh = null;
          Mob.m4.slots = null;
          toast("M4: colapso — o corpo sonoro virou regime.");
        }

        rerenderM4();
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no texto (ver consola).");
    }
  });
}

/* ============================================================
   BOTÕES / SHARE
============================================================ */
function openShare(title, note, text, srcCanvasId){
  document.getElementById("shareTitle").textContent = title;
  document.getElementById("shareNote").textContent = note;
  document.getElementById("shareText").value = text;

  const src = document.getElementById(srcCanvasId);
  const out = document.getElementById("shareCanvas");
  const ctx = out.getContext("2d");

  ctx.clearRect(0,0,out.width,out.height);
  ctx.fillStyle = "rgba(255,255,255,.94)";
  ctx.fillRect(0,0,out.width,out.height);

  ctx.fillStyle = "rgba(24,19,21,.88)";
  ctx.font = "900 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("MÓBILES — suiornotsui", 42, 48);

  ctx.fillStyle = "rgba(24,19,21,.55)";
  ctx.font = "14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(new Date().toISOString().slice(0,19).replace("T"," "), 42, 72);

  const pad = 42;
  const targetW = out.width - pad*2;
  const ratio = src.height / src.width;
  const targetH = Math.min(out.height*0.56, targetW*ratio);
  const dx = pad;
  const dy = 96;
  ctx.drawImage(src, dx, dy, targetW, targetH);

  const textTop = dy + targetH + 46;
  ctx.fillStyle = "rgba(24,19,21,.82)";
  ctx.font = "16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const lines = text.split("\n").join(" ").split(/(?<=\.)\s+/).slice(0,10);
  let y = textTop;
  for(const ln of lines){
    const s = ln.trim();
    if(!s) continue;
    wrapLine(ctx, s, pad, y, out.width - pad*2, 22);
    y += 28;
    if(y>out.height-40) break;
  }

  document.getElementById("overlay").style.display="flex";
}

function wrapLine(ctx, text, x, y, maxWidth, lineHeight){
  const words = text.split(" ");
  let line = "";
  for(let n=0;n<words.length;n++){
    const test = line + words[n] + " ";
    if(ctx.measureText(test).width > maxWidth && n>0){
      ctx.fillText(line, x, y);
      line = words[n] + " ";
      y += lineHeight;
    } else {
      line = test;
    }
  }
  ctx.fillText(line, x, y);
}

function closeShare(){ document.getElementById("overlay").style.display="none"; }
window.closeShare = closeShare;

function canvasToDataURL(canvas){
  try{ return canvas.toDataURL("image/png"); }catch(e){ return ""; }
}

function shareTextFor(kind){
  const link = location.href;
  if(kind==="m1"){
    return `MÓBILES (entrada) — eu tensionei o nascimento do campo.\n\nNão escolhi “imagens”: escolhi posição.\n\nFaz o teu percurso aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m2"){
    return `MÓBILES — posição e estrutura (S–V–O).\nInverter troca sujeito↔objeto; clicar no verbo muda o objeto.\n\nFaz o teu aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m3"){
    return `MÓBILES — foco e estilo.\nOnde eu insisti, um traço cresceu; o resto recuou.\n\nTesta o teu gesto: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m4"){
    return `MÓBILES — corpo sonoro da linguagem.\nInsisti no som até o regime ceder.\n\nJoga também: ${link}\n\nassinatura: suiornotsui`;
  }
  return `MÓBILES — minha exposição provisória.\n\n${buildFinalText()}\n\n${link}\n\nassinatura: suiornotsui`;
}

function bindButtons(){
  document.getElementById("m1Tension").addEventListener("click", ()=>{
    G.birthMode = (G.birthMode + 1) % 3;
    if(G.birthMode===0){
      applyDelta({ front:rnd(-0.25,0.25), dense:rnd(-0.15,0.15), cont:+0.20, ph:{open:+0.12}, pressure:0.10 });
    }else if(G.birthMode===1){
      applyDelta({ front:+0.28, dense:+0.10, cont:-0.25, ph:{dry:+0.16}, pressure:0.12 });
    }else{
      applyDelta({ front:-0.28, dense:-0.10, cont:+0.05, ph:{voiced:+0.16}, pressure:0.12 });
    }

    Mob.m1.slots=null;
    Mob.m2.slots=null; Mob.m2.subjKey=null; Mob.m2.objKey=null; Mob.m2.verbKey=null;
    Mob.m3.slots=null; Mob.m3.intensity=0;
    Mob.m4.slots=null; Mob.m4.intensity=0;
    Mob.final.slots=null;

    rerenderAll();
  });

  document.getElementById("m2Swap").addEventListener("click", doM2Swap);

  document.getElementById("btnFinalize").addEventListener("click", ()=>{
    Mob.final.ready = true;
    Mob.final.slots = ensureSui(sampleSlots(10));
    rerenderFinal();
    toast("Exposição gerada.");
  });

  document.getElementById("m1Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 1", "imagem + texto", shareTextFor("m1"), "m1Canvas");
  });
  document.getElementById("m2Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 2", "imagem + texto", shareTextFor("m2"), "m2Canvas");
  });
  document.getElementById("m3Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 3", "imagem + texto", shareTextFor("m3"), "m3Canvas");
  });
  document.getElementById("m4Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 4", "imagem + texto", shareTextFor("m4"), "m4Canvas");
  });
  document.getElementById("finalShare").addEventListener("click", ()=>{
    if(!Mob.final.ready){
      toast("Gera a tua exposição primeiro.");
      return;
    }
    openShare("Partilhar — Exposição", "imagem + texto", shareTextFor("final"), "finalCanvas");
  });

  document.getElementById("copyTextBtn").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(document.getElementById("shareText").value);
      toast("Texto copiado.");
    }catch(e){
      toast("Não foi possível copiar.");
    }
  });

  document.getElementById("downloadBtn").addEventListener("click", ()=>{
    const c = document.getElementById("shareCanvas");
    const a = document.createElement("a");
    a.download = "mobiles.png";
    a.href = canvasToDataURL(c);
    a.click();
  });

  document.getElementById("nativeShareBtn").addEventListener("click", async ()=>{
    const text = document.getElementById("shareText").value;
    const c = document.getElementById("shareCanvas");
    if(!navigator.share){
      toast("Partilha nativa indisponível aqui.");
      return;
    }
    try{
      const blob = await (await fetch(c.toDataURL("image/png"))).blob();
      const file = new File([blob], "mobiles.png", {type:"image/png"});
      await navigator.share({ text, files:[file] });
    }catch(e){
      toast("Partilha cancelada ou indisponível.");
    }
  });
}

/* ============================================================
   BOOT
============================================================ */
async function boot(){
  document.getElementById("leadText").textContent = TEXT_OPENING;
  document.getElementById("introM1").textContent = INTRO_M1;
  document.getElementById("introM2").textContent = INTRO_M2;
  document.getElementById("introM3").textContent = INTRO_M3;
  document.getElementById("introM4").textContent = INTRO_M4;
  document.getElementById("closingText").textContent = TEXT_FINAL_CLOSING;
  document.getElementById("finalIntro").textContent = "Depois do último móbile, encerra — e gera a tua exposição.";

  buildField();
  await tryLoadSui();

  bindButtons();
  bindCanvasClicks("m1", document.getElementById("m1Canvas"));
  bindCanvasClicks("m2", document.getElementById("m2Canvas"));
  bindCanvasClicks("m3", document.getElementById("m3Canvas"));
  bindCanvasClicks("m4", document.getElementById("m4Canvas"));
  bindCanvasClicks("final", document.getElementById("finalCanvas"));

  bindTextClicks("m3", document.getElementById("m3Text"));
  bindTextClicks("m4", document.getElementById("m4Text"));

  updatePill();
  await rerenderAll();
}

boot();
</script>
</body>
</html>
