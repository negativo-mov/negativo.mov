<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg0:#fbf4f8;
      --bg1:#f3f7ff;
      --ink:#1a1a1a;
      --mut:#45424a;
      --shadow: 0 18px 70px rgba(25,16,40,.16);
      --shadow2: 0 10px 36px rgba(25,16,40,.12);
      --radius: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(255,210,232,.75), transparent 55%),
        radial-gradient(1100px 900px at 85% 20%, rgba(207,226,255,.85), transparent 60%),
        radial-gradient(900px 900px at 30% 85%, rgba(215,255,232,.65), transparent 55%),
        radial-gradient(900px 900px at 80% 85%, rgba(217,199,255,.55), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .wrap{
      width:min(980px, calc(100% - 28px));
      margin: 28px auto 140px;
    }

    .title{
      margin: 8px 0 10px;
      font-size: 26px;
      letter-spacing: .2px;
      font-weight: 820;
      color: #120f17;
    }

    .lead{
      font-size: 16px;
      line-height: 1.55;
      color: var(--mut);
      white-space: pre-line;
      margin: 14px 0 22px;
      padding: 18px 18px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.55);
      box-shadow: var(--shadow2);
      border: 1.5px solid rgba(20,10,30,.12);
      backdrop-filter: blur(6px);
    }

    .sig{
      display:inline-block;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(20,10,30,.64);
      background: rgba(255,255,255,.6);
      border: 1px solid rgba(20,10,30,.12);
      padding: 6px 10px;
      border-radius: 999px;
      margin: 10px 0 0;
    }

    .section{ margin: 28px 0; }

    .intro{
      white-space: pre-line;
      font-size: 15px;
      line-height: 1.55;
      color: rgba(15,10,22,.80);
      margin: 0 0 14px;
      padding: 14px 16px;
      border-radius: 18px;
      background: rgba(255,255,255,.50);
      border: 1.3px solid rgba(20,10,30,.10);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(6px);
    }

    .scene{
      position: relative;
      border-radius: calc(var(--radius) + 8px);
      border: 1.6px solid rgba(20,10,30,.14);
      background: rgba(255,255,255,.42);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    /* ========= tensivo: o campo “respira” ========= */
    .scene::after{
      content:"";
      position:absolute;
      inset:-12%;
      background:
        radial-gradient(700px 420px at 30% 20%, rgba(255,210,232,.22), transparent 60%),
        radial-gradient(820px 520px at 75% 35%, rgba(207,226,255,.22), transparent 65%),
        radial-gradient(900px 520px at 45% 85%, rgba(215,255,232,.18), transparent 65%);
      opacity:.9;
      mix-blend-mode:multiply;
      transform: translate3d(var(--bx,0px), var(--by,0px), 0) rotate(var(--br,0deg));
      transition: transform 520ms ease;
      pointer-events:none;
    }

    .scenePad{ padding: 18px; position:relative; z-index:1; }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      padding: 14px 16px;
      border-top: 1px solid rgba(20,10,30,.10);
      background: rgba(255,255,255,.40);
      backdrop-filter: blur(6px);
      position:relative;
      z-index:2;
    }

    button{
      font-family: var(--sans);
      font-weight: 720;
      letter-spacing:.2px;
      border-radius: 999px;
      padding: 10px 14px;
      border: 1.4px solid rgba(20,10,30,.16);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.62));
      color: #140e1e;
      box-shadow: 0 10px 20px rgba(20,10,30,.10);
      cursor:pointer;
      user-select:none;
    }
    button:hover{ transform: translateY(-1px); }
    button:active{ transform: translateY(0px); }
    button.small{ padding: 8px 12px; font-size: 13px; }
    button.ghost{
      background: rgba(255,255,255,.35);
      box-shadow: none;
    }

    .hint{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(15,10,22,.65);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px dashed rgba(20,10,30,.18);
      background: rgba(255,255,255,.35);
    }

    /* ========= layouts ========= */
    .frGrid3{ display:grid; grid-template-columns: repeat(3, 1fr); gap: 14px; }
    .frGrid7{ display:grid; grid-template-columns: repeat(7, 1fr); gap: 10px; }
    .frGrid5{ display:grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
    .fr2{ display:grid; grid-template-columns: 1.25fr .75fr; gap: 14px; align-items:end; }

    @media (max-width: 860px){
      .frGrid7{ grid-template-columns: repeat(4, 1fr); }
      .frGrid5{ grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 700px){
      .fr2{ grid-template-columns: 1fr; }
    }
    @media (max-width: 520px){
      .frGrid7{ grid-template-columns: repeat(3, 1fr); }
      .frGrid5{ grid-template-columns: repeat(2, 1fr); }
    }

    /* ========= fragmentos ========= */
    .frag{
      position: relative;
      border-radius: 18px;
      border: 2.2px solid rgba(20,10,30,.72);
      background: rgba(255,255,255,.40);
      box-shadow: 0 14px 32px rgba(20,10,30,.18);
      overflow:hidden;
      aspect-ratio: 1 / 1;
      display:flex;
      align-items:center;
      justify-content:center;

      transform: translate3d(var(--dx,0px), var(--dy,0px), 0) rotate(var(--dr,0deg));
      transition: transform 520ms ease, box-shadow 220ms ease, outline 220ms ease;
      will-change: transform;
    }

    .frag .img{
      width: 100%;
      height: 100%;
      object-fit: contain; /* nunca achatar a Sui */
      background: rgba(255,255,255,.25);
    }

    .frag.clickable{ cursor:pointer; }
    .frag.clickable:hover{
      box-shadow: 0 18px 42px rgba(20,10,30,.22);
      outline: 3px solid rgba(255,255,255,.65);
      transform: translate3d(calc(var(--dx,0px)), calc(var(--dy,0px) - 2px), 0) rotate(var(--dr,0deg));
    }

    .fragTag{
      position:absolute;
      left: 10px;
      top: 10px;
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(20,10,30,.14);
      color: rgba(20,10,30,.75);
      pointer-events:none;
    }

    /* ========= fundos por cena ========= */
    .bg-crib::before,
    .bg-mountains::before,
    .bg-lab::before,
    .bg-stairs::before{
      content:"";
      position:absolute;
      inset:0;
      opacity:.85;
      pointer-events:none;
      mix-blend-mode: multiply;
    }

    .bg-crib::before{
      background:
        radial-gradient(400px 240px at 50% 20%, rgba(255,255,255,.85), transparent 60%),
        linear-gradient(180deg, rgba(255,210,232,.55), rgba(217,199,255,.25)),
        repeating-linear-gradient(90deg, rgba(20,10,30,.10) 0 2px, transparent 2px 12px);
    }

    .bg-mountains::before{
      background:
        linear-gradient(180deg, rgba(207,226,255,.55), rgba(255,243,218,.35)),
        radial-gradient(900px 450px at 40% 85%, rgba(180,255,207,.35), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='420' viewBox='0 0 1200 420'%3E%3Cpath d='M0 340 L170 230 L320 330 L500 190 L680 340 L860 210 L1020 340 L1200 250 L1200 420 L0 420 Z' fill='rgba(20,10,30,0.08)'/%3E%3Cpath d='M0 360 L150 280 L280 355 L460 240 L620 370 L780 260 L940 360 L1200 290 L1200 420 L0 420 Z' fill='rgba(20,10,30,0.06)'/%3E%3C/svg%3E");
      background-repeat:no-repeat;
      background-position:center bottom;
      background-size: cover;
    }

    .bg-lab::before{
      background:
        radial-gradient(700px 420px at 30% 20%, rgba(255,210,232,.35), transparent 60%),
        radial-gradient(700px 420px at 85% 30%, rgba(207,226,255,.35), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='700' viewBox='0 0 1200 700'%3E%3Cg fill='none' stroke='rgba(20,10,30,0.16)' stroke-width='5'%3E%3Cpath d='M80 120 H420 V260 H240 V400 H520 V560 H980'/%3E%3Cpath d='M160 80 H560 V200 H360 V320 H640 V460 H420 V620 H1120'/%3E%3Cpath d='M60 520 H280 V360 H120 V240 H320 V120 H980'/%3E%3C/g%3E%3C/svg%3E");
      background-size: cover;
      background-position:center;
    }

    .bg-stairs::before{
      background:
        radial-gradient(900px 520px at 50% 18%, rgba(255,243,218,.45), transparent 55%),
        radial-gradient(820px 520px at 35% 85%, rgba(217,199,255,.25), transparent 60%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='520' viewBox='0 0 1200 520'%3E%3Cg fill='none' stroke='rgba(20,10,30,0.16)' stroke-width='7'%3E%3Cpath d='M120 420 L260 340 L400 420 L540 340 L680 420 L820 340 L960 420'/%3E%3Cpath d='M220 130 L220 320 L360 240 L360 430'/%3E%3Cpath d='M620 90 L760 170 L620 250 L760 330 L620 410'/%3E%3Cpath d='M980 140 L860 220 L980 300 L860 380'/%3E%3C/g%3E%3C/svg%3E");
      background-size: cover;
      background-position:center;
    }

    /* ========= textos ========= */
    .dyn{ padding: 0 18px 18px; position:relative; z-index:2; }
    .dyn p{
      margin: 10px 0 0;
      color: rgba(20,10,30,.86);
      line-height: 1.6;
      font-size: 15px;
    }
    .dyn .small{
      font-size: 13px;
      color: rgba(20,10,30,.70);
    }

    /* token clicável */
    .tok{
      display:inline-block;
      padding: 0 2px;
      border-radius: 6px;
      transition: background .12s ease, outline .12s ease, transform .12s ease;
    }
    .tok.click{
      cursor:pointer;
      outline: 1.2px dashed rgba(20,10,30,.18);
      background: rgba(255,255,255,.35);
    }
    .tok.click:hover{
      background: rgba(255,255,255,.68);
      outline-color: rgba(20,10,30,.30);
      transform: translateY(-1px);
    }
    .tok.verb{
      font-weight: 820;
      outline: 2px solid rgba(20,10,30,.65);
      background: rgba(255,255,255,.72);
    }

    /* final */
    .finalWrap{ margin-top: 16px; padding: 18px; }
    .constellation{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 14px;
    }
    @media (max-width: 860px){
      .constellation{ grid-template-columns: repeat(3, 1fr); }
    }
    @media (max-width: 520px){
      .constellation{ grid-template-columns: repeat(2, 1fr); }
    }

    .note{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(20,10,30,.65);
      margin-top: 12px;
      white-space: pre-line;
    }

    .flash{ animation: flash .22s ease-in-out 1; }
    @keyframes flash{
      0%{ filter: saturate(1); }
      50%{ filter: saturate(1.7) contrast(1.05); }
      100%{ filter: saturate(1); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">MÓBILES — entrada</div>

    <div class="lead" id="opening">
Operas aqui a tua própria curadoria.
A artista é suiornotsui.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.
Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto —
aquilo que nunca aparece —
sustenta o desejo de continuar.</div>

    <div class="sig">suiornotsui</div>

    <!-- M1 -->
    <div class="section" id="m1">
      <div class="intro">
Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.</div>

      <div class="scene bg-crib" id="scene_m1">
        <div class="scenePad frGrid3" id="m1_frags"></div>
        <div class="dyn">
          <p id="m1_text"></p>
        </div>
        <div class="controls">
          <button id="btn_m1">Tensionar o início</button>
          <span class="hint">M1: só este botão opera.</span>
          <button class="small ghost" id="share_m1">Partilhar este móbile</button>
        </div>
      </div>
    </div>

    <!-- M2 -->
    <div class="section" id="m2">
      <div class="intro">
Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.</div>

      <div class="scene bg-mountains" id="scene_m2">
        <div class="scenePad fr2" id="m2_frags"></div>
        <div class="dyn">
          <p id="m2_text"></p>
          <p class="small">M2: clicar nos fragmentos apenas inverte frente↔fundo e sujeito↔objeto. Clicar no verbo muda apenas o objeto (e o fragmento do objeto).</p>
        </div>
        <div class="controls">
          <span class="hint">M2: só fragmentos + verbo.</span>
          <button class="small ghost" id="share_m2">Partilhar este móbile</button>
        </div>
      </div>
    </div>

    <!-- M3 -->
    <div class="section" id="m3">
      <div class="intro">
O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.</div>

      <div class="scene bg-lab" id="scene_m3">
        <div class="scenePad frGrid7" id="m3_frags"></div>
        <div class="dyn">
          <p id="m3_text"></p>
          <p class="small">M3: clique local (palavra ou fragmento) reforça o traço daquele item e espraia com decaimento.</p>
        </div>
        <div class="controls">
          <span class="hint">M3: só palavras + fragmentos.</span>
          <button class="small ghost" id="share_m3">Partilhar este móbile</button>
        </div>
      </div>
    </div>

    <!-- M4 -->
    <div class="section" id="m4">
      <div class="intro">
Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.</div>

      <div class="scene bg-stairs" id="scene_m4">
        <div class="scenePad frGrid5" id="m4_frags"></div>
        <div class="dyn">
          <p id="m4_text"></p>
          <p class="small">M4: só palavras. O som domina o texto até colapsar.</p>
        </div>
        <div class="controls">
          <span class="hint">M4: só palavras (plosivas/fricativas).</span>
          <button class="small ghost" id="share_m4">Partilhar este móbile</button>
        </div>
      </div>
    </div>

    <!-- Final -->
    <div class="section" id="final">
      <div class="intro" id="final_intro">
O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.</div>

      <div class="scene" id="scene_final">
        <div class="finalWrap">
          <button id="btn_generate">Gerar a minha exposição</button>
          <button class="small ghost" id="btn_share_final" style="display:none;">Partilhar resultado</button>

          <div id="final_out" style="display:none;">
            <div class="constellation" id="final_frags"></div>
            <div class="dyn">
              <p id="final_style"></p>
              <p id="final_crit"></p>
              <div class="note" id="final_call"></div>
            </div>
          </div>
        </div>

        <div class="controls">
          <span class="hint">Para ver exposições semanais: faz primeiro a tua curadoria.</span>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   PATHS (GitHub Pages)
   Page: /mobiles/entrada/index.html
   sui.json: /mobiles/sui.json
========================================================= */
const PATH_SUI_JSON = "../sui.json";
const PATH_PREFIX_FROM_ENTRADA = "../";

/* =========================================================
   HARD SEMANTIC ENGINE
========================================================= */
const AXES = [
  "corte","fluxo","densidade","rarefacao",
  "centro_instavel","contorno","ritmo","memoria",
  "tensao","presenca","emergencia","cuidado"
];

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function pick(a){ return a[Math.floor(Math.random()*a.length)]; }

const DECAY = { self: 1.00, next: 0.45, far: 0.18 };

const state = {
  tick: 0,
  axes: Object.fromEntries(AXES.map(k=>[k, 0.33])),
  phono: { surda:0.33, sonora:0.33, fricativa:0.33 },
  phonoTarget: "surda",
  suiMap: null,
  suiUrl: null,
  forceSui: (Math.random() < 0.90),

  m1: { clicks:0, slots:[12,53,71] },

  // M2 agora é ESTÁVEL: sujeito/objeto guardados e só o objeto muda no clique do verbo
  m2: {
    frontSlot: 18,
    backSlot: 66,
    swapped: false,
    verbIndex: 0,
    subjectOps: null,
    objectOps: null
  },

  m3: { slots:[], clicks:0 },
  m4: { slots:[], clicks:0, localBoost:{surda:0,sonora:0,fricativa:0} },

  final: { hash:"", slots:[], styleText:"", critText:"", shareText:"" }
};

function axisWeight(axis){ return clamp(state.axes[axis], 0.02, 0.98); }

function applyImpulse(axis, strength){
  const s = clamp(strength, -1, 1);
  state.axes[axis] = clamp(state.axes[axis] + s*0.10, 0.02, 0.98);

  if(axis==="corte"){ state.axes["fluxo"]=clamp(state.axes["fluxo"]-s*0.05,0.02,0.98); }
  if(axis==="fluxo"){ state.axes["corte"]=clamp(state.axes["corte"]-s*0.05,0.02,0.98); }
  if(axis==="densidade"){ state.axes["rarefacao"]=clamp(state.axes["rarefacao"]-s*0.05,0.02,0.98); }
  if(axis==="rarefacao"){ state.axes["densidade"]=clamp(state.axes["densidade"]-s*0.05,0.02,0.98); }

  state.tick++;
}

function applyPhonoImpulse(kind, strength){
  const s = clamp(strength, 0, 1);
  state.phono[kind] = clamp(state.phono[kind] + s*0.16, 0.02, 0.98);
  for(const k of ["surda","sonora","fricativa"]){
    if(k!==kind) state.phono[k] = clamp(state.phono[k] - s*0.07, 0.02, 0.98);
  }
  // target = max
  let best="surda", bestV=-1;
  for(const k of ["surda","sonora","fricativa"]){
    if(state.phono[k] > bestV){ bestV = state.phono[k]; best=k; }
  }
  state.phonoTarget = best;
  state.tick++;
}

/* =========================================================
   LEXICON (com "vinco" no lugar de "prega")
========================================================= */
const LEX = [
  // SUBS (0..27)
  { op:"vestigio", axis:["memoria","presenca"], surda:"traço", sonora:"marca", fricativa:"sombra" },
  { op:"sopro", axis:["fluxo","rarefacao"], surda:"pingo", sonora:"bafo", fricativa:"suspiro" },
  { op:"dobra", axis:["contorno","fluxo"], surda:"vinco", sonora:"curva", fricativa:"flexão" },
  { op:"canto", axis:["contorno","corte"], surda:"quina", sonora:"beira", fricativa:"franja" },
  { op:"margem", axis:["contorno","tensao"], surda:"limite", sonora:"borda", fricativa:"fronteira" },
  { op:"poeira", axis:["rarefacao","memoria"], surda:"pó", sonora:"bruma", fricativa:"cinza" },
  { op:"silencio", axis:["rarefacao","cuidado"], surda:"pausa", sonora:"calma", fricativa:"sussurro" },
  { op:"rastro", axis:["memoria","ritmo"], surda:"pegada", sonora:"vesta", fricativa:"resíduo" },
  { op:"fragmento", axis:["corte","memoria"], surda:"cortezinho", sonora:"bordado", fricativa:"desfiado" },
  { op:"detalhe", axis:["cuidado","presenca"], surda:"ponto", sonora:"miolo", fricativa:"nuança" },

  { op:"lembranca", axis:["memoria","presenca"], surda:"nota", sonora:"memória", fricativa:"recordação" },
  { op:"demora_n", axis:["ritmo","cuidado"], surda:"pausa", sonora:"espera", fricativa:"suspensão" },
  { op:"intervalo", axis:["corte","rarefacao"], surda:"corte", sonora:"entre", fricativa:"fresta" },
  { op:"eco", axis:["ritmo","presenca"], surda:"toque", sonora:"resposta", fricativa:"ressonância" },
  { op:"resto", axis:["memoria","tensao"], surda:"ruga", sonora:"sobra", fricativa:"resíduo" },

  { op:"plano", axis:["presenca","contorno"], surda:"linha", sonora:"base", fricativa:"superfície" },
  { op:"camada", axis:["densidade","presenca"], surda:"capa", sonora:"nível", fricativa:"espessura" },
  { op:"textura", axis:["densidade","cuidado"], surda:"trama", sonora:"tecido", fricativa:"fibra" },
  { op:"superficie", axis:["presenca","contorno"], surda:"pele", sonora:"face", fricativa:"película" },
  { op:"escala", axis:["tensao","presenca"], surda:"passo", sonora:"medida", fricativa:"proporção" },
  { op:"ritmo", axis:["ritmo","fluxo"], surda:"pulso", sonora:"cadência", fricativa:"fluência" },
  { op:"materia", axis:["densidade","presenca"], surda:"corpo", sonora:"substância", fricativa:"massa" },

  { op:"presenca", axis:["presenca","tensao"], surda:"toque", sonora:"vulto", fricativa:"sombra" },
  { op:"tensao", axis:["tensao","corte"], surda:"nó", sonora:"peso", fricativa:"pressão" },
  { op:"campo", axis:["presenca","fluxo"], surda:"plano", sonora:"território", fricativa:"ambiente" },
  { op:"emergencia", axis:["emergencia","tensao"], surda:"salto", sonora:"aparição", fricativa:"insurgência" },
  { op:"config", axis:["presenca","contorno"], surda:"forma", sonora:"estrutura", fricativa:"composição" },
  { op:"cessacao", axis:["corte","rarefacao"], surda:"corte", sonora:"encerramento", fricativa:"silenciamento" },

  // VERBS (28..49) infinitivo
  { op:"aproximar", axis:["cuidado","presenca"], surda:"chegar", sonora:"beirar", fricativa:"esfumar" },
  { op:"reparar", axis:["cuidado","centro_instavel"], surda:"notar", sonora:"observar", fricativa:"esmiuçar" },
  { op:"tocar", axis:["presenca","cuidado"], surda:"tatear", sonora:"roçar", fricativa:"aflorar" },
  { op:"escutar", axis:["cuidado","ritmo"], surda:"ouvir", sonora:"acolher", fricativa:"sintonizar" },
  { op:"demorar_v", axis:["ritmo","cuidado"], surda:"parar", sonora:"permanecer", fricativa:"alongar-se" },
  { op:"pousar", axis:["rarefacao","fluxo"], surda:"cair", sonora:"assentar", fricativa:"deslizar" },
  { op:"acompanhar", axis:["fluxo","cuidado"], surda:"seguir", sonora:"amparar", fricativa:"entrelaçar" },
  { op:"cuidar", axis:["cuidado","presenca"], surda:"zelar", sonora:"nutrir", fricativa:"suavizar" },

  { op:"recortar", axis:["corte","contorno"], surda:"cortar", sonora:"delimitar", fricativa:"fissurar" },
  { op:"deslocar", axis:["centro_instavel","fluxo"], surda:"mover", sonora:"transferir", fricativa:"deslizar" },
  { op:"sustentar", axis:["densidade","presenca"], surda:"segurar", sonora:"manter", fricativa:"suspender" },
  { op:"distribuir", axis:["ritmo","presenca"], surda:"partir", sonora:"organizar", fricativa:"espalhar" },
  { op:"sobrepor", axis:["densidade","fluxo"], surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir" },
  { op:"atravessar", axis:["fluxo","centro_instavel"], surda:"passar", sonora:"cruzar", fricativa:"permeiar" },
  { op:"insinuar", axis:["centro_instavel","presenca"], surda:"sugerir", sonora:"indicar", fricativa:"sussurrar" },

  { op:"insistir", axis:["tensao","ritmo"], surda:"bater", sonora:"persistir", fricativa:"ressoar" },
  { op:"interromper", axis:["corte","rarefacao"], surda:"cortar", sonora:"cessar", fricativa:"esvair-se" },
  { op:"fixar", axis:["contorno","densidade"], surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar" },
  { op:"suspender_v", axis:["rarefacao","tensao"], surda:"parar", sonora:"reter", fricativa:"flutuar" },
  { op:"reter", axis:["memoria","densidade"], surda:"prender", sonora:"guardar", fricativa:"conservar" },
  { op:"abandonar", axis:["rarefacao","corte"], surda:"largar", sonora:"deixar", fricativa:"dissolver" },
  { op:"transformar", axis:["emergencia","centro_instavel"], surda:"romper", sonora:"converter", fricativa:"transfigurar" },

  // ADJS (50..61)
  { op:"leve", axis:["rarefacao","fluxo"], surda:"claro", sonora:"brando", fricativa:"suave" },
  { op:"minimo", axis:["rarefacao","cuidado"], surda:"curto", sonora:"pequeno", fricativa:"sutil" },
  { op:"fragil", axis:["rarefacao","tensao"], surda:"ténue", sonora:"delicado", fricativa:"sensível" },
  { op:"tenue", axis:["rarefacao","contorno"], surda:"fino", sonora:"delgado", fricativa:"esfumado" },
  { op:"quase_adj", axis:["centro_instavel","tensao"], surda:"breve", sonora:"próximo", fricativa:"difuso" },

  { op:"opaco", axis:["densidade","corte"], surda:"denso", sonora:"turvo", fricativa:"fosco" },
  { op:"poroso", axis:["fluxo","centro_instavel"], surda:"aberto", sonora:"vazado", fricativa:"permeável" },
  { op:"irregular", axis:["centro_instavel","tensao"], surda:"torto", sonora:"oscilante", fricativa:"assimétrico" },
  { op:"difuso_adj", axis:["centro_instavel","rarefacao"], surda:"solto", sonora:"amplo", fricativa:"disperso" },

  { op:"latente", axis:["memoria","emergencia"], surda:"oculto", sonora:"presente", fricativa:"subjacente" },
  { op:"instavel", axis:["centro_instavel","tensao"], surda:"quebrado", sonora:"oscilante", fricativa:"flutuante" },
  { op:"provisorio", axis:["emergencia","fluxo"], surda:"breve", sonora:"mutável", fricativa:"transitório" },

  // ADVS (62..69)
  { op:"ainda", axis:["emergencia","tensao"], surda:"já", sonora:"agora", fricativa:"sempre" },
  { op:"quase_adv", axis:["centro_instavel","tensao"], surda:"logo", sonora:"perto", fricativa:"talvez" },
  { op:"lentamente", axis:["ritmo","cuidado"], surda:"aos poucos", sonora:"com calma", fricativa:"suavemente" },
  { op:"por_vezes", axis:["centro_instavel","ritmo"], surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente" },
  { op:"sempre", axis:["ritmo","tensao"], surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente" },
  { op:"raramente", axis:["rarefacao","memoria"], surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente" },
  { op:"talvez", axis:["centro_instavel","emergencia"], surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente" },
  { op:"agora", axis:["presenca","tensao"], surda:"já", sonora:"neste momento", fricativa:"presentemente" }
];

const byOp = Object.fromEntries(LEX.map(x=>[x.op,x]));
function axesOf(op){ return byOp[op]?.axis || ["presenca"]; }
function surfaceOf(op, kind){
  const o = byOp[op]; if(!o) return op;
  return o[kind] || o.surda || o.sonora || o.fricativa || op;
}

const OPS = {
  subst: LEX.slice(0, 28).map(x=>x.op),
  verb:  LEX.slice(28, 50).map(x=>x.op),
  adj:   LEX.slice(50, 62).map(x=>x.op),
  adv:   LEX.slice(62, 70).map(x=>x.op),
};

function weightedPick(ops){
  const weights = ops.map(op=>{
    const ax = axesOf(op);
    let w = 0.01;
    for(const a of ax) w += axisWeight(a);
    // leve bias pro alvo fonológico (sem dominar em M1-3)
    const bias = 1 + (state.phonoTarget==="surda" && ax.includes("corte") ? 0.10 : 0)
                   + (state.phonoTarget==="sonora" && (ax.includes("tensao")||ax.includes("emergencia")) ? 0.10 : 0)
                   + (state.phonoTarget==="fricativa" && (ax.includes("fluxo")||ax.includes("rarefacao")) ? 0.10 : 0);
    return w*bias;
  });
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for(let i=0;i<ops.length;i++){
    r -= weights[i];
    if(r<=0) return ops[i];
  }
  return ops[ops.length-1];
}

function chooseSurface(op, mode){
  // mode "semantic": fonologia deriva de eixos
  // mode "phono": domina pelo phonoTarget
  let kind = state.phonoTarget;

  if(mode==="semantic"){
    const s = state.axes.corte;
    const f = state.axes.fluxo + state.axes.rarefacao*0.6;
    const t = state.axes.tensao + state.axes.emergencia*0.5;
    const tot = s+f+t;
    const r = Math.random()*tot;
    if(r < s) kind="surda";
    else if(r < s+t) kind="sonora";
    else kind="fricativa";
  }

  if(mode==="phono"){
    // probabilidade forte conforme pesos atuais
    const sum = state.phono.surda + state.phono.sonora + state.phono.fricativa;
    const r = Math.random()*sum;
    if(r < state.phono.surda) kind="surda";
    else if(r < state.phono.surda + state.phono.sonora) kind="sonora";
    else kind="fricativa";
  }

  return surfaceOf(op, kind);
}

/* =========================================================
   VISUAL FAMILIES
========================================================= */
const FAMILIES = [
  { name:"F1",  range:[1,10],   axis:["fluxo","presenca"] },
  { name:"F2",  range:[11,20],  axis:["corte","tensao"] },
  { name:"F3",  range:[21,30],  axis:["centro_instavel","fluxo"] },
  { name:"F4",  range:[31,40],  axis:["ritmo","memoria"] },
  { name:"F5",  range:[41,50],  axis:["corte","centro_instavel"] },
  { name:"F6",  range:[51,60],  axis:["densidade","presenca"] },
  { name:"F7",  range:[61,70],  axis:["rarefacao","cuidado"] },
  { name:"F8",  range:[71,80],  axis:["centro_instavel","tensao"] },
  { name:"F9",  range:[81,90],  axis:["rarefacao","contorno"] },
  { name:"F10", range:[91,100], axis:["tensao","emergencia"] },
  { name:"F11", range:[101,110],axis:["contorno","presenca"] },
  { name:"F12", range:[111,120],axis:["densidade","corte"] },
];
function familyOfSlot(slot){
  for(const f of FAMILIES){
    if(slot>=f.range[0] && slot<=f.range[1]) return f;
  }
  return FAMILIES[0];
}

function selectSlotByAxes(){
  const famScores = FAMILIES.map(f=>{
    let s = 0.01;
    for(const a of f.axis) s += axisWeight(a);
    if(state.phonoTarget==="surda") s *= (f.axis.includes("corte")?1.18:0.94);
    if(state.phonoTarget==="fricativa") s *= ((f.axis.includes("fluxo")||f.axis.includes("rarefacao"))?1.18:0.94);
    if(state.phonoTarget==="sonora") s *= ((f.axis.includes("tensao")||f.axis.includes("emergencia"))?1.18:0.94);
    return s;
  });
  const sum = famScores.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  let fam = FAMILIES[0];
  for(let i=0;i<FAMILIES.length;i++){
    r -= famScores[i];
    if(r<=0){ fam = FAMILIES[i]; break; }
  }
  const [a,b] = fam.range;
  return a + Math.floor(Math.random()*(b-a+1));
}

/* =========================================================
   FRAGMENTS (SVG procedural + Sui slot 53)
========================================================= */
function makeFragmentSVG(slot){
  const f = familyOfSlot(slot);
  const a = f.axis;
  const cut = a.includes("corte") ? 1 : 0;
  const flow = a.includes("fluxo") ? 1 : 0;
  const dense = a.includes("densidade") ? 1 : 0;
  const rare = a.includes("rarefacao") ? 1 : 0;
  const center = a.includes("centro_instavel") ? 1 : 0;
  const edge = a.includes("contorno") ? 1 : 0;
  const rhythm = a.includes("ritmo") ? 1 : 0;
  const mem = a.includes("memoria") ? 1 : 0;
  const tens = a.includes("tensao") ? 1 : 0;
  const emer = a.includes("emergencia") ? 1 : 0;
  const care = a.includes("cuidado") ? 1 : 0;

  const hueBase = (slot * 17) % 360;
  const hue2 = (hueBase + 110) % 360;
  const sat = 35 + (dense*20) + (tens*12);
  const light = 86 - (dense*18) + (rare*6);

  const strokes = edge ? 3 : 2;
  const cutLines = cut ? 6 : 2;
  const blobs = dense ? 7 : 3;
  const mist = rare ? 0.22 : 0.10;

  const seed = slot * 99991;
  function pr(n){
    return (Math.sin(seed + n*12.9898) * 43758.5453) % 1;
  }

  const shapes = [];
  shapes.push(`<rect x="0" y="0" width="100" height="100" fill="hsla(${hueBase},${sat}%,${light}%,0.95)"/>`);
  shapes.push(`<rect x="0" y="0" width="100" height="100" fill="hsla(${hue2},${sat-10}%,${light-6}%,${mist})"/>`);

  for(let i=0;i<cutLines;i++){
    const x1 = (pr(i+1)*100).toFixed(2);
    const y1 = (pr(i+2)*100).toFixed(2);
    const x2 = (pr(i+3)*100).toFixed(2);
    const y2 = (pr(i+4)*100).toFixed(2);
    const w = (1.2 + pr(i+5)*2.8 + (cut?1.2:0)).toFixed(2);
    const op = (0.18 + pr(i+6)*0.22 + (cut?0.12:0) - (rare?0.05:0)).toFixed(2);
    const dash = flow ? `${(6+pr(i+7)*10).toFixed(1)} ${(4+pr(i+8)*10).toFixed(1)}` : "0 0";
    shapes.push(`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(20,10,30,${op})" stroke-width="${w}" stroke-linecap="round" stroke-dasharray="${dash}"/>`);
  }

  for(let i=0;i<blobs;i++){
    const cx = (10 + pr(50+i)*80).toFixed(2);
    const cy = (10 + pr(70+i)*80).toFixed(2);
    const r  = (6 + pr(90+i)*18 + (dense?6:0) - (rare?3:0)).toFixed(2);
    const op = (0.10 + pr(110+i)*0.18 + (dense?0.12:0) - (rare?0.05:0)).toFixed(2);
    shapes.push(`<circle cx="${cx}" cy="${cy}" r="${r}" fill="rgba(20,10,30,${op})"/>`);
  }

  if(mem){
    for(let i=0;i<24;i++){
      const x = (pr(200+i)*100).toFixed(2);
      const y = (pr(230+i)*100).toFixed(2);
      const op = (0.06 + pr(260+i)*0.12).toFixed(2);
      shapes.push(`<circle cx="${x}" cy="${y}" r="${(0.6 + pr(290+i)*1.2).toFixed(2)}" fill="rgba(20,10,30,${op})"/>`);
    }
  }

  if(emer){
    shapes.push(`<path d="M${20+pr(401)*60} ${30+pr(402)*40} L${35+pr(403)*50} ${20+pr(404)*30} L${60+pr(405)*30} ${38+pr(406)*40}"
      stroke="rgba(20,10,30,0.22)" stroke-width="3.2" fill="none" stroke-linecap="round"/>`);
  }

  if(care){
    shapes.push(`<circle cx="50" cy="50" r="38" fill="none" stroke="rgba(255,255,255,0.35)" stroke-width="5"/>`);
  }

  if(rhythm){
    shapes.push(`<rect x="6" y="6" width="88" height="88" rx="16" ry="16"
      fill="none" stroke="rgba(20,10,30,0.20)" stroke-width="${strokes}"/>`);
  } else if(edge){
    shapes.push(`<rect x="7" y="7" width="86" height="86" rx="14" ry="14"
      fill="none" stroke="rgba(20,10,30,0.18)" stroke-width="${strokes}"/>`);
  }

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 100 100">
  ${shapes.join("\n  ")}
</svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

function getFragmentURL(slot){
  if(slot === 53 && state.suiUrl) return state.suiUrl;
  return makeFragmentSVG(slot);
}

/* =========================================================
   MICRO-MOVIMENTO (campo + fragmentos)
========================================================= */
function driftScene(sceneId, amount=10){
  const el = document.getElementById(sceneId);
  if(!el) return;
  const dx = (Math.random()*2-1)*amount;
  const dy = (Math.random()*2-1)*amount;
  const dr = (Math.random()*2-1)*(amount/18);
  el.style.setProperty("--bx", dx.toFixed(1)+"px");
  el.style.setProperty("--by", dy.toFixed(1)+"px");
  el.style.setProperty("--br", dr.toFixed(2)+"deg");
}

function driftFrag(el, amount=7){
  const dx = (Math.random()*2-1)*amount;
  const dy = (Math.random()*2-1)*amount;
  const dr = (Math.random()*2-1)*(amount/30);
  el.style.setProperty("--dx", dx.toFixed(1)+"px");
  el.style.setProperty("--dy", dy.toFixed(1)+"px");
  el.style.setProperty("--dr", dr.toFixed(2)+"deg");
}

function flash(el){
  if(!el) return;
  el.classList.remove("flash");
  void el.offsetWidth;
  el.classList.add("flash");
}

/* =========================================================
   TOKEN
========================================================= */
function token(op, text, clickable=true, extraClass=""){
  const cls = ["tok", clickable?"click":"", extraClass].filter(Boolean).join(" ");
  const safe = text.replace(/</g,"&lt;").replace(/>/g,"&gt;");
  return `<span class="${cls}" data-op="${op}">${safe}</span>`;
}

/* =========================================================
   PLURALIZAÇÃO LEVE (heurística)
========================================================= */
function pluralizePT(w){
  if(!w) return w;
  const s = w.trim();
  if(s.endsWith("s") || s.endsWith("x") || s.endsWith("z")) return s;
  if(s.endsWith("ão")) return s.slice(0,-2)+"ões";
  if(s.endsWith("al")) return s.slice(0,-2)+"ais";
  if(s.endsWith("el")) return s.slice(0,-2)+"eis";
  if(s.endsWith("il")) return s.slice(0,-2)+"is";
  if(s.endsWith("ol")) return s.slice(0,-2)+"ois";
  if(s.endsWith("ul")) return s.slice(0,-2)+"uis";
  return s + "s";
}
function maybePluralSurface(op, mode){
  const surf = chooseSurface(op, mode);
  // plural leve principalmente pra SUB/ADJ
  return pluralizePT(surf);
}

/* =========================================================
   FRASES BOAS (M3/M4/Final) — sem artigos, com verbos de apoio
========================================================= */
const SUPPORT = {
  a: ["fazem","permitem","deixam","levam a","fazem tender a","fazem passar a"],
  b: ["sustentam","organizam","deslocam","inclinam","retêm","abrem"],
  c: ["até que","de tal modo que","ao ponto de","num excesso em que"]
};

function phraseM3Ops(){
  // estrutura: SUBpl ADJpl (aux) INF OBJpl, e SUBpl ADJpl (aux) INF OBJpl; ADV, SUBpl (aux) INF em SUBpl, até que SUBpl ADJpl (aux) INF.
  const S1 = weightedPick(OPS.subst), A1 = weightedPick(OPS.adj), V1 = weightedPick(OPS.verb), O1 = weightedPick(OPS.subst);
  const S2 = weightedPick(OPS.subst), A2 = weightedPick(OPS.adj), V2 = weightedPick(OPS.verb), O2 = weightedPick(OPS.subst);
  const ADV = weightedPick(OPS.adv);
  const S3 = weightedPick(OPS.subst), V3 = weightedPick(OPS.verb), P3 = weightedPick(OPS.subst);
  const S4 = weightedPick(OPS.subst), A3 = weightedPick(OPS.adj), V4 = weightedPick(OPS.verb);

  const aux1 = pick(SUPPORT.a);
  const aux2 = pick(SUPPORT.a);
  const aux3 = pick(SUPPORT.b);
  const aux4 = pick(SUPPORT.b);
  const pivot = pick(SUPPORT.c);

  return { S1,A1,V1,O1,S2,A2,V2,O2,ADV,S3,V3,P3,S4,A3,V4, aux1,aux2,aux3,aux4, pivot };
}

function renderM3Sentence(clickable=true){
  const o = phraseM3Ops();

  const parts = [
    "<span class='tok'>No</span> <span class='tok'>campo,</span>",
    token(o.S1, maybePluralSurface(o.S1,"semantic"), clickable),
    token(o.A1, maybePluralSurface(o.A1,"semantic"), clickable),
    `<span class="tok">${o.aux1}</span>`,
    token(o.V1, chooseSurface(o.V1,"semantic"), clickable),
    token(o.O1, maybePluralSurface(o.O1,"semantic"), clickable),
    "<span class='tok'>,</span>",
    "<span class='tok'>e</span>",
    token(o.S2, maybePluralSurface(o.S2,"semantic"), clickable),
    token(o.A2, maybePluralSurface(o.A2,"semantic"), clickable),
    `<span class="tok">${o.aux2}</span>`,
    token(o.V2, chooseSurface(o.V2,"semantic"), clickable),
    token(o.O2, maybePluralSurface(o.O2,"semantic"), clickable),
    "<span class='tok'>;</span>",
    token(o.ADV, chooseSurface(o.ADV,"semantic"), clickable),
    "<span class='tok'>,</span>",
    token(o.S3, maybePluralSurface(o.S3,"semantic"), clickable),
    `<span class="tok">${o.aux3}</span>`,
    "<span class='tok'>a</span>",
    token(o.V3, chooseSurface(o.V3,"semantic"), clickable),
    "<span class='tok'>em</span>",
    token(o.P3, maybePluralSurface(o.P3,"semantic"), clickable),
    "<span class='tok'>,</span>",
    `<span class="tok">${o.pivot}</span>`,
    token(o.S4, maybePluralSurface(o.S4,"semantic"), clickable),
    token(o.A3, maybePluralSurface(o.A3,"semantic"), clickable),
    `<span class="tok">${o.aux4}</span>`,
    token(o.V4, chooseSurface(o.V4,"semantic"), clickable),
    "<span class='tok'>.</span>"
  ];

  return parts.join(" ");
}

function phraseM4Ops(){
  // mais denso em tokens para o som dominar
  const S1=weightedPick(OPS.subst), A1=weightedPick(OPS.adj), V1=weightedPick(OPS.verb), O1=weightedPick(OPS.subst);
  const S2=weightedPick(OPS.subst), A2=weightedPick(OPS.adj), V2=weightedPick(OPS.verb), O2=weightedPick(OPS.subst);
  const ADV=weightedPick(OPS.adv);
  const S3=weightedPick(OPS.subst), A3=weightedPick(OPS.adj), V3=weightedPick(OPS.verb), P3=weightedPick(OPS.subst);
  const pivot=pick(SUPPORT.c);
  const aux1=pick(SUPPORT.a), aux2=pick(SUPPORT.a), aux3=pick(SUPPORT.b);

  return {S1,A1,V1,O1,S2,A2,V2,O2,ADV,S3,A3,V3,P3,pivot,aux1,aux2,aux3};
}

function renderM4Sentence(){
  const o = phraseM4Ops();
  const mode = "phono"; // aqui a fonologia realmente domina

  const parts = [
    "<span class='tok'>No</span> <span class='tok'>limite,</span>",
    token(o.S1, maybePluralSurface(o.S1,mode), true),
    token(o.A1, maybePluralSurface(o.A1,mode), true),
    `<span class="tok">${o.aux1}</span>`,
    token(o.V1, chooseSurface(o.V1,mode), true),
    token(o.O1, maybePluralSurface(o.O1,mode), true),
    "<span class='tok'>,</span>",
    "<span class='tok'>e</span>",
    token(o.S2, maybePluralSurface(o.S2,mode), true),
    token(o.A2, maybePluralSurface(o.A2,mode), true),
    `<span class="tok">${o.aux2}</span>`,
    token(o.V2, chooseSurface(o.V2,mode), true),
    token(o.O2, maybePluralSurface(o.O2,mode), true),
    "<span class='tok'>;</span>",
    token(o.ADV, chooseSurface(o.ADV,mode), true),
    "<span class='tok'>,</span>",
    token(o.S3, maybePluralSurface(o.S3,mode), true),
    token(o.A3, maybePluralSurface(o.A3,mode), true),
    `<span class="tok">${o.aux3}</span>`,
    "<span class='tok'>a</span>",
    token(o.V3, chooseSurface(o.V3,mode), true),
    "<span class='tok'>em</span>",
    token(o.P3, maybePluralSurface(o.P3,mode), true),
    "<span class='tok'>,</span>",
    `<span class="tok">${o.pivot}</span>`,
    "<span class='tok'>o</span>",
    token("resto", chooseSurface("resto",mode), true),
    "<span class='tok'>cede.</span>"
  ];

  return parts.join(" ");
}

/* =========================================================
   M1
========================================================= */
function m1_generateText(){
  const core = weightedPick(OPS.subst);
  const v = weightedPick(OPS.verb);
  const o = weightedPick(OPS.subst);
  const adv = weightedPick(OPS.adv);

  const t1 = chooseSurface(core,"semantic");
  const t2 = `${chooseSurface(v,"semantic")} ${chooseSurface(o,"semantic")}`;
  const t3 = chooseSurface(adv,"semantic");

  return `No começo, ${t1} aparece como eixo — e isso já inclina o campo. O que nasce aqui é um ${t2}, ${t3}. O resto não some: fica como toque à espera de outra tensão. Se endurece, não é ruído: é corte em formação.`;
}

function m1_tension(){
  state.m1.clicks++;
  const axes = pick([["corte","tensao"],["fluxo","cuidado"],["densidade","presenca"],["rarefacao","centro_instavel"],["emergencia","memoria"]]);
  for(const a of axes) applyImpulse(a, +1 * DECAY.self);

  // slots
  const slots = [selectSlotByAxes(), selectSlotByAxes(), selectSlotByAxes()];
  if(state.forceSui && state.suiUrl && !slots.includes(53) && Math.random()<0.45){
    slots[Math.floor(Math.random()*3)] = 53;
  }
  state.m1.slots = slots;

  // leve arrasto fonológico
  applyPhonoImpulse(pick(["surda","sonora","fricativa"]), 0.35);
}

/* =========================================================
   M2 — estrito, estável
========================================================= */
const M2_VERB_POOL = ["sustentar","recortar","aproximar","insinuar","distribuir","atravessar","fixar","transformar","interromper","acompanhar"];

function buildPhraseCluster(){
  const wantAdj = Math.random() < (0.30 + 0.35*state.axes.densidade);
  const wantAdv = Math.random() < (0.20 + 0.35*state.axes.rarefacao + 0.20*state.axes.ritmo);

  const core = weightedPick(OPS.subst);
  const ops = [core];

  if(wantAdj) ops.push(weightedPick(OPS.adj));
  if(wantAdv && Math.random()<0.6) ops.push(weightedPick(OPS.adv));

  return ops;
}

function initM2Phrases(){
  state.m2.subjectOps = buildPhraseCluster();
  state.m2.objectOps  = buildPhraseCluster();
}

function m2_swapByFragments(){
  state.m2.swapped = !state.m2.swapped;
  // swap front/back slots
  const t = state.m2.frontSlot;
  state.m2.frontSlot = state.m2.backSlot;
  state.m2.backSlot = t;

  // swap subject/object clusters (módulo1 ↔ módulo3)
  const tmp = state.m2.subjectOps;
  state.m2.subjectOps = state.m2.objectOps;
  state.m2.objectOps = tmp;

  // impulse by new front family axes
  familyOfSlot(state.m2.frontSlot).axis.forEach(a=>applyImpulse(a, 0.55));
}

function m2_cycleVerbAndObject(){
  // ONLY object changes
  state.m2.verbIndex = (state.m2.verbIndex + 1) % M2_VERB_POOL.length;

  // semantic impulse
  applyImpulse("emergencia", 0.55);
  applyImpulse("centro_instavel", 0.25);

  // new object cluster
  state.m2.objectOps = buildPhraseCluster();

  // change object fragment ONLY:
  // object is represented by backSlot when not swapped, and by frontSlot when swapped (because swap already exchanges)
  const newSlot = selectSlotByAxes();
  if(state.m2.swapped){
    state.m2.frontSlot = newSlot; // object currently in front
  }else{
    state.m2.backSlot = newSlot; // object currently in back
  }
}

function renderPhraseOps(ops, mode, clickable){
  return ops.map(op=>{
    const surf = (OPS.subst.includes(op) || OPS.adj.includes(op)) ? maybePluralSurface(op,mode) : chooseSurface(op,mode);
    return token(op, surf, clickable);
  }).join(" ");
}

function autoVerbFor(){
  const sC = state.axes.corte;
  const sF = state.axes.fluxo;
  const sD = state.axes.densidade;
  const sE = state.axes.emergencia;
  return (sC > sF && sC > sD) ? pick(["recortar","interromper"]) :
         (sF > sD && sF > sC) ? pick(["atravessar","acompanhar"]) :
         (sE > 0.55) ? "transformar" :
         pick(["sustentar","fixar","insinuar","distribuir"]);
}

/* =========================================================
   FRAGMENT DIV
========================================================= */
function fragDiv(slot, clickable, tagPrefix){
  const d = document.createElement("div");
  d.className = "frag" + (clickable ? " clickable" : "");
  d.dataset.slot = slot;

  const img = document.createElement("img");
  img.className = "img";
  img.alt = `fragmento ${slot}`;
  img.src = getFragmentURL(slot);

  const tag = document.createElement("div");
  tag.className = "fragTag";
  const fam = familyOfSlot(slot).name;
  tag.textContent = `${tagPrefix} · ${fam} · ${slot}`;

  d.appendChild(img);
  d.appendChild(tag);

  driftFrag(d, 7);
  return d;
}

/* =========================================================
   RENDERERS
========================================================= */
function m1_render(){
  driftScene("scene_m1", 12);
  const wrap = document.getElementById("m1_frags");
  wrap.innerHTML = "";
  state.m1.slots.forEach(slot=>{
    const el = fragDiv(slot, false, "m1");
    wrap.appendChild(el);
  });
  document.getElementById("m1_text").textContent = m1_generateText();
}

function m2_render(){
  driftScene("scene_m2", 10);

  const wrap = document.getElementById("m2_frags");
  wrap.innerHTML = "";

  const front = fragDiv(state.m2.frontSlot, true, "m2");
  const back  = fragDiv(state.m2.backSlot, true, "m2");

  front.addEventListener("click", ()=>{
    m2_swapByFragments();
    rerenderAll();
  });
  back.addEventListener("click", ()=>{
    m2_swapByFragments();
    rerenderAll();
  });

  wrap.appendChild(front);
  wrap.appendChild(back);

  const verbAuto = autoVerbFor();
  const verbChosen = (state.m2.verbIndex % 2 === 0) ? verbAuto : M2_VERB_POOL[state.m2.verbIndex];

  const module1HTML = renderPhraseOps(state.m2.subjectOps, "semantic", false);
  const verbHTML = `<span class="tok click verb" data-verb="1">${chooseSurface(verbChosen,"semantic")}</span>`;
  const module3HTML = renderPhraseOps(state.m2.objectOps, "semantic", false);

  const tEl = document.getElementById("m2_text");
  tEl.innerHTML = `${module1HTML} ${verbHTML} ${module3HTML}.`;

  const vTok = tEl.querySelector("[data-verb='1']");
  if(vTok){
    vTok.addEventListener("click", (e)=>{
      e.stopPropagation();
      m2_cycleVerbAndObject();
      rerenderAll();
    });
  }
}

function m3_render(){
  driftScene("scene_m3", 10);

  if(state.m3.slots.length !== 7){
    state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
    if(state.forceSui && state.suiUrl && !state.m3.slots.includes(53) && Math.random()<0.45){
      state.m3.slots[Math.floor(Math.random()*7)] = 53;
    }
  }else{
    // drift muito leve
    const driftChance = 0.10 + 0.20*state.axes.centro_instavel;
    for(let i=0;i<state.m3.slots.length;i++){
      if(Math.random()<driftChance*0.18) state.m3.slots[i] = selectSlotByAxes();
    }
  }

  const wrap = document.getElementById("m3_frags");
  wrap.innerHTML = "";
  state.m3.slots.forEach(slot=>{
    const el = fragDiv(slot, true, "m3");
    el.addEventListener("click", ()=>{
      const fam = familyOfSlot(slot);
      fam.axis.forEach(a=>applyImpulse(a, 0.90));
      state.m3.clicks++;
      if(state.m3.clicks >= 9){
        state.m3.clicks = 0;
        applyImpulse("emergencia", 1.0);
        applyImpulse("tensao", 0.7);
        state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
        flash(document.getElementById("scene_m3"));
      }
      rerenderAll();
    });
    wrap.appendChild(el);
  });

  const tEl = document.getElementById("m3_text");
  tEl.innerHTML = renderM3Sentence(true);

  // clique local por palavra: reforça eixos daquela palavra
  tEl.querySelectorAll(".tok.click[data-op]").forEach(span=>{
    span.addEventListener("click", (e)=>{
      e.stopPropagation();
      const op = span.getAttribute("data-op");
      axesOf(op).forEach(a=>applyImpulse(a, 0.95));
      state.m3.clicks++;
      if(state.m3.clicks >= 9){
        state.m3.clicks = 0;
        applyImpulse("emergencia", 1.0);
        applyImpulse("tensao", 0.7);
        state.m3.slots = Array.from({length:7}, ()=>selectSlotByAxes());
        flash(document.getElementById("scene_m3"));
      }
      rerenderAll();
    });
  });
}

function m4_render(){
  driftScene("scene_m4", 11);

  if(state.m4.slots.length !== 5){
    state.m4.slots = Array.from({length:5}, ()=>selectSlotByAxes());
    if(state.forceSui && state.suiUrl && !state.m4.slots.includes(53) && Math.random()<0.70){
      state.m4.slots[Math.floor(Math.random()*5)] = 53;
    }
  }else{
    for(let i=0;i<state.m4.slots.length;i++){
      if(Math.random()<0.06) state.m4.slots[i] = selectSlotByAxes();
    }
  }

  const wrap = document.getElementById("m4_frags");
  wrap.innerHTML = "";
  state.m4.slots.forEach(slot=>{
    const el = fragDiv(slot, false, "m4");
    wrap.appendChild(el);
  });

  const tEl = document.getElementById("m4_text");
  tEl.innerHTML = renderM4Sentence();

  tEl.querySelectorAll(".tok.click[data-op]").forEach(span=>{
    span.addEventListener("click",(e)=>{
      e.stopPropagation();
      const op = span.getAttribute("data-op");
      const ax = axesOf(op);

      // fonologia “sentida” por eixos (corte->surda, tensao/emerg->sonora, fluxo/raref->fricativa)
      let kind = state.phonoTarget;
      if(ax.includes("corte")) kind = "surda";
      else if(ax.includes("tensao") || ax.includes("emergencia")) kind = "sonora";
      else if(ax.includes("fluxo") || ax.includes("rarefacao")) kind = "fricativa";

      state.m4.localBoost[kind] = clamp(state.m4.localBoost[kind] + 1, 0, 999);
      applyPhonoImpulse(kind, 0.95);

      // arrasto visual coerente
      if(kind==="surda"){ applyImpulse("corte", 0.80); applyImpulse("contorno", 0.25); }
      if(kind==="sonora"){ applyImpulse("tensao", 0.80); applyImpulse("emergencia", 0.35); }
      if(kind==="fricativa"){ applyImpulse("fluxo", 0.80); applyImpulse("rarefacao", 0.35); }

      state.m4.clicks++;

      // catástrofe: troca regime com salto sensível
      if(state.m4.clicks >= 12){
        state.m4.clicks = 0;
        const order = ["surda","sonora","fricativa"];
        const idx = order.indexOf(state.phonoTarget);
        const next = order[(idx+1)%order.length];
        state.phonoTarget = next;
        state.phono[next] = 0.92;
        for(const k of order){ if(k!==next) state.phono[k] = 0.12; }
        state.m4.slots = Array.from({length:5}, ()=>selectSlotByAxes());
        flash(document.getElementById("scene_m4"));
      }

      rerenderAll();
    });
  });
}

/* =========================================================
   FINAL (determinístico por estado — não muda por clique no botão)
========================================================= */
function computeStateHash(){
  const a = AXES.map(k=>state.axes[k].toFixed(3)).join(",");
  const p = ["surda","sonora","fricativa"].map(k=>state.phono[k].toFixed(3)).join(",");
  const l = [
    state.m1.clicks,
    state.m2.frontSlot, state.m2.backSlot, state.m2.swapped?1:0, state.m2.verbIndex,
    state.m2.subjectOps?.join("-")||"",
    state.m2.objectOps?.join("-")||"",
    state.m3.slots.join("-"),
    state.m4.slots.join("-"),
    state.phonoTarget
  ].join("|");
  return `${a}__${p}__${l}`;
}

function seededRng(seedStr){
  let h = 2166136261 >>> 0;
  for(let i=0;i<seedStr.length;i++){
    h ^= seedStr.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return function(){
    h += 0x6D2B79F5;
    let t = Math.imul(h ^ (h >>> 15), 1 | h);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

function axisLabel(a){
  const map = {
    corte: "corte e decisão",
    fluxo: "passagens e continuidade",
    densidade: "densidade contida",
    rarefacao: "rarefação e respiro",
    centro_instavel: "centro instável",
    contorno: "contorno e margem",
    ritmo: "ritmo de insistência",
    memoria: "memória e vestígio",
    tensao: "tensão e peso",
    presenca: "presença táctil",
    emergencia: "emergência",
    cuidado: "cuidado de aproximação",
  };
  return map[a] || a;
}

function selectSlotByAxesSeeded(R){
  const famScores = FAMILIES.map(f=>{
    let s = 0.01;
    for(const a of f.axis) s += axisWeight(a);
    if(state.phonoTarget==="surda") s *= (f.axis.includes("corte")?1.18:0.94);
    if(state.phonoTarget==="fricativa") s *= ((f.axis.includes("fluxo")||f.axis.includes("rarefacao"))?1.18:0.94);
    if(state.phonoTarget==="sonora") s *= ((f.axis.includes("tensao")||f.axis.includes("emergencia"))?1.18:0.94);
    return s;
  });
  const sum = famScores.reduce((a,b)=>a+b,0);
  let r = R()*sum;
  let fam = FAMILIES[0];
  for(let i=0;i<FAMILIES.length;i++){
    r -= famScores[i];
    if(r<=0){ fam = FAMILIES[i]; break; }
  }
  const [a,b] = fam.range;
  return a + Math.floor(R()*(b-a+1));
}

function buildCritiqueText(){
  // frase boa, sem “se faz”, com suporte de infinitivo
  const mode = "phono";
  const S1=weightedPick(OPS.subst), A1=weightedPick(OPS.adj), V1=weightedPick(OPS.verb), O1=weightedPick(OPS.subst);
  const S2=weightedPick(OPS.subst), A2=weightedPick(OPS.adj), V2=weightedPick(OPS.verb), O2=weightedPick(OPS.subst);
  const ADV=weightedPick(OPS.adv);

  const domAxes = AXES.slice().sort((a,b)=>state.axes[b]-state.axes[a]).slice(0,2);
  const domA = axisLabel(domAxes[0]);
  const domB = axisLabel(domAxes[1]);

  const aux1 = pick(["fazem","permitem","deixam","forçam a","inclinam a"]);
  const aux2 = pick(["sustentam","organizam","recortam","deslocam","retêm"]);
  const aux3 = pick(["ao ponto de","de tal modo que","num excesso em que"]);

  const s1 = maybePluralSurface(S1, mode);
  const a1 = maybePluralSurface(A1, mode);
  const v1 = chooseSurface(V1, mode);
  const o1 = maybePluralSurface(O1, mode);

  const s2 = maybePluralSurface(S2, mode);
  const a2 = maybePluralSurface(A2, mode);
  const v2 = chooseSurface(V2, mode);
  const o2 = maybePluralSurface(O2, mode);

  const adv = chooseSurface(ADV, mode);

  return `A constelação organiza um regime de aparecimento — não um tema. Entre ${domA} e ${domB}, ${s1} ${a1} ${aux1} ${v1} ${o1}. ${adv}, ${s2} ${a2} ${aux2} ${v2} ${o2}, ${aux3} o resto insistir como dispositivo.`;
}

function generateFinal(){
  const hash = computeStateHash();
  if(state.final.hash === hash && state.final.slots.length===10) return;

  const R = seededRng(hash);
  const slots = [];
  for(let i=0;i<10;i++) slots.push(selectSlotByAxesSeeded(R));

  if(state.forceSui && state.suiUrl && !slots.includes(53)){
    slots[Math.floor(R()*10)] = 53;
  }

  const domAxes = AXES.slice().sort((a,b)=>state.axes[b]-state.axes[a]).slice(0,3);
  const ph = state.phonoTarget;
  const phText = (ph==="surda") ? "corte seco" : (ph==="sonora") ? "ruptura sonora" : "passagem fricativa";

  const style = `O teu estilo curatorial inclina-se para ${axisLabel(domAxes[0])}, com ${axisLabel(domAxes[1])} e um resto de ${axisLabel(domAxes[2])}. Predomina um corpo sonoro de ${phText}, que reorganiza o modo como o campo decide presença e ausência.`;

  const crit = buildCritiqueText();

  const shareText =
`Eu gerei a minha curadoria possível em MÓBILES (suiornotsui).
O que apareceu para mim não é “o todo”: é um recorte.
E o resto — o que não consegui alcançar — é o motor.

Faz a tua:
${location.href}`;

  state.final.hash = hash;
  state.final.slots = slots;
  state.final.styleText = style;
  state.final.critText = crit;
  state.final.shareText = shareText;

  renderFinal();
}

function renderFinal(){
  driftScene("scene_final", 10);

  const out = document.getElementById("final_out");
  const grid = document.getElementById("final_frags");
  grid.innerHTML = "";

  state.final.slots.forEach(slot=>{
    const el = fragDiv(slot, false, "expo");
    grid.appendChild(el);
  });

  document.getElementById("final_style").textContent = state.final.styleText;
  document.getElementById("final_crit").textContent  = state.final.critText;
  document.getElementById("final_call").textContent =
`Partilha a tua exposição — e chama outras pessoas para verem o que tu não conseguiste alcançar.
Para descobrir outras constelações expositivas, é preciso antes arriscar a tua própria curadoria.`;

  out.style.display = "block";
  document.getElementById("btn_share_final").style.display = "inline-block";
}

/* =========================================================
   SHARE (prioridade: native share com imagem+texto)
========================================================= */
async function buildCanvasFromSlots(slots, title){
  const size = 1080;
  const pad = 64;
  const canvas = document.createElement("canvas");
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext("2d");

  const g1 = ctx.createRadialGradient(size*0.25,size*0.2, 20, size*0.25,size*0.2, size*0.9);
  g1.addColorStop(0, "rgba(255,210,232,0.85)");
  g1.addColorStop(1, "rgba(251,244,248,1)");
  ctx.fillStyle = g1;
  ctx.fillRect(0,0,size,size);

  const g2 = ctx.createRadialGradient(size*0.78,size*0.25, 20, size*0.78,size*0.25, size*0.95);
  g2.addColorStop(0, "rgba(207,226,255,0.90)");
  g2.addColorStop(1, "rgba(243,247,255,0)");
  ctx.fillStyle = g2;
  ctx.fillRect(0,0,size,size);

  ctx.fillStyle = "rgba(20,10,30,0.82)";
  ctx.font = "800 44px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.fillText(title, pad, pad+30);

  ctx.font = "600 22px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas";
  ctx.fillStyle = "rgba(20,10,30,0.62)";
  ctx.fillText("suiornotsui · MÓBILES", pad, pad+64);

  const cols = 5;
  const gap = 18;
  const usableW = size - pad*2;
  const cell = Math.floor((usableW - gap*(cols-1)) / cols);
  const startY = pad + 110;

  async function loadImg(src){
    return new Promise(resolve=>{
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.onload = ()=>resolve(im);
      im.onerror = ()=>resolve(null);
      im.src = src;
    });
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  for(let i=0;i<slots.length;i++){
    const r = Math.floor(i/cols);
    const c = i%cols;
    const x = pad + c*(cell+gap);
    const y = startY + r*(cell+gap);

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    roundRect(ctx, x, y, cell, cell, 24, true, false);
    ctx.strokeStyle = "rgba(20,10,30,0.85)";
    ctx.lineWidth = 6;
    roundRect(ctx, x, y, cell, cell, 24, false, true);

    const slot = slots[i];
    const src = getFragmentURL(slot);
    const im = await loadImg(src);
    if(im){
      const iw = im.width, ih = im.height;
      const scale = Math.min((cell-18)/iw, (cell-18)/ih);
      const dw = iw*scale, dh = ih*scale;
      const dx = x + (cell - dw)/2;
      const dy = y + (cell - dh)/2;
      ctx.drawImage(im, dx, dy, dw, dh);
    }
  }

  ctx.fillStyle = "rgba(20,10,30,0.68)";
  ctx.font = "650 22px ui-sans-serif, system-ui";
  ctx.fillText("Faz a tua curadoria: " + location.href, pad, size - pad);

  return canvas;
}

async function shareSlots(slots, title, text){
  const canvas = await buildCanvasFromSlots(slots, title);
  const blob = await new Promise(res=>canvas.toBlob(res, "image/png", 0.92));
  const file = new File([blob], "mobiles.png", { type: "image/png" });

  if(navigator.canShare && navigator.canShare({ files:[file] })){
    try{
      await navigator.share({ title, text, files:[file], url: location.href });
      return;
    }catch(e){}
  }

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "mobiles.png";
  a.click();
  URL.revokeObjectURL(url);

  try{
    await navigator.clipboard.writeText(text);
    alert("Imagem descarregada. Texto copiado para a área de transferência.");
  }catch(e){
    prompt("Copia o texto para partilhar:", text);
  }
}

function bindSharing(){
  document.getElementById("share_m1").addEventListener("click", ()=>{
    shareSlots(state.m1.slots.slice(), "MÓBILES — início", `Eu tensionei o início (MÓBILE 1). E tu?\n${location.href}`);
  });
  document.getElementById("share_m2").addEventListener("click", ()=>{
    shareSlots([state.m2.frontSlot, state.m2.backSlot], "MÓBILES — posição", `Eu inverti posições (MÓBILE 2). E tu?\n${location.href}`);
  });
  document.getElementById("share_m3").addEventListener("click", ()=>{
    shareSlots(state.m3.slots.slice(), "MÓBILES — gesto", `Eu intensifiquei um gesto (MÓBILE 3). Faz a tua curadoria:\n${location.href}`);
  });
  document.getElementById("share_m4").addEventListener("click", ()=>{
    shareSlots(state.m4.slots.slice(), "MÓBILES — corpo da linguagem", `Eu fiz o som dominar (MÓBILE 4). Faz a tua curadoria:\n${location.href}`);
  });
  document.getElementById("btn_share_final").addEventListener("click", ()=>{
    shareSlots(state.final.slots.slice(), "MÓBILES — minha exposição", state.final.shareText);
  });
}

/* =========================================================
   SUI LOADER
========================================================= */
async function loadSui(){
  try{
    const res = await fetch(PATH_SUI_JSON, { cache:"no-store" });
    if(!res.ok) throw new Error("Falha ao carregar sui.json");
    const data = await res.json();
    state.suiMap = data;
    const p = data["53"] || data[53];
    if(p){
      state.suiUrl = PATH_PREFIX_FROM_ENTRADA + String(p).replace(/^\/+/,"");
    }else{
      state.suiUrl = PATH_PREFIX_FROM_ENTRADA + "assets/sui/slot_053.jpg";
    }
  }catch(e){
    state.suiUrl = PATH_PREFIX_FROM_ENTRADA + "assets/sui/slot_053.jpg";
  }
}

/* =========================================================
   GLOBAL RERENDER
========================================================= */
function rerenderAll(){
  m1_render();
  m2_render();
  m3_render();
  m4_render();

  const h = computeStateHash();
  if(state.final.hash && state.final.hash !== h){
    // invalida final se estado mudou
    document.getElementById("btn_share_final").style.display = "none";
  }
}

/* =========================================================
   INIT
========================================================= */
async function init(){
  await loadSui();

  // M1 slots
  state.m1.slots = [selectSlotByAxes(), selectSlotByAxes(), selectSlotByAxes()];
  if(state.forceSui && state.suiUrl && !state.m1.slots.includes(53) && Math.random()<0.55){
    state.m1.slots[Math.floor(Math.random()*3)] = 53;
  }

  // M2 init
  state.m2.frontSlot = selectSlotByAxes();
  state.m2.backSlot = selectSlotByAxes();
  initM2Phrases();

  if(state.forceSui && state.suiUrl && Math.random()<0.35){
    if(Math.random()<0.5) state.m2.frontSlot = 53; else state.m2.backSlot = 53;
  }

  rerenderAll();
  bindSharing();

  document.getElementById("btn_m1").addEventListener("click", ()=>{
    m1_tension();
    rerenderAll();
  });

  document.getElementById("btn_generate").addEventListener("click", ()=>{
    generateFinal();
  });
}

init();
</script>
</body>
</html>
