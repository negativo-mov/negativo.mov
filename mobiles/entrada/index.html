<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg1:#f6f1f7;
      --bg2:#eef6f6;
      --ink:#1b1b1f;
      --muted:#4b4b57;
      --card:#ffffffcc;
      --stroke:#15151a22;
      --stroke2:#15151a44;
      --accent:#ff4fd822;
      --accent2:#38ffd422;
      --shadow: 0 16px 42px rgba(15,15,20,.10);
      --r: 18px;
      --pad: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--ink);
      background:
        radial-gradient(1100px 600px at 12% 10%, #ffd7ef55 0%, transparent 60%),
        radial-gradient(900px 600px at 85% 22%, #c8fff555 0%, transparent 55%),
        radial-gradient(1200px 800px at 50% 80%, #d9d2ff44 0%, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }
    .wrap{max-width:980px;margin:0 auto;padding:28px 16px 90px;}
    .title{margin:0 0 8px;font-weight:750;letter-spacing:.2px;font-size:18px;}
    .lead{font-size:16px;line-height:1.55;color:var(--muted);margin:6px 0 18px;white-space:pre-line;}
    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:18px;
      margin:14px 0 24px;
      overflow:hidden;
    }
    .intro{margin:10px 0 14px;color:#2b2b35;line-height:1.55;white-space:pre-line;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
    button{
      appearance:none;border:1px solid var(--stroke2);background:#fff;border-radius:999px;
      padding:10px 14px;font-weight:700;cursor:pointer;box-shadow:0 8px 18px rgba(10,10,20,.08);
    }
    button:hover{transform:translateY(-1px)}
    button:active{transform:translateY(0px)}
    .canvasWrap{
      border-radius:16px;border:1px solid var(--stroke);
      background:
        radial-gradient(700px 260px at 30% 30%, var(--accent) 0%, transparent 55%),
        radial-gradient(900px 330px at 75% 50%, var(--accent2) 0%, transparent 55%),
        linear-gradient(180deg,#ffffffaa,#ffffff55);
      overflow:hidden;
    }
    canvas{width:100%;height:auto;display:block;}
    .gen{margin-top:12px;line-height:1.65;color:#1e1e25;font-size:15px;}
    .gen .tok{
      cursor:pointer;border-radius:8px;padding:0 4px;margin:0 1px;display:inline-block;
    }
    .gen .tok:hover{background:#00000008;outline:1px solid #00000010;}
    .gen .tok:active{background:#00000012;}
    .hint{font-size:13px;color:#535362;margin-top:6px;}
    .finalBox{margin-top:14px;padding:14px;border-radius:14px;border:1px dashed var(--stroke2);background:#ffffff99;}
    .small{font-size:13px;color:#4f4f5f;line-height:1.5;white-space:pre-line;}
    .copy{
      font-family:var(--mono);font-size:12px;color:#2f2f3b;background:#ffffffaa;border:1px solid var(--stroke);
      padding:10px;border-radius:12px;white-space:pre-wrap;word-break:break-word;margin-top:10px;
    }
    .pill{
      display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #15151a22;
      background:#ffffffaa;color:#2b2b35;font-weight:800;font-size:12px;
    }
    .ok{border-color:#2a7a3a33;background:#2a7a3a12;color:#2a7a3a;}
    .warn{border-color:#a36b0a33;background:#a36b0a12;color:#7a5205;}
  </style>
</head>
<body>
<div class="wrap">
  <h1 class="title">MÓBILES — operar curadoria (entrada)</h1>
  <div class="lead">Operas aqui a tua própria curadoria.
A artista é <b>suiornotsui</b>.
Mas as obras que vês nunca são todas.
O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.

Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.
Esse resto — aquilo que nunca aparece — sustenta o desejo de continuar.</div>

  <section class="card" id="m1">
    <div class="intro">Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.</div>
    <div class="canvasWrap"><canvas id="c1" width="940" height="340"></canvas></div>
    <div class="row">
      <button id="b1">Tensionar o início</button>
      <button id="sh1">Partilhar este móbile</button>
      <span id="suiPill" class="pill warn">Sui: a carregar…</span>
    </div>
    <div class="gen" id="t1"></div>
    <div class="hint">M1: só este botão. Cada clique muda o ponto de partida do campo e inclina o percurso inteiro.</div>
  </section>

  <section class="card" id="m2">
    <div class="intro">Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.</div>
    <div class="canvasWrap"><canvas id="c2" width="940" height="320"></canvas></div>
    <div class="row">
      <button id="sh2">Partilhar este móbile</button>
    </div>
    <div class="gen" id="t2"></div>
    <div class="hint">M2: clicar nos fragmentos apenas inverte frente↔fundo e módulo1↔módulo3. Clicar no verbo muda exclusivamente o objeto (módulo 3) e o fragmento correspondente.</div>
  </section>

  <section class="card" id="m3">
    <div class="intro">O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.</div>
    <div class="canvasWrap"><canvas id="c3" width="940" height="360"></canvas></div>
    <div class="row">
      <button id="sh3">Partilhar este móbile</button>
    </div>
    <div class="gen" id="t3"></div>
    <div class="hint">M3: só palavras e fragmentos. Clique local reforça o eixo específico do item clicado (com espraiamento regulado por distância).</div>
  </section>

  <section class="card" id="m4">
    <div class="intro">Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.</div>
    <div class="canvasWrap"><canvas id="c4" width="940" height="340"></canvas></div>
    <div class="row">
      <button id="sh4">Partilhar este móbile</button>
    </div>
    <div class="gen" id="t4"></div>
    <div class="hint">M4: só palavras. O texto migra para a classe sonora dominante (surda/sonora/fricativa) até colapsar para o próximo regime.</div>
  </section>

  <section class="card" id="final">
    <div class="intro">O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.
Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.
Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.
Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.
Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.</div>

    <div class="row">
      <button id="genFinal">Gerar a minha exposição</button>
      <button id="shFinal" style="display:none;">Partilhar a minha exposição</button>
    </div>

    <div class="finalBox" id="finalBox" style="display:none;">
      <div class="canvasWrap"><canvas id="cf" width="940" height="420"></canvas></div>
      <div class="gen" id="tf"></div>
      <div class="small" style="margin-top:10px;">Para ver os demais estados expositivos da semana, faz primeiro a tua curadoria (gera a tua expo).</div>
      <div class="copy" id="fallbackShare" style="display:none;"></div>
    </div>
  </section>
</div>

<script>
/* =========================
   UTIL: seeded RNG (estável)
========================= */
function xmur3(str){
  let h=1779033703 ^ str.length;
  for(let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function sfc32(a,b,c,d){
  return function(){
    a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
    let t = (a + b) | 0;
    a = b ^ (b >>> 9);
    b = (c + (c << 3)) | 0;
    c = (c << 21) | (c >>> 11);
    d = (d + 1) | 0;
    t = (t + d) | 0;
    c = (c + t) | 0;
    return (t >>> 0) / 4294967296;
  };
}
function makeRng(seedStr){
  const seed = xmur3(seedStr);
  return sfc32(seed(), seed(), seed(), seed());
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function lerp(a,b,t){ return a + (b-a)*t; }

/* =========================
   TENSIVE FAMÍLIAS (F1–F12)
   Cada família reforça eixos
========================= */
const AXES = [
  "continuity","cut","oblique","rhythm","rupture","density",
  "rarefaction","center","neutral","conflict","contour","mass",
  "phon_surd","phon_son","phon_fric"
];

const FAMILIES = [
  {id:"F1", name:"Continuidade linear", axes:{continuity:1, rhythm:.5}},
  {id:"F2", name:"Corte vertical", axes:{cut:1, contour:.7}},
  {id:"F3", name:"Deslocamento oblíquo", axes:{oblique:1, center:.6}},
  {id:"F4", name:"Ritmo repetitivo", axes:{rhythm:1, continuity:.4}},
  {id:"F5", name:"Ruptura", axes:{rupture:1, cut:.6}},
  {id:"F6", name:"Densidade", axes:{density:1, mass:.6}},
  {id:"F7", name:"Rarefação", axes:{rarefaction:1, continuity:.2}},
  {id:"F8", name:"Centro instável", axes:{center:1, conflict:.4}},
  {id:"F9", name:"Campo homogéneo", axes:{neutral:1, continuity:.3}},
  {id:"F10", name:"Direção múltipla", axes:{conflict:1, oblique:.5}},
  {id:"F11", name:"Contorno", axes:{contour:1, cut:.3}},
  {id:"F12", name:"Massa", axes:{mass:1, density:.6}}
];

// Slots 1–120 → família (10 cada, como combinaste)
function slotToFamily(slot){
  const idx = Math.floor((slot-1)/10); // 0..11
  return FAMILIES[clamp(idx,0,11)];
}

/* =========================
   LÉXICO (70 operadores) × 3
   (prega -> vinco)
========================= */
const LEX = {
  // SUBSTANTIVOS 1..28
  "vestígio": {pos:"N", variants:{surda:"traço", sonora:"marca", fricativa:"sombra"}, axes:["contour","center"]},
  "sopro": {pos:"N", variants:{surda:"pingo", sonora:"bafo", fricativa:"suspiro"}, axes:["rarefaction","continuity"]},
  "dobra": {pos:"N", variants:{surda:"vinco", sonora:"curva", fricativa:"flexão"}, axes:["oblique","continuity"]},
  "canto": {pos:"N", variants:{surda:"quina", sonora:"beira", fricativa:"franja"}, axes:["contour","cut"]},
  "margem": {pos:"N", variants:{surda:"limite", sonora:"borda", fricativa:"fronteira"}, axes:["contour","conflict"]},
  "poeira": {pos:"N", variants:{surda:"pó", sonora:"bruma", fricativa:"cinza"}, axes:["rarefaction","neutral"]},
  "silêncio": {pos:"N", variants:{surda:"pausa", sonora:"calma", fricativa:"sussurro"}, axes:["rarefaction","continuity"]},
  "rastro": {pos:"N", variants:{surda:"pegada", sonora:"vesta", fricativa:"resíduo"}, axes:["rhythm","center"]},
  "fragmento": {pos:"N", variants:{surda:"cortezinho", sonora:"bordado", fricativa:"desfiado"}, axes:["rupture","cut","contour"]},
  "detalhe": {pos:"N", variants:{surda:"ponto", sonora:"miolo", fricativa:"nuança"}, axes:["center","continuity"]},

  "lembrança": {pos:"N", variants:{surda:"nota", sonora:"memória", fricativa:"recordação"}, axes:["rhythm","center"]},
  "demora": {pos:"N", variants:{surda:"pausa", sonora:"espera", fricativa:"suspensão"}, axes:["continuity","rarefaction"]},
  "intervalo": {pos:"N", variants:{surda:"corte", sonora:"entre", fricativa:"fresta"}, axes:["cut","conflict"]},
  "eco": {pos:"N", variants:{surda:"toque", sonora:"resposta", fricativa:"ressonância"}, axes:["rhythm","continuity"]},
  "resto": {pos:"N", variants:{surda:"ruga", sonora:"sobra", fricativa:"resíduo"}, axes:["rupture","center"]},

  "plano": {pos:"N", variants:{surda:"linha", sonora:"base", fricativa:"superfície"}, axes:["neutral","continuity"]},
  "camada": {pos:"N", variants:{surda:"capa", sonora:"nível", fricativa:"espessura"}, axes:["density","mass"]},
  "textura": {pos:"N", variants:{surda:"trama", sonora:"tecido", fricativa:"fibra"}, axes:["rhythm","density"]},
  "superfície": {pos:"N", variants:{surda:"pele", sonora:"face", fricativa:"película"}, axes:["contour","neutral"]},
  "escala": {pos:"N", variants:{surda:"passo", sonora:"medida", fricativa:"proporção"}, axes:["neutral","conflict"]},
  "ritmo": {pos:"N", variants:{surda:"pulso", sonora:"cadência", fricativa:"fluência"}, axes:["rhythm","continuity"]},
  "matéria": {pos:"N", variants:{surda:"corpo", sonora:"substância", fricativa:"massa"}, axes:["density","mass"]},

  "presença": {pos:"N", variants:{surda:"toque", sonora:"vulto", fricativa:"sombra"}, axes:["center","contour"]},
  "tensão": {pos:"N", variants:{surda:"nó", sonora:"peso", fricativa:"pressão"}, axes:["conflict","mass"]},
  "campo": {pos:"N", variants:{surda:"plano", sonora:"território", fricativa:"ambiente"}, axes:["neutral","continuity"]},
  "emergência": {pos:"N", variants:{surda:"salto", sonora:"aparição", fricativa:"insurgência"}, axes:["rupture","conflict"]},
  "configuração": {pos:"N", variants:{surda:"forma", sonora:"estrutura", fricativa:"composição"}, axes:["neutral","density"]},
  "cessação": {pos:"N", variants:{surda:"corte", sonora:"encerramento", fricativa:"silenciamento"}, axes:["cut","rarefaction","rupture"]},

  // VERBOS 29..50
  "aproximar": {pos:"V", variants:{surda:"chegar", sonora:"beirar", fricativa:"esfumar"}, axes:["continuity","center"]},
  "reparar": {pos:"V", variants:{surda:"notar", sonora:"observar", fricativa:"esmiuçar"}, axes:["center","contour"]},
  "tocar": {pos:"V", variants:{surda:"tatear", sonora:"roçar", fricativa:"aflorar"}, axes:["contour","continuity"]},
  "escutar": {pos:"V", variants:{surda:"ouvir", sonora:"acolher", fricativa:"sintonizar"}, axes:["rarefaction","continuity"]},
  "demorar_v": {pos:"V", base:"demorar", variants:{surda:"parar", sonora:"permanecer", fricativa:"alongar-se"}, axes:["continuity","rarefaction"]},
  "pousar": {pos:"V", variants:{surda:"cair", sonora:"assentar", fricativa:"deslizar"}, axes:["mass","continuity"]},
  "acompanhar": {pos:"V", variants:{surda:"seguir", sonora:"amparar", fricativa:"entrelaçar"}, axes:["rhythm","continuity"]},
  "cuidar": {pos:"V", variants:{surda:"zelar", sonora:"nutrir", fricativa:"suavizar"}, axes:["continuity","rarefaction"]},

  "recortar": {pos:"V", variants:{surda:"cortar", sonora:"delimitar", fricativa:"fissurar"}, axes:["cut","contour"]},
  "deslocar": {pos:"V", variants:{surda:"mover", sonora:"transferir", fricativa:"deslizar"}, axes:["oblique","center"]},
  "sustentar": {pos:"V", variants:{surda:"segurar", sonora:"manter", fricativa:"suspender"}, axes:["continuity","mass"]},
  "distribuir": {pos:"V", variants:{surda:"partir", sonora:"organizar", fricativa:"espalhar"}, axes:["neutral","rhythm"]},
  "sobrepor": {pos:"V", variants:{surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir"}, axes:["density","mass"]},
  "atravessar": {pos:"V", variants:{surda:"passar", sonora:"cruzar", fricativa:"permeiar"}, axes:["oblique","conflict"]},
  "insinuar": {pos:"V", variants:{surda:"sugerir", sonora:"indicar", fricativa:"sussurrar"}, axes:["center","rarefaction"]},

  "insistir": {pos:"V", variants:{surda:"bater", sonora:"persistir", fricativa:"ressoar"}, axes:["rhythm","conflict"]},
  "interromper": {pos:"V", variants:{surda:"cortar", sonora:"cessar", fricativa:"esvair-se"}, axes:["cut","rupture"]},
  "fixar": {pos:"V", variants:{surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar"}, axes:["contour","mass"]},
  "suspender": {pos:"V", variants:{surda:"parar", sonora:"reter", fricativa:"flutuar"}, axes:["rarefaction","center"]},
  "reter": {pos:"V", variants:{surda:"prender", sonora:"guardar", fricativa:"conservar"}, axes:["mass","continuity"]},
  "abandonar": {pos:"V", variants:{surda:"largar", sonora:"deixar", fricativa:"dissolver"}, axes:["rupture","rarefaction"]},
  "transformar": {pos:"V", variants:{surda:"romper", sonora:"converter", fricativa:"transfigurar"}, axes:["rupture","oblique"]},

  // ADJETIVOS 51..62
  "leve": {pos:"ADJ", variants:{surda:"claro", sonora:"brando", fricativa:"suave"}, axes:["rarefaction","continuity"]},
  "mínimo": {pos:"ADJ", variants:{surda:"curto", sonora:"pequeno", fricativa:"sutil"}, axes:["rarefaction","center"]},
  "frágil": {pos:"ADJ", variants:{surda:"ténue", sonora:"delicado", fricativa:"sensível"}, axes:["rarefaction","center"]},
  "tênue": {pos:"ADJ", variants:{surda:"fino", sonora:"delgado", fricativa:"esfumado"}, axes:["rarefaction","continuity"]},
  "quase_adj": {pos:"ADJ", base:"quase", variants:{surda:"breve", sonora:"próximo", fricativa:"difuso"}, axes:["center","rarefaction"]},
  "opaco": {pos:"ADJ", variants:{surda:"denso", sonora:"turvo", fricativa:"fosco"}, axes:["density","neutral"]},
  "poroso": {pos:"ADJ", variants:{surda:"aberto", sonora:"vazado", fricativa:"permeável"}, axes:["continuity","rarefaction"]},
  "irregular": {pos:"ADJ", variants:{surda:"torto", sonora:"instável", fricativa:"assimétrico"}, axes:["center","conflict"]},
  "difuso": {pos:"ADJ", variants:{surda:"solto", sonora:"amplo", fricativa:"disperso"}, axes:["center","rarefaction"]},
  "latente": {pos:"ADJ", variants:{surda:"oculto", sonora:"presente", fricativa:"subjacente"}, axes:["center","neutral"]},
  "instável": {pos:"ADJ", variants:{surda:"quebrado", sonora:"oscilante", fricativa:"flutuante"}, axes:["conflict","center"]},
  "provisório": {pos:"ADJ", variants:{surda:"breve", sonora:"mutável", fricativa:"transitório"}, axes:["rarefaction","oblique"]},

  // ADVÉRBIOS 63..70
  "ainda": {pos:"ADV", variants:{surda:"já", sonora:"agora", fricativa:"sempre"}, axes:["continuity","rhythm"]},
  "quase_adv": {pos:"ADV", base:"quase", variants:{surda:"logo", sonora:"perto", fricativa:"talvez"}, axes:["center","rarefaction"]},
  "lentamente": {pos:"ADV", variants:{surda:"aos poucos", sonora:"com calma", fricativa:"suavemente"}, axes:["continuity","rarefaction"]},
  "por vezes": {pos:"ADV", variants:{surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente"}, axes:["rhythm","neutral"]},
  "sempre": {pos:"ADV", variants:{surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente"}, axes:["continuity","rhythm"]},
  "raramente": {pos:"ADV", variants:{surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente"}, axes:["rarefaction","neutral"]},
  "talvez": {pos:"ADV", variants:{surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente"}, axes:["center","neutral"]},
  "agora": {pos:"ADV", variants:{surda:"já", sonora:"neste momento", fricativa:"presentemente"}, axes:["continuity","center"]}
};

const OPS = Object.keys(LEX);

/* =========================
   FONOLOGIA: classificar
========================= */
function phonClass(word){
  // regras simples: surda = p,t,k,f,s,ch,ç / sonora = b,d,g,v,z,j,m,n,l,r / fricativa = f,s,sh,ç,v,z,j (prioriza fricativa)
  const w = word.toLowerCase();
  if(/[fsçxjzv]/.test(w)) return "fricativa";
  if(/[bdgmnlr]/.test(w)) return "sonora";
  return "surda";
}

/* =========================
   Estado global hard
========================= */
const state = {
  seed: (Math.random().toString(36).slice(2) + "-" + Date.now()),
  vec: Object.fromEntries(AXES.map(a=>[a,0])),
  // para travar escolhas determinísticas por estado
  version: 0,
  // M2
  m2FrontSlot: 18,
  m2BackSlot: 76,
  m2Swap: false,
  m2ObjBankIdx: 0,
  // M3/M4 colapsos
  m3Clicks: 0,
  m4Clicks: 0,
  // Sui
  suiImg: null,
  suiReady: false,
  suiPath: null
};

function rngFor(tag){
  return makeRng(state.seed + "::" + state.version + "::" + tag);
}

/* =========================
   Espraiamento regulado
   (alto no móbile, médio no seguinte, baixo nos demais)
========================= */
function applyImpulse(sourceMobile, axes, mag){
  // pesos por distância (1->4)
  const w = { self:1.0, next:0.45, far:0.18 };
  // aplica no vetor global com passo máximo (anti-caos)
  for(const ax of Object.keys(axes)){
    const delta = axes[ax] * mag;
    state.vec[ax] = clamp(state.vec[ax] + delta, -3, 3);
  }
  // também reforça classe fonológica quando eixo fon_*
  // (já é parte do vetor, mas garantimos que fica sensível)
}

function axisBundleFromAxesList(list){
  const out = {};
  for(const a of list){ out[a] = (out[a]||0) + 1; }
  return out;
}

function blendFamilyIntoVec(fam, strength){
  applyImpulse("FAM", fam.axes, strength);
}

/* =========================
   Seleção de realização (surda/sonora/fricativa)
   baseada no vetor fonológico dominante
========================= */
function currentPhonMode(){
  const s = state.vec.phon_surd, so = state.vec.phon_son, fr = state.vec.phon_fric;
  if(fr >= so && fr >= s) return "fricativa";
  if(so >= fr && so >= s) return "sonora";
  return "surda";
}

/* =========================
   Seleção de slots por eixos
========================= */
function pickFamilyByVec(rng){
  // calcula score por família a partir do vetor
  const scores = FAMILIES.map(f=>{
    let sc = 0.01;
    for(const k in f.axes){
      sc += (state.vec[k] || 0) * f.axes[k];
    }
    // pequena aleatoriedade estável
    sc += (rng()*0.22);
    return Math.max(0.001, sc);
  });
  const sum = scores.reduce((a,b)=>a+b,0);
  let t = rng()*sum;
  for(let i=0;i<scores.length;i++){
    t -= scores[i];
    if(t<=0) return FAMILIES[i];
  }
  return FAMILIES[0];
}

function pickSlotFromFamily(fam, rng){
  const base = (FAMILIES.indexOf(fam))*10 + 1;
  const slot = base + Math.floor(rng()*10); // 1..10 dentro
  return slot;
}

/* =========================
   Sui: carregar sui.json e imagem
========================= */
async function loadSui(){
  const pill = document.getElementById("suiPill");
  try{
    // index está em mobiles/entrada/ => sui.json está em ../sui.json
    const res = await fetch("../sui.json", {cache:"no-store"});
    if(!res.ok) throw new Error("fetch sui.json falhou: " + res.status);
    const j = await res.json();
    // formato fixo: { "53": "assets/sui/slot_053.jpg" }
    const rel = j["53"];
    if(!rel) throw new Error("sui.json não tem chave 53");
    state.suiPath = "../" + rel.replace(/^\.?\//,""); // vira ../assets/sui/slot_053.jpg
    const img = new Image();
    img.crossOrigin = "anonymous";
    await new Promise((ok, bad)=>{
      img.onload = ok;
      img.onerror = ()=>bad(new Error("imagem Sui não carregou"));
      img.src = state.suiPath + "?v=" + Date.now();
    });
    state.suiImg = img;
    state.suiReady = true;
    pill.textContent = "Sui: ok";
    pill.classList.remove("warn");
    pill.classList.add("ok");
  }catch(e){
    // fallback: tenta caminho conhecido
    try{
      state.suiPath = "../assets/sui/slot_053.jpg";
      const img = new Image();
      img.crossOrigin = "anonymous";
      await new Promise((ok,bad)=>{
        img.onload = ok;
        img.onerror = ()=>bad(new Error("fallback falhou"));
        img.src = state.suiPath + "?v=" + Date.now();
      });
      state.suiImg = img;
      state.suiReady = true;
      pill.textContent = "Sui: ok";
      pill.classList.remove("warn");
      pill.classList.add("ok");
    }catch(_){
      pill.textContent = "Sui: fallback";
      pill.classList.add("warn");
      state.suiReady = false;
    }
  }
}

/* =========================
   DESENHO: fragmentos (canvas)
   - mantém aspect ratio (contain)
   - frames bem demarcados
   - cenários visíveis: berço, montanhas, labirinto, escadas
========================= */
function drawBackground(ctx, w,h, scene){
  ctx.clearRect(0,0,w,h);

  // base pastel morbido
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0, "rgba(255,210,235,0.30)");
  g.addColorStop(0.5,"rgba(200,255,245,0.22)");
  g.addColorStop(1, "rgba(210,200,255,0.20)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // cena
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(20,20,30,0.10)";
  ctx.lineWidth = 2;

  if(scene==="crib"){
    // arcos do móbile
    ctx.beginPath();
    ctx.arc(w*0.5, h*0.05, w*0.28, Math.PI*0.95, Math.PI*0.05, true);
    ctx.stroke();
    // cordas
    for(const x of [0.35,0.5,0.65]){
      ctx.beginPath();
      ctx.moveTo(w*x, h*0.08);
      ctx.lineTo(w*x, h*0.16);
      ctx.stroke();
    }
  } else if(scene==="mountain"){
    // montanhas
    ctx.fillStyle = "rgba(160,160,180,0.12)";
    ctx.beginPath();
    ctx.moveTo(0,h*0.62);
    ctx.lineTo(w*0.22,h*0.38);
    ctx.lineTo(w*0.45,h*0.60);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(w*0.35,h*0.66);
    ctx.lineTo(w*0.58,h*0.34);
    ctx.lineTo(w*0.82,h*0.66);
    ctx.closePath();
    ctx.fill();

    // chão
    ctx.fillStyle="rgba(180,220,200,0.12)";
    ctx.fillRect(0,h*0.66,w,h*0.34);

    // animais mínimos
    ctx.strokeStyle="rgba(20,20,30,0.16)";
    ctx.lineWidth=2;
    const cows = [
      [w*0.20,h*0.74],[w*0.28,h*0.76],[w*0.34,h*0.73],
      [w*0.56,h*0.75],[w*0.62,h*0.77]
    ];
    for(const [cx,cy] of cows){
      ctx.beginPath();
      ctx.moveTo(cx-10,cy);
      ctx.lineTo(cx+10,cy);
      ctx.moveTo(cx-6,cy);
      ctx.lineTo(cx-10,cy+6);
      ctx.moveTo(cx+6,cy);
      ctx.lineTo(cx+10,cy+6);
      ctx.stroke();
    }
  } else if(scene==="maze"){
    // labirinto
    ctx.strokeStyle="rgba(20,20,30,0.10)";
    ctx.lineWidth=3;
    const step = 28;
    for(let y=30;y<h-30;y+=step){
      for(let x=30;x<w-30;x+=step){
        if(((x/step + y/step)|0)%3===0){
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+step,y); ctx.stroke();
        }else if(((x/step + y/step)|0)%3===1){
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y+step); ctx.stroke();
        }else{
          ctx.beginPath(); ctx.rect(x,y,step,step); ctx.stroke();
        }
      }
    }
  } else if(scene==="stairs"){
    // escadas "Escher"
    ctx.strokeStyle="rgba(20,20,30,0.12)";
    ctx.lineWidth=2;
    const blocks = 10;
    for(let i=0;i<blocks;i++){
      const x = w*0.08 + i*(w*0.08);
      const y = h*0.62 - i*(h*0.04);
      ctx.strokeRect(x,y,w*0.18,h*0.18);
      ctx.strokeRect(x+w*0.08,y-h*0.08,w*0.18,h*0.18);
    }
  }
  ctx.restore();
}

function drawFrame(ctx, x,y, ww,hh, mood){
  // frame bem demarcado, com leve neon mórbido
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.15)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 10;

  ctx.fillStyle = "rgba(255,255,255,0.62)";
  ctx.fillRect(x,y,ww,hh);

  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(20,20,30,0.28)";
  ctx.lineWidth = 2.2;
  ctx.strokeRect(x,y,ww,hh);

  // inner edge
  ctx.strokeStyle = "rgba(255,80,210,0.10)";
  ctx.strokeRect(x+3,y+3,ww-6,hh-6);

  // small label line (gramática visual)
  ctx.strokeStyle = "rgba(20,20,30,0.08)";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(x+10,y+hh-14);
  ctx.lineTo(x+ww-10,y+hh-14);
  ctx.stroke();

  ctx.restore();
}

function drawNonSuiFragment(ctx, x,y, ww,hh, slot){
  // desenha "fragmento" segundo família (tensivo)
  const fam = slotToFamily(slot);
  ctx.save();
  ctx.translate(x,y);

  // base
  ctx.fillStyle = "rgba(240,240,255,0.35)";
  ctx.fillRect(0,0,ww,hh);

  // parâmetros por família (visível)
  let cut = fam.axes.cut ? fam.axes.cut : 0;
  let dens = fam.axes.density ? fam.axes.density : 0;
  let rar = fam.axes.rarefaction ? fam.axes.rarefaction : 0;
  let cen = fam.axes.center ? fam.axes.center : 0;
  let rhy = fam.axes.rhythm ? fam.axes.rhythm : 0;
  let ob  = fam.axes.oblique ? fam.axes.oblique : 0;
  let con = fam.axes.contour ? fam.axes.contour : 0;
  let mas = fam.axes.mass ? fam.axes.mass : 0;
  let rup = fam.axes.rupture ? fam.axes.rupture : 0;

  // background wash per fam
  const wash = ctx.createLinearGradient(0,0,ww,hh);
  wash.addColorStop(0, `rgba(${Math.floor(220-30*mas)},${Math.floor(240-30*dens)},${Math.floor(235-40*cut)},0.22)`);
  wash.addColorStop(1, `rgba(${Math.floor(235-40*rup)},${Math.floor(220-30*con)},${Math.floor(250-40*ob)},0.20)`);
  ctx.fillStyle = wash;
  ctx.fillRect(0,0,ww,hh);

  // shapes density
  const n = Math.floor(6 + dens*10 + mas*6 + rhy*6);
  ctx.globalAlpha = 0.55 - rar*0.25;
  for(let i=0;i<n;i++){
    const rx = (i*37 + slot*13) % Math.floor(ww-40) + 10;
    const ry = (i*53 + slot*17) % Math.floor(hh-40) + 10;
    const rw = 18 + ((i*19 + slot*7) % 58);
    const rh = 12 + ((i*23 + slot*11)% 48);
    ctx.fillStyle = `rgba(${180+((i*9)%60)},${170+((i*7)%70)},${200+((i*11)%50)},0.18)`;
    if(ob>0.2){
      ctx.save();
      ctx.translate(rx,ry);
      ctx.rotate(((-0.25+((i%5)/10))*ob));
      ctx.fillRect(0,0,rw,rh);
      ctx.restore();
    }else{
      ctx.fillRect(rx,ry,rw,rh);
    }
    if(cut>0.5){
      ctx.clearRect(rx+rw*0.55, ry, Math.max(2,rw*0.12), rh);
    }
    if(rup>0.5 && i%3===0){
      ctx.clearRect(rx, ry+rh*0.35, rw, Math.max(2,rh*0.12));
    }
  }

  // contour line (if contour)
  if(con>0.4){
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = "rgba(20,20,30,0.22)";
    ctx.lineWidth = 3;
    ctx.strokeRect(10,10,ww-20,hh-20);
  }

  // center instability (offset focal)
  if(cen>0.4){
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,90,210,0.18)";
    ctx.beginPath();
    ctx.ellipse(ww*0.55, hh*0.45, ww*0.18, hh*0.12, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // small slot id (hidden-ish)
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "rgba(20,20,30,0.55)";
  ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
  ctx.fillText(String(slot).padStart(3,"0"), ww-44, hh-14);

  ctx.restore();
}

function drawSui(ctx, x,y, ww,hh){
  if(!state.suiReady || !state.suiImg) return false;
  const img = state.suiImg;
  // contain
  const r = Math.min(ww/img.width, hh/img.height);
  const dw = img.width * r;
  const dh = img.height * r;
  const dx = x + (ww-dw)/2;
  const dy = y + (hh-dh)/2;
  ctx.drawImage(img, dx,dy,dw,dh);
  return true;
}

/* =========================
   Texto: escolher realizações
========================= */
function realize(opKey, mode){
  const o = LEX[opKey];
  if(!o) return opKey;
  const m = mode || currentPhonMode();
  return (o.variants && o.variants[m]) ? o.variants[m] : (o.variants ? Object.values(o.variants)[0] : opKey);
}

function pickOpsByPos(pos){
  return OPS.filter(k => LEX[k].pos === pos);
}

const N_OPS = pickOpsByPos("N");
const V_OPS = pickOpsByPos("V");
const ADJ_OPS = pickOpsByPos("ADJ");
const ADV_OPS = pickOpsByPos("ADV");

/* =========================
   Render tokenizado
========================= */
function renderTokens(el, tokens, clickHandler){
  el.innerHTML = "";
  for(const t of tokens){
    if(t.type==="text"){
      el.appendChild(document.createTextNode(t.v));
    }else if(t.type==="tok"){
      const sp = document.createElement("span");
      sp.className = "tok";
      sp.textContent = t.v;
      sp.dataset.op = t.op;
      sp.dataset.axes = (t.axes||[]).join(",");
      sp.addEventListener("click", (ev)=>clickHandler(ev, t));
      el.appendChild(sp);
    }
  }
}

/* =========================
   Gerar frases curatorias (M1/M3/M4)
   (com infinitivo “substantivado”: é um VERB SUB)
========================= */
function m1Text(){
  const rng = rngFor("m1Text");
  const mode = currentPhonMode();

  const n1 = N_OPS[Math.floor(rng()*N_OPS.length)];
  const v1 = V_OPS[Math.floor(rng()*V_OPS.length)];
  const n2 = N_OPS[Math.floor(rng()*N_OPS.length)];
  const adv = ADV_OPS[Math.floor(rng()*ADV_OPS.length)];

  const line = `No começo, ${realize(n1,mode)} aparece como eixo — e isso já inclina o campo. ` +
               `O que nasce aqui é um ${realize(v1,mode)} ${realize(n2,mode)}, ${realize(adv,mode)}. ` +
               `O resto não some: fica como ${realize("eco",mode)} à espera de outra tensão. ` +
               `Se o campo endurece, não é ruído: é ${realize("cessação",mode)} em formação.`;

  // tokeniza palavras que são realizações (mapear por op)
  // aqui fazemos tokens só nos operadores principais, para clique local não virar “parágrafo inteiro”
  const tokens = [];
  function pushText(s){ tokens.push({type:"text", v:s}); }
  function pushTok(op, txt){ tokens.push({type:"tok", op, v:txt, axes:LEX[op].axes}); }

  pushText("No começo, ");
  pushTok(n1, realize(n1,mode));
  pushText(" aparece como eixo — e isso já inclina o campo. O que nasce aqui é um ");
  pushTok(v1, realize(v1,mode));
  pushText(" ");
  pushTok(n2, realize(n2,mode));
  pushText(", ");
  pushTok(adv, realize(adv,mode));
  pushText(". O resto não some: fica como ");
  pushTok("eco", realize("eco",mode));
  pushText(" à espera de outra tensão. Se o campo endurece, não é ruído: é ");
  pushTok("cessação", realize("cessação",mode));
  pushText(" em formação.");

  return tokens;
}

// Template poético-curatorial para M3/M4 (substantivação do infinitivo)
function poeticCuratorialTokens(tag){
  const rng = rngFor(tag);
  const mode = currentPhonMode();

  // pick helpers
  const nA = N_OPS[Math.floor(rng()*N_OPS.length)];
  const nB = N_OPS[Math.floor(rng()*N_OPS.length)];
  const nC = N_OPS[Math.floor(rng()*N_OPS.length)];
  const nD = N_OPS[Math.floor(rng()*N_OPS.length)];
  const adjA = ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)];
  const adjB = ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)];
  const vA = V_OPS[Math.floor(rng()*V_OPS.length)];
  const vB = V_OPS[Math.floor(rng()*V_OPS.length)];
  const advA = ADV_OPS[Math.floor(rng()*ADV_OPS.length)];

  // Migração fonológica no M4: quanto mais domina um modo, mais palavras “forçadas” para ele.
  const dom = dominantPhonStrength(); // 0..1
  const forcedMode = (tag==="m4") ? dominantPhonMode() : mode;
  function maybeForce(op){
    if(tag!=="m4") return mode;
    // força mais conforme dom
    return (rng() < dom) ? forcedMode : mode;
  }

  const tokens = [];
  const P = (s)=>tokens.push({type:"text", v:s});
  const T = (op)=>tokens.push({type:"tok", op, v:realize(op, maybeForce(op)), axes:LEX[op].axes});

  // “No campo, a {SUB} {ADJ} é um {VERB} {SUB}, e a {SUB} {ADJ} é um {VERB} {SUB}; {ADV}, a {SUB} é um {VERB} na {SUB}, até que a {SUB} {ADJ} se {VERB}.”
  P("No campo, a ");
  T(nA); P(" "); T(adjA);
  P(" é um "); T(vA); P(" "); T(nB);
  P(", e a "); T(nC); P(" "); T(adjB);
  P(" é um "); T(vB); P(" "); T(nD);
  P("; "); T(advA);
  P(", a "); T("presença");
  P(" é um "); T("insinuar");
  P(" na "); T("superfície");
  P(", até que a "); T("configuração");
  P(" "); T("instável");
  P(" se "); T("transformar");
  P(".");

  return tokens;
}

/* =========================
   Fonologia: dominância e colapso (M4)
========================= */
function dominantPhonMode(){
  const s = state.vec.phon_surd, so = state.vec.phon_son, fr = state.vec.phon_fric;
  if(fr >= so && fr >= s) return "fricativa";
  if(so >= fr && so >= s) return "sonora";
  return "surda";
}
function dominantPhonStrength(){
  // normaliza 0..1 a partir da distância entre dominante e média
  const arr = [state.vec.phon_surd, state.vec.phon_son, state.vec.phon_fric];
  const max = Math.max(...arr);
  const avg = (arr[0]+arr[1]+arr[2])/3;
  return clamp((max-avg)/2.0, 0, 1);
}
function bumpPhon(mode, amount){
  if(mode==="surda") state.vec.phon_surd = clamp(state.vec.phon_surd + amount, -3, 3);
  if(mode==="sonora") state.vec.phon_son = clamp(state.vec.phon_son + amount, -3, 3);
  if(mode==="fricativa") state.vec.phon_fric = clamp(state.vec.phon_fric + amount, -3, 3);
}
function maybePhonCollapse(){
  // quando dominância fica alta, “colapsa” para o próximo regime (cycle)
  const dom = dominantPhonStrength();
  if(dom < 0.92) return false;
  const current = dominantPhonMode();
  // ciclo: surda->sonora->fricativa->surda
  let next = "sonora";
  if(current==="sonora") next = "fricativa";
  if(current==="fricativa") next = "surda";

  // reset suave e empurra para o próximo
  state.vec.phon_surd *= 0.2;
  state.vec.phon_son  *= 0.2;
  state.vec.phon_fric *= 0.2;
  bumpPhon(next, 1.4);
  return true;
}

/* =========================
   M2: módulos restritos (S-V-O)
========================= */
function m2Build(){
  const rng = rngFor("m2");
  const mode = currentPhonMode();

  // sujeito e objeto são N (+ opcional ADJ/ADV dependendo de rarefação/centro)
  const subjCore = N_OPS[Math.floor(rng()*N_OPS.length)];
  const objBank = [
    // bancos de objeto “fora da dupla binária” via clique no verbo
    () => N_OPS[Math.floor(rng()*N_OPS.length)],
    () => "emergência",
    () => "configuração",
    () => "resto",
    () => "textura",
    () => "cessação",
    () => "tensão"
  ];
  const objCore = objBank[state.m2ObjBankIdx % objBank.length]();

  const allowAdj = (state.vec.center + state.vec.rarefaction) > 0.4;
  const allowAdv = (state.vec.continuity + state.vec.rhythm) > 0.6;

  const subjAdj = allowAdj ? ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)] : null;
  const objAdj  = allowAdj ? ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)] : null;
  const subjAdv = allowAdv ? ADV_OPS[Math.floor(rng()*ADV_OPS.length)] : null;
  const objAdv  = allowAdv ? ADV_OPS[Math.floor(rng()*ADV_OPS.length)] : null;

  // verbo “adequado” depende de swap (posição)
  // quando sujeito e objeto trocam, verbo deve mudar (mas só isso)
  function pickVerbFor(coreA, coreB){
    // heurística: se há mais cut/rupture => recortar/interromper; se continuity => sustentar/acompanhar; se center => insinuar/reparar
    const a = state.vec;
    const cand = [];
    if(a.cut + a.rupture > 0.8) cand.push("recortar","interromper","fixar");
    if(a.continuity + a.rhythm > 0.8) cand.push("sustentar","acompanhar","distribuir");
    if(a.center + a.rarefaction > 0.8) cand.push("insinuar","reparar","escutar");
    cand.push("tocar","deslocar","atravessar");
    const v = cand[Math.floor(rng()*cand.length)];
    return v;
  }

  let S = {core:subjCore, adj:subjAdj, adv:subjAdv};
  let O = {core:objCore,  adj:objAdj,  adv:objAdv};

  // swap invertendo módulo 1 e 3
  if(state.m2Swap){
    const tmp = S; S = O; O = tmp;
  }

  const V = pickVerbFor(S.core, O.core);

  // Tokens: apenas verbo clicável para mudar o objeto
  const tokens = [];
  const P = (s)=>tokens.push({type:"text", v:s});
  const T = (op)=>tokens.push({type:"tok", op, v:realize(op,mode), axes:LEX[op].axes});

  // módulo 1
  if(S.adv) { T(S.adv); P(", "); }
  T(S.core);
  if(S.adj) { P(" "); T(S.adj); }

  P(" — é um ");
  // verbo clicável
  tokens.push({type:"tok", op:V, v:realize(V,mode), axes:LEX[V].axes, verb:true});
  P(" ");

  // módulo 3 (objeto)
  if(O.adv) { T(O.adv); P(" "); }
  T(O.core);
  if(O.adj) { P(" "); T(O.adj); }

  P(".");

  return {tokens, S, V, O};
}

/* =========================
   Sui placement (90% por móbile, estável por estado)
========================= */
function wantsSuiFor(tag){
  if(!state.suiReady) return false;
  const rng = rngFor("sui::"+tag);
  return rng() < 0.90;
}

/* =========================
   Render M1..M4 (desenho + texto tokenizado)
========================= */
const c1 = document.getElementById("c1").getContext("2d");
const c2 = document.getElementById("c2").getContext("2d");
const c3 = document.getElementById("c3").getContext("2d");
const c4 = document.getElementById("c4").getContext("2d");
const t1 = document.getElementById("t1");
const t2 = document.getElementById("t2");
const t3 = document.getElementById("t3");
const t4 = document.getElementById("t4");

function renderM1(){
  const ctx = c1; const w=ctx.canvas.width, h=ctx.canvas.height;
  drawBackground(ctx,w,h,"crib");

  // 3 pendentes
  const rng = rngFor("m1Slots");
  const slots = [];
  for(let i=0;i<3;i++){
    const fam = pickFamilyByVec(rng);
    slots.push(pickSlotFromFamily(fam, rng));
  }

  // Sui injection
  let injected = false;
  if(wantsSuiFor("m1")){
    slots[2] = 53; injected = true;
  }

  const frames = [
    {x:w*0.18, y:h*0.16, ww:w*0.22, hh:h*0.62},
    {x:w*0.39, y:h*0.16, ww:w*0.22, hh:h*0.62},
    {x:w*0.60, y:h*0.16, ww:w*0.22, hh:h*0.62},
  ];

  frames.forEach((f,idx)=>{
    drawFrame(ctx,f.x,f.y,f.ww,f.hh);
    const slot = slots[idx];
    // corda visual
    ctx.save();
    ctx.strokeStyle="rgba(20,20,30,0.16)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(f.x+f.ww/2, h*0.12);
    ctx.lineTo(f.x+f.ww/2, f.y);
    ctx.stroke();
    ctx.restore();

    if(slot===53 && state.suiReady){
      drawSui(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20);
    }else{
      drawNonSuiFragment(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20,slot);
    }
  });

  // Texto tokenizado (cliques NÃO operam aqui; só botão)
  renderTokens(t1, m1Text(), ()=>{});
}

function renderM2(){
  const ctx = c2; const w=ctx.canvas.width, h=ctx.canvas.height;
  drawBackground(ctx,w,h,"mountain");

  // slots de frente/fundo
  const rng = rngFor("m2Slots");
  // se ainda não setados, cria
  if(!state.m2FrontSlot || !state.m2BackSlot){
    const famA = pickFamilyByVec(rng);
    const famB = pickFamilyByVec(rng);
    state.m2FrontSlot = pickSlotFromFamily(famA, rng);
    state.m2BackSlot  = pickSlotFromFamily(famB, rng);
  }

  // decide Sui (um dos dois) com 90% estável, mas sem quebrar regra: só 1 Sui aqui
  if(wantsSuiFor("m2")){
    const pickFront = rng() < 0.5;
    if(pickFront) state.m2FrontSlot = 53;
    else state.m2BackSlot = 53;
  }

  const front = {x:w*0.56, y:h*0.18, ww:w*0.36, hh:h*0.62, slot: state.m2FrontSlot};
  const back  = {x:w*0.18, y:h*0.26, ww:w*0.32, hh:h*0.52, slot: state.m2BackSlot};

  // desenha fundo primeiro
  drawFrame(ctx, back.x, back.y, back.ww, back.hh);
  if(back.slot===53 && state.suiReady) drawSui(ctx, back.x+10, back.y+10, back.ww-20, back.hh-20);
  else drawNonSuiFragment(ctx, back.x+10, back.y+10, back.ww-20, back.hh-20, back.slot);

  // depois frente
  drawFrame(ctx, front.x, front.y, front.ww, front.hh);
  if(front.slot===53 && state.suiReady) drawSui(ctx, front.x+10, front.y+10, front.ww-20, front.hh-20);
  else drawNonSuiFragment(ctx, front.x+10, front.y+10, front.ww-20, front.hh-20, front.slot);

  // hit regions para click (apenas inverter)
  state._m2Hit = {front, back};

  // texto S–V–O com restrição
  const built = m2Build();
  renderTokens(t2, built.tokens, (ev, tok)=>{
    // só verbo clicável altera objeto
    if(tok.verb){
      state.m2ObjBankIdx = (state.m2ObjBankIdx + 1) % 7;
      // trocar apenas objeto implica trocar fragmento correspondente ao objeto (o "back" quando não swap? -> regra: objeto é módulo 3 (O) portanto corresponde ao fragmento de fundo quando não swap, e de frente quando swap)
      const rng2 = rngFor("m2ObjSlot");
      const fam = pickFamilyByVec(rng2);
      const newSlot = pickSlotFromFamily(fam, rng2);
      if(state.m2Swap){
        // objeto está no "front" (porque swap inverte S e O)
        state.m2FrontSlot = (wantsSuiFor("m2") ? state.m2FrontSlot : newSlot);
        if(state.m2FrontSlot!==53) state.m2FrontSlot = newSlot;
      }else{
        // objeto está no "back"
        state.m2BackSlot = (wantsSuiFor("m2") ? state.m2BackSlot : newSlot);
        if(state.m2BackSlot!==53) state.m2BackSlot = newSlot;
      }
      // impulso semântico do verbo (clique local)
      applyImpulse("m2", axisBundleFromAxesList(LEX[tok.op].axes), 0.25);
      state.version++;
      rerenderAll();
    }
  });
}

function renderM3(){
  const ctx = c3; const w=ctx.canvas.width, h=ctx.canvas.height;
  drawBackground(ctx,w,h,"maze");

  const rng = rngFor("m3Slots");
  // 7 slots
  const slots = [];
  for(let i=0;i<7;i++){
    const fam = pickFamilyByVec(rng);
    slots.push(pickSlotFromFamily(fam, rng));
  }
  // Sui injection
  if(wantsSuiFor("m3")){
    const k = Math.floor(rng()*7);
    slots[k] = 53;
  }

  // layout (bem centrado, sem cortar)
  const frames = [];
  const cols = 4;
  const cellW = w*0.22;
  const cellH = h*0.34;
  const startX = w*0.06;
  const startY = h*0.14;
  for(let i=0;i<7;i++){
    const r = Math.floor(i/cols);
    const c = i%cols;
    const x = startX + c*(cellW+ w*0.04);
    const y = startY + r*(cellH+ h*0.08);
    frames.push({x, y, ww:cellW, hh:cellH, slot:slots[i]});
  }
  state._m3Frames = frames;

  for(const f of frames){
    drawFrame(ctx,f.x,f.y,f.ww,f.hh);
    if(f.slot===53 && state.suiReady) drawSui(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20);
    else drawNonSuiFragment(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20,f.slot);
  }

  // texto maior, curatorial, tokenizado e clicável por palavra
  const tokens = poeticCuratorialTokens("m3");
  renderTokens(t3, tokens, (ev, tok)=>{
    // clique local em palavra reforça eixos dela
    applyImpulse("m3", axisBundleFromAxesList(tok.axes||[]), 0.28);
    // também reforça fonologia a partir da classe do token renderizado (sensível)
    bumpPhon(phonClass(tok.v), 0.10);
    state.m3Clicks++;
    // colapso: se clicks acumulados + eixo dominante passa limiar, muda regime levemente
    if(state.m3Clicks % 12 === 0){
      // catástrofe suave: amplifica eixo dominante e reduz o resto
      const best = AXES.filter(a=>!a.startsWith("phon_")).reduce((acc,a)=> (state.vec[a]>state.vec[acc]?a:acc), "continuity");
      for(const a of AXES){
        if(a===best) state.vec[a] = clamp(state.vec[a]+0.45, -3, 3);
        else state.vec[a] *= 0.92;
      }
    }
    state.version++;
    rerenderAll();
  });
}

function renderM4(){
  const ctx = c4; const w=ctx.canvas.width, h=ctx.canvas.height;
  drawBackground(ctx,w,h,"stairs");

  const rng = rngFor("m4Slots");
  const slots = [];
  for(let i=0;i<5;i++){
    const fam = pickFamilyByVec(rng);
    slots.push(pickSlotFromFamily(fam, rng));
  }
  if(wantsSuiFor("m4")){
    slots[Math.floor(rng()*5)] = 53;
  }

  // layout centralizado (sem cortar direita)
  const frames = [];
  const baseY = h*0.18;
  for(let i=0;i<5;i++){
    const ww = w*0.20;
    const hh = h*0.60;
    const x = w*0.08 + i*(ww + w*0.02);
    const y = baseY + (i%2)*h*0.05;
    frames.push({x,y,ww,hh,slot:slots[i]});
  }
  state._m4Frames = frames;

  for(const f of frames){
    drawFrame(ctx,f.x,f.y,f.ww,f.hh);
    if(f.slot===53 && state.suiReady) drawSui(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20);
    else drawNonSuiFragment(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20,f.slot);
  }

  // texto: tokenizado; só palavras clicáveis; migração fonológica + colapso
  const tokens = poeticCuratorialTokens("m4");
  renderTokens(t4, tokens, (ev, tok)=>{
    // restrito: só palavras, reforça fonologia dominante da palavra clicada
    const cls = phonClass(tok.v);
    bumpPhon(cls==="surda"?"surda":(cls==="sonora"?"sonora":"fricativa"), 0.35);

    // pequena coerência semântica: também reforça eixos do operador
    applyImpulse("m4", axisBundleFromAxesList(tok.axes||[]), 0.14);

    state.m4Clicks++;
    const collapsed = maybePhonCollapse();
    if(collapsed){
      // catástrofe sonora deve “puxar” visual: cut<->continuity etc
      const pm = dominantPhonMode();
      if(pm==="surda"){ state.vec.cut = clamp(state.vec.cut + 0.55, -3,3); }
      if(pm==="sonora"){ state.vec.mass = clamp(state.vec.mass + 0.50, -3,3); state.vec.density = clamp(state.vec.density + 0.35, -3,3); }
      if(pm==="fricativa"){ state.vec.continuity = clamp(state.vec.continuity + 0.55, -3,3); state.vec.rarefaction = clamp(state.vec.rarefaction + 0.35, -3,3); }
    }

    state.version++;
    rerenderAll();
  });
}

function rerenderAll(){
  // garantir que nunca “perde” a restrição: re-render não adiciona handlers extras.
  renderM1();
  renderM2();
  renderM3();
  renderM4();
}

/* =========================
   Eventos (restritos por móbile)
========================= */
document.getElementById("b1").addEventListener("click", ()=>{
  // “tensionar o início”: muda sementes iniciais de eixos (regimes)
  const rng = rngFor("m1Button");
  // escolhe 1 regime dominante (cut / continuity / density / rarefaction / center / conflict)
  const regimes = [
    {continuity:1.2, rhythm:0.6, phon_fric:0.4},
    {cut:1.3, contour:0.8, phon_surd:0.7},
    {density:1.2, mass:0.9, phon_son:0.6},
    {rarefaction:1.2, continuity:0.4, phon_fric:0.6},
    {center:1.2, conflict:0.6, phon_son:0.3},
    {conflict:1.1, oblique:0.7, phon_surd:0.4}
  ];
  const r = regimes[Math.floor(rng()*regimes.length)];

  // reset suave + aplicar regime
  for(const a of AXES) state.vec[a] *= 0.35;
  applyImpulse("m1", r, 0.95);

  // também reinicializa m2 slots de forma coerente com novo campo
  state.m2FrontSlot = null;
  state.m2BackSlot  = null;

  state.version++;
  rerenderAll();
});

// M2: clique nos fragmentos inverte somente frente/fundo e módulo1/módulo3
document.getElementById("c2").addEventListener("click", (ev)=>{
  const rect = ev.target.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (c2.canvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (c2.canvas.height / rect.height);
  const hit = state._m2Hit;
  if(!hit) return;

  function inside(r){
    return x>=r.x && x<=r.x+r.ww && y>=r.y && y<=r.y+r.hh;
  }
  const clickedFront = inside(hit.front);
  const clickedBack  = inside(hit.back);
  if(!clickedFront && !clickedBack) return;

  // INVERTE SOMENTE:
  const tmp = state.m2FrontSlot;
  state.m2FrontSlot = state.m2BackSlot;
  state.m2BackSlot  = tmp;

  state.m2Swap = !state.m2Swap;

  // verbo muda automaticamente (via rebuild), mas NÃO muda objeto por conta própria
  // impulso semântico por inversão: reforça conflito/center (posição)
  applyImpulse("m2swap", {conflict:0.35, center:0.25}, 0.45);

  state.version++;
  rerenderAll();
});

// M3: clique nos fragmentos reforça família do slot clicado (clique local de fragmento)
document.getElementById("c3").addEventListener("click", (ev)=>{
  const rect = ev.target.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (c3.canvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (c3.canvas.height / rect.height);
  const frames = state._m3Frames || [];
  for(const f of frames){
    if(x>=f.x && x<=f.x+f.ww && y>=f.y && y<=f.y+f.hh){
      const fam = slotToFamily(f.slot);
      blendFamilyIntoVec(fam, 0.32);
      // phon bump por família (aproxima conteúdo->expressão)
      if(fam.id==="F2"||fam.id==="F5") bumpPhon("surda",0.20);
      if(fam.id==="F6"||fam.id==="F12") bumpPhon("sonora",0.18);
      if(fam.id==="F1"||fam.id==="F7") bumpPhon("fricativa",0.18);
      state.version++;
      rerenderAll();
      break;
    }
  }
});

// M4: clique nos fragmentos NÃO faz nada (restrição). (Só palavras via tokens em t4).

/* =========================
   FINAL: exposição determinística
========================= */
const genFinalBtn = document.getElementById("genFinal");
const shFinalBtn  = document.getElementById("shFinal");
const finalBox    = document.getElementById("finalBox");
const cf          = document.getElementById("cf").getContext("2d");
const tf          = document.getElementById("tf");
const fallbackShare = document.getElementById("fallbackShare");

function stateSignature(){
  // assinatura curta do vetor (determinística)
  const keyAxes = ["continuity","cut","density","rarefaction","center","conflict","contour","rhythm","oblique","mass","rupture","neutral","phon_surd","phon_son","phon_fric"];
  return keyAxes.map(a=>Math.round(state.vec[a]*100)/100).join("|")
    + "|m2swap:"+(state.m2Swap?1:0)
    + "|m2obj:"+(state.m2ObjBankIdx%7);
}

function finalSlotsFromState(){
  const rng = makeRng("FINAL::" + stateSignature());
  const slots = [];
  for(let i=0;i<10;i++){
    const fam = pickFamilyByVec(rng);
    slots.push(pickSlotFromFamily(fam, rng));
  }
  // garante Sui com 90% por estado
  if(state.suiReady && rng() < 0.90){
    slots[Math.floor(rng()*10)] = 53;
  }
  return slots;
}

function styleTextFromVec(){
  const v = state.vec;
  const cutness = v.cut + v.rupture;
  const flow    = v.continuity + v.rarefaction;
  const weight  = v.density + v.mass;
  const drift   = v.oblique + v.center;
  const conflict= v.conflict;
  const phon = dominantPhonMode();
  const phonLabel = (phon==="surda") ? "cortes secos" : (phon==="sonora" ? "peso e impacto" : "passagens suaves");

  // escolha de traços dominantes
  const traits = [];
  if(cutness > flow && cutness > weight) traits.push("corte");
  if(flow > cutness && flow > weight) traits.push("fluxo");
  if(weight > cutness && weight > flow) traits.push("massa");
  if(drift > 0.9) traits.push("desvio");
  if(conflict > 0.9) traits.push("conflito");
  if(v.neutral > 0.9) traits.push("campo homogéneo");
  if(v.contour > 0.9) traits.push("contorno");

  return {traits, phon, phonLabel};
}

function finalTexts(){
  const rng = makeRng("TXT::" + stateSignature());
  const mode = currentPhonMode();
  const {traits, phon, phonLabel} = styleTextFromVec();

  // estilo curatorial (parte 1)
  const style =
`O teu estilo curatorial inclina-se para ${traits.length?traits.join(" + "):"um equilíbrio instável"} — com ${phonLabel} no corpo da linguagem.
As tuas decisões fizeram o campo pender: o que aparece não é “o melhor”, é o que o teu gesto conseguiu sustentar.`;

  // crítica (parte 2) — mais longa, “catálogo”
  const n1 = N_OPS[Math.floor(rng()*N_OPS.length)];
  const n2 = N_OPS[Math.floor(rng()*N_OPS.length)];
  const n3 = N_OPS[Math.floor(rng()*N_OPS.length)];
  const a1 = ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)];
  const a2 = ADJ_OPS[Math.floor(rng()*ADJ_OPS.length)];
  const v1 = V_OPS[Math.floor(rng()*V_OPS.length)];
  const v2 = V_OPS[Math.floor(rng()*V_OPS.length)];
  const adv= ADV_OPS[Math.floor(rng()*ADV_OPS.length)];

  const critique =
`Esta constelação trabalha a ${realize("superfície",mode)} como ${realize(a1,mode)}: não descreve, opera.
Entre ${realize(n1,mode)} e ${realize(n2,mode)}, o campo faz-se por ${realize(v1,mode)} — e a ${realize("tensão",mode)} não aparece como tema, mas como regra.
Há um ${realize("resto",mode)} que insiste: o que não entrou mantém a ${realize("emergência",mode)} em aberto.
${realize(adv,mode)}, a ${realize("configuração",mode)} ${realize(a2,mode)} parece ${realize(v2,mode)} a própria ideia de exposição: não fechar, mas tornar legível a inclinação.`;

  // convite (fixo pop+campo)
  const invite =
`Partilha a tua exposição — e chama alguém para operar outra.
Cada percurso faz emergir obras diferentes.
Que imagens os teus amigos vão encontrar que tu não conseguiste alcançar?
https://negativo-mov.github.io/negativo.mov/mobiles/entrada/`;

  return {style, critique, invite};
}

function drawFinalExhibition(slots){
  const ctx = cf; const w=ctx.canvas.width, h=ctx.canvas.height;
  drawBackground(ctx,w,h,"maze");

  // constelação
  const rng = makeRng("LAY::" + stateSignature());
  const frames = [];
  for(let i=0;i<10;i++){
    const ww = w*(0.18 + rng()*0.05);
    const hh = h*(0.28 + rng()*0.06);
    const x = w*(0.06 + rng()*0.86) - ww/2;
    const y = h*(0.10 + rng()*0.82) - hh/2;
    frames.push({x:clamp(x,10,w-ww-10), y:clamp(y,10,h-hh-10), ww, hh, slot:slots[i]});
  }

  // desenha por ordem (fundo->frente)
  for(const f of frames){
    drawFrame(ctx,f.x,f.y,f.ww,f.hh);
    if(f.slot===53 && state.suiReady) drawSui(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20);
    else drawNonSuiFragment(ctx,f.x+10,f.y+10,f.ww-20,f.hh-20,f.slot);
  }
}

genFinalBtn.addEventListener("click", ()=>{
  const slots = finalSlotsFromState(); // determinístico: não muda por clique
  drawFinalExhibition(slots);

  const {style, critique, invite} = finalTexts();
  tf.innerHTML = "";
  const p1 = document.createElement("div");
  p1.className = "gen";
  p1.textContent = style;
  const p2 = document.createElement("div");
  p2.className = "gen";
  p2.style.marginTop = "10px";
  p2.textContent = critique;
  tf.appendChild(p1);
  tf.appendChild(p2);

  // preparar share text
  const shareText =
`${style}\n\n${critique}\n\n${invite}`;

  shFinalBtn.style.display = "inline-block";
  finalBox.style.display = "block";

  // fallback box
  fallbackShare.style.display = "block";
  fallbackShare.textContent = shareText;

  // guardar para partilha
  state._finalShareText = shareText;
});

// Sharing: Web Share API com imagem do canvas (se disponível), fallback copy/download
async function shareCanvas(canvasEl, text){
  const url = "https://negativo-mov.github.io/negativo.mov/mobiles/entrada/";
  try{
    const blob = await new Promise(res=>canvasEl.toBlob(res, "image/png", 0.92));
    const files = blob ? [new File([blob], "mobiles.png", {type:"image/png"})] : [];
    if(navigator.share && (!files.length || navigator.canShare?.({files})) ){
      await navigator.share({title:"MÓBILES — curadoria", text, url, files});
      return true;
    }
  }catch(e){}
  // fallback: copiar texto
  try{
    await navigator.clipboard.writeText(text + "\n\n" + url);
    alert("Texto copiado. Cole no WhatsApp/Instagram/etc. (A imagem pode ser baixada pelo botão do browser no canvas).");
  }catch(_){
    alert("Não deu para partilhar automaticamente. Copie o texto no bloco ao fim.");
  }
  return false;
}

document.getElementById("shFinal").addEventListener("click", ()=>{
  shareCanvas(document.getElementById("cf"), state._finalShareText || "");
});

document.getElementById("sh1").addEventListener("click", ()=>{
  const txt = "Eu comecei a minha curadoria no MÓBILES. Vem operar a tua: https://negativo-mov.github.io/negativo.mov/mobiles/entrada/";
  shareCanvas(document.getElementById("c1"), txt);
});
document.getElementById("sh2").addEventListener("click", ()=>{
  const txt = "Troquei posições e senti a forma prender — até o verbo abrir saída. Faz a tua: https://negativo-mov.github.io/negativo.mov/mobiles/entrada/";
  shareCanvas(document.getElementById("c2"), txt);
});
document.getElementById("sh3").addEventListener("click", ()=>{
  const txt = "Cliquei em palavras e fragmentos: o campo respondeu ao meu gesto. Experimenta: https://negativo-mov.github.io/negativo.mov/mobiles/entrada/";
  shareCanvas(document.getElementById("c3"), txt);
});
document.getElementById("sh4").addEventListener("click", ()=>{
  const txt = "Insisti num som e a frase mudou de corpo — até colapsar. Vem: https://negativo-mov.github.io/negativo.mov/mobiles/entrada/";
  shareCanvas(document.getElementById("c4"), txt);
});

/* =========================
   Boot
========================= */
(async function boot(){
  await loadSui();

  // Garantia: se nenhum móbile cair com Sui (raro), força no M1
  // (Como é determinístico por estado, checamos uma vez)
  const anySui =
    wantsSuiFor("m1") || wantsSuiFor("m2") || wantsSuiFor("m3") || wantsSuiFor("m4");
  if(state.suiReady && !anySui){
    // força via seed tweak mínima (não muda “do nada”; muda só neste boot)
    state.version++;
  }

  // inicializa slots m2 coerentes
  state.m2FrontSlot = null;
  state.m2BackSlot  = null;

  rerenderAll();
})();
</script>
</body>
</html>
