<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — entrada</title>
  <style>
    :root{
      --bg:#fbf4f4;
      --ink:#141416;
      --muted:rgba(20,20,22,.68);
      --hair:rgba(20,20,22,.14);

      --p1:#ffe1ea;
      --p2:#dff3ff;
      --p3:#e7ffe8;
      --p4:#fff2d6;
      --acid:#a7ffb2;
      --bruise:#c9b2ff;

      --card:rgba(255,255,255,.66);
      --shadow:0 18px 60px rgba(10,10,14,.09);
      --radius:22px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 12% 6%, var(--p2), transparent 65%),
        radial-gradient(900px 620px at 88% 18%, var(--p1), transparent 62%),
        radial-gradient(880px 720px at 22% 88%, var(--p3), transparent 60%),
        radial-gradient(900px 700px at 84% 88%, var(--bruise), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.03));
      min-height:100vh;
    }

    a{color:inherit}
    .wrap{
      width:min(1120px, 92vw);
      margin: 22px auto 56px;
    }

    header{ padding: 16px 2px 10px; }
    header h1{
      margin:0 0 8px;
      font-size: 22px;
      letter-spacing:.2px;
      font-weight: 700;
    }
    header p{
      margin:0;
      max-width: 78ch;
      color:var(--muted);
      line-height:1.45;
      font-size:14px;
    }
    .sig{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .pill{
      border:1px solid var(--hair);
      background: rgba(255,255,255,.58);
      padding:6px 10px;
      border-radius:999px;
      box-shadow: 0 10px 30px rgba(0,0,0,.06);
      backdrop-filter: blur(8px);
    }

    .card{
      margin-top: 18px;
      border: 1px solid rgba(20,20,22,.12);
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
    }
    .head{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      padding: 14px 16px;
      border-bottom:1px solid rgba(20,20,22,.10);
      background: linear-gradient(90deg, rgba(255,255,255,.66), rgba(255,255,255,.36));
    }
    .t b{
      display:block;
      font-size:14px;
      letter-spacing:.2px;
      margin-bottom:4px;
    }
    .t small{
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      display:block;
      max-width: 70ch;
    }
    .mini{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button{
      border:1px solid rgba(20,20,22,.16);
      background: rgba(255,255,255,.72);
      color:var(--ink);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:600;
      font-size:12px;
      letter-spacing:.1px;
      box-shadow: 0 12px 34px rgba(0,0,0,.08);
    }
    button:hover{transform: translateY(-1px)}
    button:active{transform: translateY(0px); opacity:.88}

    .stage{ padding: 14px 16px 18px; }

    .fixedIntro{
      font-size:14px;
      line-height:1.35;
      color:var(--ink);
      margin:2px 0 14px 0;
      opacity:.92
    }

    canvas{
      width:100%;
      height:auto;
      border-radius: 18px;
      border: 1px solid rgba(20,20,22,.16);
      background:
        radial-gradient(700px 420px at 30% 35%, rgba(255,255,255,.55), rgba(255,255,255,.20) 62%, rgba(0,0,0,.02)),
        linear-gradient(135deg, rgba(255,220,235,.28), rgba(223,243,255,.28), rgba(231,255,232,.22));
      box-shadow: 0 20px 70px rgba(0,0,0,.08);
    }
    .txt{
      margin-top: 10px;
      font-size: 14px;
      line-height: 1.55;
      color: rgba(20,20,22,.86);
      letter-spacing:.1px;
      max-width: 90ch;
    }
    .w{
      cursor:pointer;
      border-radius: 6px;
      padding: 0 2px;
    }
    .w:hover{
      background: rgba(167,255,178,.18);
      outline: 1px dashed rgba(20,20,22,.18);
    }
    .verb{
      background: rgba(201,178,255,.18);
      outline: 1px dashed rgba(20,20,22,.18);
    }
    .lock{ opacity:.92; }

    .hint{
      margin-top:10px;
      font-size: 12px;
      color: var(--muted);
    }

    .finalGridNote{
      margin-top:10px;
      font-size:12px;
      color: var(--muted);
    }

    footer{
      margin-top: 26px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
    }

    /* modal share */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.42);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 999;
    }
    .modal{
      width: min(980px, 96vw);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(20,20,22,.16);
      border-radius: 18px;
      box-shadow: 0 30px 120px rgba(0,0,0,.28);
      overflow:hidden;
      backdrop-filter: blur(12px);
    }
    .mhead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 12px 14px;
      border-bottom:1px solid rgba(20,20,22,.12);
      background: linear-gradient(90deg, rgba(255,255,255,.82), rgba(255,255,255,.62));
    }
    .mcontent{
      padding: 14px;
      display:grid;
      gap: 12px;
      grid-template-columns: 1.2fr .8fr;
    }
    .mcontent textarea{
      width:100%;
      min-height: 180px;
      border-radius: 14px;
      padding: 10px;
      border: 1px solid rgba(20,20,22,.18);
      outline:none;
      font-size: 13px;
      line-height:1.45;
      resize: vertical;
      background: rgba(255,255,255,.82);
    }
    .mcontent .imgbox{
      border: 1px solid rgba(20,20,22,.14);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(255,255,255,.84);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:10px;
    }
    .mcontent img{max-width:100%; height:auto; border-radius:12px}
    .mfoot{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding: 12px 14px;
      border-top:1px solid rgba(20,20,22,.12);
      background: rgba(255,255,255,.82);
      flex-wrap:wrap;
    }
    .toast{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      background: rgba(20,20,22,.88);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 1000;
      box-shadow: 0 18px 60px rgba(0,0,0,.28);
    }
    .toast.on{opacity:1; transform: translateX(-50%) translateY(-2px)}
    @media (max-width: 900px){
      .mcontent{grid-template-columns: 1fr}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>MÓBILES — entrada</h1>
      <p>
        Operas aqui a tua própria curadoria. A artista é <b>suiornotsui</b>.
        Mas as obras que vês nunca são todas. O que aparece depende do modo como entras,
        de onde começas, do gesto que insistes em repetir, do que escolhes tocar e do que deixas passar.
        Por trás do que vês, há sempre mais. Algumas imagens só surgem sob certas tensões.
        Outras resistem, permanecem ausentes, como se aguardassem um olhar que ainda não chegou.
        Esse resto — aquilo que nunca aparece — sustenta o desejo de continuar.
      </p>
      <div class="sig">
        <span class="pill">NEGATIVO.mov · MÓBILES</span>
        <span class="pill">curadoria como posição</span>
        <span class="pill">resto como motor</span>
        <span class="pill">assinatura: <b>suiornotsui</b></span>
      </div>
    </header>

    <section class="card" id="m1">
      <div class="head">
        <div class="t">
          <b>Móbile 1 — Nascimento do campo</b>
          <small>3 fragmentos · o ponto de partida regula tudo o que poderá emergir depois</small>
        </div>
        <div class="mini">
          <button id="m1Tension">Tensionar nascimento</button>
          <button id="m1Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m1Fixed">Tudo começa aqui.<br>Três formas pendem no campo,<br>leves, ainda indecisas.<br>Cada tensão desloca o lugar de onde partes.<br>Não é escolha de imagens.<br>É escolha de posição.<br>E o modo como começas<br>inclina todo o percurso.</div>
        <canvas id="m1Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m1Text"></div>
        <div class="hint">M1: <b>só</b> o botão tensiona. O campo muda de regime, mas não vira embaralho a cada clique menor.</div>
      </div>
    </section>

    <section class="card" id="m2">
      <div class="head">
        <div class="t">
          <b>Móbile 2 — Posição e estrutura (S–V–O)</b>
          <small>2 fragmentos · frente/fundo = sujeito/objeto; <b>verbo</b> altera verbo + objeto (e só isso)</small>
        </div>
        <div class="mini">
          <button id="m2Swap">Inverter</button>
          <button id="m2Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m2Fixed">Agora há relação.<br>Algo ocupa a frente.<br>Algo permanece no fundo.<br>Trocar de lugar muda o sentido,<br>mas não liberta da forma.<br>Há posições que se repetem.<br>Só o gesto —<br>o que fazes —<br>abre outra possibilidade.</div>
        <canvas id="m2Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m2Text"></div>
        <div class="hint">M2: botão/canvas só <b>inverte</b>. Clique no <b>verbo</b> muda verbo + objeto (sujeito fica).</div>
      </div>
    </section>

    <section class="card" id="m3">
      <div class="head">
        <div class="t">
          <b>Móbile 3 — Formação do gesto (estilo)</b>
          <small>7 fragmentos · clique em fragmentos/palavras intensifica traços (visível) até colapsar</small>
        </div>
        <div class="mini">
          <button id="m3Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m3Fixed">O campo começa a responder ao teu gesto.<br>Onde insistes, algo cresce.<br>O que tocas torna-se mais visível.<br>O que ignoras afasta-se.<br>Sem perceber, vais formando um modo de ver.<br>Um estilo.<br>Uma inclinação do mundo.</div>
        <canvas id="m3Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m3Text"></div>
        <div class="hint">M3: sem botões além de partilhar. Clique = <b>intensificar</b> (não “trocar tudo”).</div>
      </div>
    </section>

    <section class="card" id="m4">
      <div class="head">
        <div class="t">
          <b>Móbile 4 — Corpo da linguagem (fonografia) + colapso</b>
          <small>5 fragmentos · <b>só palavras</b>: plosiva surda / plosiva sonora / fricativa — insistir satura</small>
        </div>
        <div class="mini">
          <button id="m4Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="m4Fixed">Agora já não operas imagens.<br>Operas a própria linguagem.<br>Cada palavra carrega um corpo.<br>Um peso.<br>Um som.<br>Uma força.<br>Insistir numa forma faz o campo inteiro ceder.<br>Até que, em excesso,<br>algo colapsa<br>e o regime muda.</div>
        <canvas id="m4Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m4Text"></div>
        <div class="hint">M4: clique apenas nas palavras. Você deve <b>ouvir</b> o regime no texto (e ver o campo “ceder”).</div>
      </div>
    </section>

    <section class="card" id="final">
      <div class="head">
        <div class="t">
          <b>Estado alcançado — tua exposição provisória</b>
          <small>10 fragmentos · texto (estilo curatorial + crítica), pronto pra partilhar</small>
        </div>
        <div class="mini">
          <button id="btnFinalize">Gerar a minha expo</button>
          <button id="finalShare">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <div class="fixedIntro" id="finalFixed">O que construíste aqui não é um resultado neutro.<br>Revela algo do teu modo de ver,<br>do teu modo de escolher,<br>do teu modo de insistir.<br>Esta é a tua curadoria possível —<br>não a melhor,<br>não a definitiva,<br>mas a que emergiu das tuas decisões.<br>Outras teriam produzido outras constelações.<br>E ainda assim,<br>algo ficou sempre de fora.<br>Esse resto —<br>o que não conseguiste alcançar —<br>é o que mantém o desejo vivo.<br>Partilha o teu percurso.<br>Não como resposta,<br>mas como pergunta aberta aos outros.</div>
        <canvas id="finalCanvas" width="1000" height="640"></canvas>
        <div class="txt" id="finalText"></div>
        <div class="finalGridNote" id="weeklyGate"></div>
        <div class="hint">Depois a gente liga aqui o forms/endpoint semanal (bloqueado até gerar tua expo).</div>
      </div>
    </section>

    <footer>
      MÓBILES · entrada — dispositivo tensivo de emergência, espraiamento e circulação do improvável · NEGATIVO.mov
    </footer>
  </div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="mhead">
        <b id="shareTitle">Partilhar</b>
        <div style="margin-top:4px;color:var(--muted);font-size:12px" id="shareNote"></div>
        <button id="closeShare">Fechar</button>
      </div>
      <div class="mcontent">
        <div>
          <textarea id="shareText"></textarea>
          <div style="margin-top:10px;color:var(--muted);font-size:12px">
            Dica: em desktop, copie o texto + baixe a imagem. Em mobile, salvar a imagem e colar o texto funciona bem.
          </div>
        </div>
        <div class="imgbox">
          <img id="shareImg" alt="imagem para partilha" />
        </div>
      </div>
      <div class="mfoot">
        <button id="copyText">Copiar texto</button>
        <button id="downloadImg">Baixar imagem</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   LÉXICO COMPLETO — 70 operadores × 3 realizações
============================================================ */
const LEX = {
  vestigio:{ surda:"traço", sonora:"marca", fricativa:"sombra" },
  sopro:{ surda:"pingo", sonora:"bafo", fricativa:"suspiro" },
  dobra:{ surda:"prega", sonora:"curva", fricativa:"flexão" },
  canto:{ surda:"quina", sonora:"beira", fricativa:"franja" },
  margem:{ surda:"limite", sonora:"borda", fricativa:"fronteira" },
  poeira:{ surda:"pó", sonora:"bruma", fricativa:"cinza" },
  silencio:{ surda:"pausa", sonora:"calma", fricativa:"sussurro" },
  rastro:{ surda:"pegada", sonora:"vesta", fricativa:"resíduo" },
  fragmento:{ surda:"cortezinho", sonora:"bordado", fricativa:"desfiado" },
  detalhe:{ surda:"ponto", sonora:"miolo", fricativa:"nuança" },

  lembranca:{ surda:"nota", sonora:"memória", fricativa:"recordação" },
  demora:{ surda:"pausa", sonora:"espera", fricativa:"suspensão" },
  intervalo:{ surda:"corte", sonora:"entre", fricativa:"fresta" },
  eco:{ surda:"toque", sonora:"resposta", fricativa:"ressonância" },
  resto:{ surda:"ruga", sonora:"sobra", fricativa:"resíduo" },

  plano:{ surda:"linha", sonora:"base", fricativa:"superfície" },
  camada:{ surda:"capa", sonora:"nível", fricativa:"espessura" },
  textura:{ surda:"trama", sonora:"tecido", fricativa:"fibra" },
  superficie:{ surda:"pele", sonora:"face", fricativa:"película" },
  escala:{ surda:"passo", sonora:"medida", fricativa:"proporção" },
  ritmo:{ surda:"pulso", sonora:"cadência", fricativa:"fluência" },
  materia:{ surda:"corpo", sonora:"substância", fricativa:"massa" },

  presenca:{ surda:"toque", sonora:"vulto", fricativa:"sombra" },
  tensao:{ surda:"nó", sonora:"peso", fricativa:"pressão" },
  campo:{ surda:"plano", sonora:"território", fricativa:"ambiente" },
  emergencia:{ surda:"salto", sonora:"aparição", fricativa:"insurgência" },
  configuracao:{ surda:"forma", sonora:"estrutura", fricativa:"composição" },
  cessacao:{ surda:"corte", sonora:"encerramento", fricativa:"silenciamento" },

  aproximar:{ surda:"chegar", sonora:"beirar", fricativa:"esfumar" },
  reparar:{ surda:"notar", sonora:"observar", fricativa:"esmiuçar" },
  tocar:{ surda:"tatear", sonora:"roçar", fricativa:"aflorar" },
  escutar:{ surda:"ouvir", sonora:"acolher", fricativa:"sintonizar" },
  demorar_v:{ surda:"parar", sonora:"permanecer", fricativa:"alongar-se" },
  pousar:{ surda:"cair", sonora:"assentar", fricativa:"deslizar" },
  acompanhar:{ surda:"seguir", sonora:"amparar", fricativa:"entrelaçar" },
  cuidar:{ surda:"zelar", sonora:"nutrir", fricativa:"suavizar" },

  recortar:{ surda:"cortar", sonora:"delimitar", fricativa:"fissurar" },
  deslocar:{ surda:"mover", sonora:"transferir", fricativa:"deslizar" },
  sustentar:{ surda:"segurar", sonora:"manter", fricativa:"suspender" },
  distribuir:{ surda:"partir", sonora:"organizar", fricativa:"espalhar" },
  sobrepor:{ surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir" },
  atravessar:{ surda:"passar", sonora:"cruzar", fricativa:"permeiar" },
  insinuar:{ surda:"sugerir", sonora:"indicar", fricativa:"sussurrar" },

  insistir:{ surda:"bater", sonora:"persistir", fricativa:"ressoar" },
  interromper:{ surda:"cortar", sonora:"cessar", fricativa:"esvair-se" },
  fixar:{ surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar" },
  suspender:{ surda:"parar", sonora:"reter", fricativa:"flutuar" },
  reter:{ surda:"prender", sonora:"guardar", fricativa:"conservar" },
  abandonar:{ surda:"largar", sonora:"deixar", fricativa:"dissolver" },
  transformar:{ surda:"romper", sonora:"converter", fricativa:"transfigurar" },

  leve:{ surda:"claro", sonora:"brando", fricativa:"suave" },
  minimo:{ surda:"curto", sonora:"pequeno", fricativa:"sutil" },
  fragil:{ surda:"ténue", sonora:"delicado", fricativa:"sensível" },
  tenue:{ surda:"fino", sonora:"delgado", fricativa:"esfumado" },
  quase_a:{ surda:"breve", sonora:"próximo", fricativa:"difuso" },

  opaco:{ surda:"denso", sonora:"turvo", fricativa:"fosco" },
  poroso:{ surda:"aberto", sonora:"vazado", fricativa:"permeável" },
  irregular:{ surda:"torto", sonora:"instável", fricativa:"assimétrico" },
  difuso:{ surda:"solto", sonora:"amplo", fricativa:"disperso" },

  latente:{ surda:"oculto", sonora:"presente", fricativa:"subjacente" },
  instavel:{ surda:"quebrado", sonora:"oscilante", fricativa:"flutuante" },
  provisorio:{ surda:"breve", sonora:"mutável", fricativa:"transitório" },

  ainda:{ surda:"já", sonora:"agora", fricativa:"sempre" },
  quase:{ surda:"logo", sonora:"perto", fricativa:"talvez" },
  lentamente:{ surda:"aos poucos", sonora:"com calma", fricativa:"suavemente" },
  por_vezes:{ surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente" },
  sempre:{ surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente" },
  raramente:{ surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente" },
  talvez:{ surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente" },
  agora:{ surda:"já", sonora:"neste momento", fricativa:"presentemente" },
};

/* ============================================================
   GRUPOS (conteúdo / funções) — 70 operadores organizados
============================================================ */
const N_SENS = ["vestigio","sopro","dobra","canto","margem","poeira","silencio","rastro","fragmento","detalhe"];
const N_MEM  = ["lembranca","demora","intervalo","eco","resto","cessacao"];
const N_PLAS = ["plano","camada","textura","superficie","escala","ritmo","materia"];
const N_CUR  = ["presenca","tensao","campo","emergencia","configuracao"];

const V_SENS = ["aproximar","reparar","tocar","escutar","demorar_v","pousar","acompanhar","cuidar"];
const V_COMP = ["recortar","deslocar","sustentar","distribuir","sobrepor","atravessar","insinuar"];
const V_DEC  = ["insistir","interromper","fixar","suspender","reter","abandonar","transformar"];

const A_SENS = ["leve","minimo","fragil","tenue","quase_a"];
const A_VIS  = ["opaco","poroso","irregular","difuso"];
const A_CRIT = ["latente","instavel","provisorio"];

const ADV    = ["ainda","quase","lentamente","por_vezes","sempre","raramente","talvez","agora"];

/* ============================================================
   ESTADO GLOBAL (campo) — agora menos “embaralho”, mais “inclinação”
============================================================ */
const G = {
  front: 0.0,
  dense: 0.0,
  cont:  0.0,
  pressure: 0.10,
  ph: { dry:0.0, voiced:0.0, open:0.0 },
  collapse: 0,
};

const Mob = {
  m1:{ slots:null, focusFam:null },
  m2:{ slots:null, flip:false, verbIx:0, subjKey:null, objKey:null, verbKey:null },
  m3:{ slots:null, focusFam: null, intensity:0, clicks:0 },
  m4:{ slots:null, focusPh: null, intensity:0, clicks:0 },
  final:{ ready:false, slots:null },
};

/* ============================================================
   UTIL
============================================================ */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const rnd   = (a,b)=>a + Math.random()*(b-a);
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

function toast(msg){
  const t=document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("on");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>t.classList.remove("on"), 1200);
}

function phMode(){
  const {dry, voiced, open} = G.ph;
  const m = Math.max(dry, voiced, open);
  if(m < 0.22) return "neutro";
  if(m===dry) return "surda";
  if(m===voiced) return "sonora";
  return "fricativa";
}

function realize(key){
  const o = LEX[key];
  if(!o) return key;
  const mode = phMode();
  if(mode==="surda") return o.surda || o.sonora || o.fricativa;
  if(mode==="sonora") return o.sonora || o.surda || o.fricativa;
  if(mode==="fricativa") return o.fricativa || o.sonora || o.surda;

  // neutro: mistura com leve viés pelos acumuladores
  const wDry = Math.max(0.01, 0.34 + G.ph.dry*0.16);
  const wVoi = Math.max(0.01, 0.34 + G.ph.voiced*0.16);
  const wOpn = Math.max(0.01, 0.34 + G.ph.open*0.16);
  const s = wDry+wVoi+wOpn;
  const r = Math.random()*s;
  if(r<wDry) return o.surda;
  if(r<wDry+wVoi) return o.sonora;
  return o.fricativa;
}

function applyDelta(delta){
  if(typeof delta.front==="number") G.front = clamp(G.front + delta.front, -1, 1);
  if(typeof delta.dense==="number") G.dense = clamp(G.dense + delta.dense, -1, 1);
  if(typeof delta.cont ==="number") G.cont  = clamp(G.cont  + delta.cont,  -1, 1);
  if(typeof delta.pressure==="number") G.pressure = clamp(G.pressure + delta.pressure, 0, 1);
  if(delta.ph){
    if(typeof delta.ph.dry==="number") G.ph.dry = clamp(G.ph.dry + delta.ph.dry, -1, 1);
    if(typeof delta.ph.voiced==="number") G.ph.voiced = clamp(G.ph.voiced + delta.ph.voiced, -1, 1);
    if(typeof delta.ph.open==="number") G.ph.open = clamp(G.ph.open + delta.ph.open, -1, 1);
  }
}

/* ============================================================
   FRASES — “voz curatorial” mais longa (exceto M2)
   (coerência: repete termos, abre intervalo/resto, fecha com tese)
============================================================ */
function pickAdjByState(){
  // escolhe adjetivo conforme inclinação do campo (mais consistente)
  if(G.dense>0.22) return realize(pick(A_VIS));
  if(G.front>0.22) return realize(pick(A_CRIT));
  return realize(pick(A_SENS));
}
function maybeAdj(prob=0.72){
  if(Math.random() > prob) return null;
  return pickAdjByState();
}
function maybeAdv(prob=0.62){
  if(Math.random() > prob) return null;
  return realize(pick(ADV));
}
function phraseN(group){
  const key = pick(group);
  const n = realize(key);
  const adj = maybeAdj(0.60);
  if(adj) return `${n} ${adj}`;
  return n;
}
function phraseNCore(group){
  // só núcleo (para M2)
  const key = pick(group);
  return { key, surf: realize(key) };
}
function phraseAdvTail(){
  const adv = maybeAdv(0.70);
  return adv ? ` ${adv}` : "";
}
function phraseV(group){
  const key = pick(group);
  return { key, surf: realize(key) };
}

function genCuratorialParagraph(kind){
  // kind: m1 / m3 / m4 / finalA / finalB
  const n1 = phraseN(N_PLAS);
  const n2 = phraseN(N_SENS);
  const n3 = phraseN(N_CUR);
  const n4 = phraseN(N_MEM);
  const v1 = realize(pick(V_COMP));
  const v2 = realize(pick(V_SENS));
  const v3 = realize(pick(V_DEC));
  const adv = phraseAdvTail();

  if(kind==="m1"){
    return [
      `A ${n1} não é decoração: é o plano onde o teu olhar aprende a ${v2}${adv}.`,
      `Quando tensionas o início, a ${n2} muda de lugar e a ${n3} ganha outra medida — como se o campo escolhesse, contigo, o que pode virar forma.`,
      `O que ainda não aparece permanece como ${n4}: não é falha, é reserva. É isso que mantém a curadoria viva.`
    ].join(" ");
  }

  if(kind==="m3"){
    return [
      `Aqui a máquina deixa de “mostrar” e começa a responder. Onde tocas, a ${n3} se ${v1}${adv}; onde repetes, a ${n1} adensa e o resto se desloca.`,
      `O teu gesto cria um estilo: uma forma de ${v2} o mundo por ${n2}, sem precisar de tema.`,
      `Insistir não é teimosia: é método. A cada insistência, algo se revela — e algo se perde como ${n4}.`
    ].join(" ");
  }

  if(kind==="m4"){
    const mode = phMode();
    const label = (mode==="surda") ? "corte seco" : (mode==="sonora" ? "ruptura estrondosa" : (mode==="fricativa" ? "passagem fluida" : "corpo indeciso"));
    return [
      `Agora o operador é a própria matéria sonora. Cada palavra traz ${label}: o som arrasta consigo um modo de recortar o campo.`,
      `Ao insistires, a frase se reorganiza e a ${n1} se deixa ${v1}${adv} — como se a língua fosse um dispositivo de montagem.`,
      `No limite, há colapso: não para terminar, mas para ${v3} o regime e devolver ${n4} como resto operável.`
    ].join(" ");
  }

  if(kind==="finalA"){
    return [
      `O teu estilo curatorial tende a ${v1}${adv} — preferindo ${n1} e ${n3} em vez de enunciados fechados.`,
      `Atenção ao que foi ficando mais nítido: o teu gesto valoriza ${n2} e aceita ${n4} como condição de trabalho.`,
      `Em termos de campo, isso produz uma curadoria que não prova “tema”: prova posição.`
    ].join(" ");
  }

  if(kind==="finalB"){
    return [
      `A exposição montada aqui aparece como ${n3}: uma constelação onde a ${n1} não fecha o sentido, apenas o sustenta.`,
      `Entre ${n2} e ${n4}, o percurso mantém uma pergunta no lugar certo — o lugar onde o olhar volta.`,
      `Partilhar não é exibir resultado: é reencenar o dispositivo, para ver que outras obras emergem onde tu não conseguiste chegar.`
    ].join(" ");
  }

  return "";
}

/* ============================================================
   TEXTO RICO (clique em palavras) — M3/M4
============================================================ */
let SURFACE_PH = null;
function buildSurfacePhMap(){
  const m = new Map();
  for(const k of Object.keys(LEX)){
    const o = LEX[k];
    if(!o || typeof o!=="object") continue;
    if(o.surda) m.set(String(o.surda).toLowerCase(), "surda");
    if(o.sonora) m.set(String(o.sonora).toLowerCase(), "sonora");
    if(o.fricativa) m.set(String(o.fricativa).toLowerCase(), "fricativa");
  }
  return m;
}
function inferPh(token){
  if(!SURFACE_PH) SURFACE_PH = buildSurfacePhMap();
  const t = String(token||"").toLowerCase().replace(/[.,;:!?]/g,"");
  return SURFACE_PH.get(t) || null;
}
function setRichTextPlain(el, text){
  el.textContent = text;
}
function setRichTextWithMeta(el, text, key){
  const parts = text.split(/(\s+)/);
  el.innerHTML = "";
  for(const p of parts){
    if(p.trim()===""){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    const span = document.createElement("span");
    span.className = "w";
    span.textContent = p;
    const clean = p.toLowerCase().replace(/[.,;:!?]/g,"");
    span.dataset.token = clean;

    if(key==="m3"){
      // palavra tende a reforçar eixo conforme classe (heurística simples porém estável)
      let axe = "front";
      if(tokIsFromSets(clean, SETS.dense)) axe="dense";
      else if(tokIsFromSets(clean, SETS.cont)) axe="cont";
      else if(tokIsFromSets(clean, SETS.front)) axe="front";
      span.dataset.axe = axe;
    }
    if(key==="m4"){
      span.dataset.ph = inferPh(clean) || (Math.random()<0.34 ? "surda" : (Math.random()<0.5 ? "sonora" : "fricativa"));
    }
    el.appendChild(span);
  }
}
const SETS = { front:new Set(), dense:new Set(), cont:new Set() };
function addVar(set, obj){
  if(!obj) return;
  if(obj.surda) set.add(String(obj.surda).toLowerCase());
  if(obj.sonora) set.add(String(obj.sonora).toLowerCase());
  if(obj.fricativa) set.add(String(obj.fricativa).toLowerCase());
}
function tokIsFromSets(tok, set){ return set.has(tok); }
(function buildSets(){
  for(const k of N_CUR.concat(N_MEM)) addVar(SETS.front, LEX[k]);
  for(const k of N_PLAS) addVar(SETS.dense, LEX[k]);
  for(const k of N_SENS) addVar(SETS.cont, LEX[k]);
  for(const k of V_DEC) addVar(SETS.front, LEX[k]);
  for(const k of V_COMP) addVar(SETS.dense, LEX[k]);
  for(const k of V_SENS) addVar(SETS.cont, LEX[k]);
})();

/* ============================================================
   IMAGENS / FRAGMENTOS (slots 1..120) + Sui (53)
============================================================ */
const BASE_SLOTS = 120;
const SUI_SLOT = 53;

function slotFamily(slot){
  if(slot>=1 && slot<=10) return 1;
  if(slot<=20) return 2;
  if(slot<=30) return 3;
  if(slot<=40) return 4;
  if(slot<=50) return 5;
  if(slot<=60) return 6;
  if(slot<=70) return 7;
  if(slot<=80) return 8;
  if(slot<=90) return 9;
  if(slot<=100) return 10;
  if(slot<=110) return 11;
  return 12;
}
function shouldForceSui(){ return Math.random() < 0.90; }

function pickSlotWeighted(count){
  const arr=[];
  for(let i=1;i<=BASE_SLOTS;i++){
    let w=1;
    const fam = slotFamily(i);

    // inclinações globais (estáveis)
    if(G.cont>0.20 && fam===1) w+=1.3;
    if(G.pressure>0.55 && (fam===2||fam===5)) w+=1.35;
    if(Math.abs(G.front)>0.35 && fam===3) w+=1.05;
    if(G.dense>0.25 && fam===6) w+=1.25;
    if(G.dense<-0.15 && fam===7) w+=1.05;
    if(G.front<-0.25 && fam===8) w+=0.90;
    if(G.cont<-0.15 && fam===12) w+=0.90;

    if(fam===4 || fam===10 || fam===11) w+=0.25;

    if(i===SUI_SLOT) w+=0.35;

    const k=Math.max(1, Math.floor(w*6));
    for(let j=0;j<k;j++) arr.push(i);
  }

  const out=[];
  const pool=[...arr];
  while(out.length<count && pool.length){
    const idx=(Math.random()*pool.length)|0;
    out.push(pool[idx]);
    pool.splice(idx,1);
  }
  while(out.length<count) out.push( ((Math.random()*BASE_SLOTS)|0)+1 );
  return out;
}

function slotUrl(slot){
  if(slot===SUI_SLOT){
    return "assets/sui/slot_053.jpg";
  }
  return null;
}

/* ============================================================
   DESENHO (cenários visíveis + contornos fortes + INTENSIFICAÇÃO PERCEPTÍVEL)
============================================================ */
const HITS = { m1:[], m2:[], m3:[], m4:[], final:[] };
function clearHits(key){ HITS[key]=[]; }

function drawFrame(ctx, x,y,w,h, style){
  ctx.save();
  ctx.fillStyle = style.fill;
  ctx.strokeStyle = style.stroke;
  ctx.lineWidth = style.line || 3.0;
  ctx.shadowColor = style.shadow || "rgba(0,0,0,.12)";
  ctx.shadowBlur = style.blur || 18;
  ctx.shadowOffsetY = style.offy || 8;
  ctx.beginPath();
  const r=16;
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur=0;
  ctx.stroke();
  ctx.restore();
}

function drawHorrorPastelBG(ctx, W,H, mood){
  ctx.save();
  ctx.clearRect(0,0,W,H);

  const g=ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0, "rgba(255,225,234,.62)");
  g.addColorStop(0.45, "rgba(223,243,255,.55)");
  g.addColorStop(1, "rgba(231,255,232,.52)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  for(let i=0;i<10;i++){
    const x=rnd(0,W), y=rnd(0,H), r=rnd(90,220);
    const gg=ctx.createRadialGradient(x,y,0,x,y,r);
    gg.addColorStop(0, (Math.random()<0.5) ? "rgba(201,178,255,.22)" : "rgba(167,255,178,.16)");
    gg.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle=gg;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  ctx.strokeStyle="rgba(20,20,22,.08)";
  ctx.lineWidth=1;
  for(let i=0;i<14;i++){
    ctx.beginPath();
    ctx.moveTo(rnd(0,W), rnd(0,H));
    ctx.bezierCurveTo(rnd(0,W),rnd(0,H), rnd(0,W),rnd(0,H), rnd(0,W),rnd(0,H));
    ctx.stroke();
  }

  if(mood==="crib"){
    ctx.strokeStyle="rgba(20,20,22,.12)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(W*0.5, H*0.04, W*0.55, Math.PI*0.08, Math.PI*0.92);
    ctx.stroke();
    for(const k of [0.33,0.5,0.67]){
      ctx.beginPath();
      ctx.moveTo(W*0.5, H*0.06);
      ctx.lineTo(W*k, H*0.22);
      ctx.stroke();
    }
  }
  if(mood==="mountains"){
    ctx.fillStyle="rgba(20,20,22,.06)";
    ctx.beginPath();
    ctx.moveTo(0,H*0.70);
    ctx.lineTo(W*0.18,H*0.52);
    ctx.lineTo(W*0.32,H*0.66);
    ctx.lineTo(W*0.52,H*0.44);
    ctx.lineTo(W*0.70,H*0.62);
    ctx.lineTo(W*0.86,H*0.50);
    ctx.lineTo(W,H*0.68);
    ctx.lineTo(W,H);
    ctx.lineTo(0,H);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle="rgba(20,20,22,.16)";
    ctx.lineWidth=2;
    for(const px of [0.22,0.42,0.62,0.78]){
      const x=W*px, y=H*0.78 + rnd(-6,6);
      ctx.beginPath();
      ctx.moveTo(x-10,y);
      ctx.lineTo(x+10,y);
      ctx.moveTo(x-6,y);
      ctx.lineTo(x-10,y+10);
      ctx.moveTo(x+6,y);
      ctx.lineTo(x+10,y+10);
      ctx.stroke();
    }
  }
  if(mood==="maze"){
    ctx.strokeStyle="rgba(20,20,22,.14)";
    ctx.lineWidth=2;
    const step=44;
    for(let y=24;y<H-24;y+=step){
      for(let x=24;x<W-24;x+=step){
        if(Math.random()<0.55){
          ctx.beginPath();
          ctx.moveTo(x,y);
          ctx.lineTo(x+step*(Math.random()<0.5?1:0), y+step*(Math.random()<0.5?1:0));
          ctx.stroke();
        }
      }
    }
  }
  if(mood==="stairs"){
    ctx.strokeStyle="rgba(20,20,22,.16)";
    ctx.lineWidth=3;
    for(let i=0;i<7;i++){
      const x=rnd(W*0.08,W*0.86);
      const y=rnd(H*0.10,H*0.86);
      const w=rnd(120,240);
      const h=rnd(60,110);
      ctx.beginPath();
      ctx.rect(x,y,w,h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x,y+h);
      ctx.lineTo(x+w*0.25,y+h*0.72);
      ctx.lineTo(x+w*0.5,y+h);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// intensidade perceptível: realça família focada, desbota demais
function applyVisualIntensityForSlot(ctx, slot, key){
  if(key==="m3" && Mob.m3.focusFam!=null){
    const fam = slotFamily(slot);
    const t = clamp(Mob.m3.intensity, 0, 1);
    if(fam === Mob.m3.focusFam){
      // realce
      ctx.globalAlpha = 1.0;
      ctx.filter = `contrast(${1.0 + 0.75*t}) saturate(${1.0 + 0.45*t})`;
    }else{
      // desbote
      ctx.globalAlpha = 1.0 - 0.55*t;
      ctx.filter = `grayscale(${0.22 + 0.55*t}) contrast(${1.0 - 0.12*t})`;
    }
  } else {
    ctx.globalAlpha = 1.0;
    ctx.filter = "none";
  }
}

function drawProceduralFragment(ctx, x,y,w,h, slot, key){
  const fam = slotFamily(slot);

  const pals = [
    ["rgba(255,225,234,.80)","rgba(20,20,22,.55)"],
    ["rgba(223,243,255,.78)","rgba(20,20,22,.58)"],
    ["rgba(231,255,232,.78)","rgba(20,20,22,.58)"],
    ["rgba(255,242,214,.76)","rgba(20,20,22,.58)"],
    ["rgba(201,178,255,.72)","rgba(20,20,22,.62)"],
    ["rgba(167,255,178,.68)","rgba(20,20,22,.62)"],
  ];
  const [fillBase, ink] = pals[(fam-1)%pals.length];

  // borda mais “viva” quando focado
  let stroke = "rgba(20,20,22,.55)";
  let line = 3.2;
  if(key==="m3" && Mob.m3.focusFam!=null && fam===Mob.m3.focusFam){
    line = 4.4;
    stroke = "rgba(20,20,22,.78)";
  }

  drawFrame(ctx, x,y,w,h, {
    fill: fillBase,
    stroke,
    line,
    shadow: "rgba(0,0,0,.16)",
    blur: 20,
    offy: 10
  });

  ctx.save();
  ctx.beginPath();
  const r=14;
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.clip();

  ctx.strokeStyle = ink;
  ctx.fillStyle = ink;
  ctx.lineWidth = 2.4;

  if(fam===1){
    for(let i=0;i<9;i++){
      const yy = y + (i+1)*(h/10);
      ctx.beginPath();
      ctx.moveTo(x+10, yy);
      ctx.bezierCurveTo(x+w*0.35, yy-10, x+w*0.65, yy+10, x+w-10, yy);
      ctx.stroke();
    }
  }else if(fam===2){
    for(let i=0;i<5;i++){
      const xx = x + (i+2)*(w/7);
      ctx.beginPath();
      ctx.moveTo(xx, y+10);
      ctx.lineTo(xx, y+h-10);
      ctx.stroke();
    }
  }else if(fam===3){
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(x-20, y + i*(h/5));
      ctx.lineTo(x+w+20, y + i*(h/5) + 22);
      ctx.stroke();
    }
  }else if(fam===4){
    for(let i=0;i<8;i++){
      const cx = x + (i+1)*(w/9);
      ctx.beginPath();
      ctx.arc(cx, y+h*0.55, 10, 0, Math.PI*2);
      ctx.stroke();
    }
  }else if(fam===5){
    for(let i=0;i<8;i++){
      ctx.beginPath();
      ctx.moveTo(x+rnd(0,w), y+rnd(0,h));
      ctx.lineTo(x+rnd(0,w), y+rnd(0,h));
      ctx.stroke();
    }
  }else if(fam===6){
    for(let i=0;i<30;i++){
      ctx.globalAlpha = 0.55;
      ctx.fillRect(x+rnd(0,w), y+rnd(0,h), rnd(4,10), rnd(4,10));
    }
    ctx.globalAlpha = 1;
  }else if(fam===7){
    ctx.strokeStyle="rgba(20,20,22,.22)";
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.arc(x+w*0.5, y+h*0.5, 30+i*18, 0, Math.PI*2);
      ctx.stroke();
    }
  }else if(fam===8){
    ctx.beginPath();
    ctx.arc(x+w*0.55, y+h*0.48, 46, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(x+w*0.42, y+h*0.58, 28, 0, Math.PI*2);
    ctx.stroke();
  }else if(fam===9){
    ctx.globalAlpha=0.18;
    ctx.fillRect(x+10,y+10,w-20,h-20);
    ctx.globalAlpha=1;
  }else if(fam===10){
    for(let i=0;i<10;i++){
      ctx.beginPath();
      ctx.moveTo(x+w*0.5, y+h*0.5);
      ctx.lineTo(x+rnd(0,w), y+rnd(0,h));
      ctx.stroke();
    }
  }else if(fam===11){
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.rect(x+18,y+18,w-36,h-36);
    ctx.stroke();
    ctx.beginPath();
    ctx.rect(x+32,y+32,w-64,h-64);
    ctx.stroke();
  }else{
    ctx.fillStyle="rgba(20,20,22,.32)";
    ctx.fillRect(x+18, y+18, w-36, h-36);
  }

  ctx.restore();

  ctx.save();
  ctx.fillStyle="rgba(20,20,22,.50)";
  ctx.font="12px ui-sans-serif";
  ctx.fillText(String(slot).padStart(3,"0"), x+14, y+22);
  ctx.restore();
}

async function drawImageInto(ctx, imgUrl, x,y,w,h, slot, key){
  return new Promise((resolve)=>{
    const im = new Image();
    im.crossOrigin="anonymous";
    im.onload=()=>{
      ctx.save();
      let stroke = "rgba(20,20,22,.65)";
      let line = 3.2;
      if(key==="m3" && Mob.m3.focusFam!=null && slotFamily(slot)===Mob.m3.focusFam){
        line = 4.4;
        stroke = "rgba(20,20,22,.82)";
      }
      drawFrame(ctx,x,y,w,h,{ fill:"rgba(255,255,255,.86)", stroke, line, shadow:"rgba(0,0,0,.16)", blur:22, offy:10 });
      ctx.beginPath();
      const r=14;
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(im, x, y, w, h);
      ctx.restore();
      resolve(true);
    };
    im.onerror=()=>resolve(false);
    im.src=imgUrl + (imgUrl.includes("?") ? "" : ("?v="+Date.now()));
  });
}

/* ============================================================
   COMPOSIÇÕES — agora NÃO re-sorteia a cada clique (só em eventos maiores)
============================================================ */
function sampleSlots(n){
  let slots = pickSlotWeighted(n);
  if(shouldForceSui()){
    if(!slots.includes(SUI_SLOT)) slots[0]=SUI_SLOT;
  }
  for(let i=slots.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0;
    [slots[i],slots[j]]=[slots[j],slots[i]];
  }
  return slots;
}

async function drawMobile(canvas, key, n){
  const ctx=canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  clearHits(key);

  const mood = (key==="m1")?"crib":(key==="m2")?"mountains":(key==="m3")?"maze":(key==="m4")?"stairs":"maze";
  drawHorrorPastelBG(ctx,W,H,mood);

  // slots fixos
  let slots = Mob[key]?.slots;
  if(!slots || slots.length!==n){
    slots = sampleSlots(n);
    Mob[key].slots = slots;
  }

  // layout por móbile
  let rects=[];
  if(key==="m1"){
    rects = [
      {x:W*0.18,y:H*0.22,w:W*0.24,h:H*0.42, z:1},
      {x:W*0.38,y:H*0.24,w:W*0.24,h:H*0.42, z:2},
      {x:W*0.58,y:H*0.22,w:W*0.24,h:H*0.42, z:3},
    ];
  }else if(key==="m2"){
    // fundo + frente; swap troca a ordem de desenho
    const back  = {x:W*0.14,y:H*0.30,w:W*0.34,h:H*0.46, z:1};
    const front = {x:W*0.52,y:H*0.22,w:W*0.36,h:H*0.54, z:2};
    if(Mob.m2.flip){
      rects = [front, back];
    }else{
      rects = [back, front];
    }
  }else if(key==="m3"){
    const pts=[
      [0.12,0.25],[0.33,0.20],[0.54,0.24],[0.76,0.18],
      [0.18,0.58],[0.46,0.62],[0.74,0.55]
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.18+rnd(-0.02,0.02)), h:H*(0.26+rnd(-0.03,0.03)), z:i+1
    }));
  }else if(key==="m4"){
    const pts=[
      [0.18,0.24],[0.52,0.18],[0.68,0.44],[0.34,0.50],[0.10,0.58],
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.22+rnd(-0.02,0.02)), h:H*(0.28+rnd(-0.03,0.03)), z:i+1
    }));
  }else{
    const pts=[
      [0.10,0.18],[0.28,0.12],[0.50,0.16],[0.72,0.10],[0.82,0.28],
      [0.62,0.36],[0.38,0.34],[0.16,0.40],[0.24,0.62],[0.62,0.62],
    ];
    rects = pts.map((p,i)=>({
      x:W*p[0], y:H*p[1], w:W*(0.20+rnd(-0.02,0.02)), h:H*(0.26+rnd(-0.03,0.03)), z:i+1
    }));
  }

  rects.sort((a,b)=>a.z-b.z);

  for(let i=0;i<rects.length;i++){
    const r=rects[i];
    const slot=slots[i];
    const url=slotUrl(slot);

    ctx.save();
    applyVisualIntensityForSlot(ctx, slot, key);

    if(url){
      const ok = await drawImageInto(ctx, url, r.x, r.y, r.w, r.h, slot, key);
      if(!ok) drawProceduralFragment(ctx, r.x, r.y, r.w, r.h, slot, key);
    }else{
      drawProceduralFragment(ctx, r.x, r.y, r.w, r.h, slot, key);
    }

    ctx.restore();

    // hitbox (só onde o móbile permite)
    HITS[key].push({x:r.x,y:r.y,w:r.w,h:r.h,slot});
  }

  // overlay do M4 para “ceder” com regime fonográfico
  if(key==="m4"){
    const mode = phMode();
    const t = clamp(Mob.m4.intensity, 0, 1);
    ctx.save();
    ctx.globalAlpha = 0.12 + 0.22*t;
    if(mode==="surda") ctx.fillStyle="rgba(20,20,22,.55)";
    else if(mode==="sonora") ctx.fillStyle="rgba(201,178,255,.55)";
    else if(mode==="fricativa") ctx.fillStyle="rgba(167,255,178,.45)";
    else ctx.fillStyle="rgba(255,255,255,.35)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }
}

/* ============================================================
   M2 — S–V–O com inversão estrita + verbo muda verbo+objeto
============================================================ */
const M2_VERBS = [
  ...V_COMP, ...V_SENS, ...V_DEC
];

function m2InitIfNeeded(){
  if(Mob.m2.subjKey && Mob.m2.objKey && Mob.m2.verbKey) return;

  // sujeito e objeto fixos (até M1 retensionar ou colapso global)
  const subj = (G.front>0.22) ? pick(N_CUR) : pick(N_SENS);
  const obj  = (G.dense>0.22) ? pick(N_PLAS) : pick(N_MEM);
  Mob.m2.subjKey = subj;
  Mob.m2.objKey  = obj;

  // verbo inicial
  Mob.m2.verbIx = (Math.random()*M2_VERBS.length)|0;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];
}

function m2PhraseBlockN(nKey){
  // bloco: núcleo substantivo + adjetivo/adv opcionais dependentes do estado global
  const n = realize(nKey);
  const adjProb = clamp(0.25 + Math.abs(G.dense)*0.35 + Math.abs(G.front)*0.20, 0.20, 0.75);
  const advProb = clamp(0.15 + Math.abs(G.cont)*0.28, 0.10, 0.55);
  const adj = (Math.random()<adjProb) ? pickAdjByState() : null;
  const adv = (Math.random()<advProb) ? realize(pick(ADV)) : null;

  let s = n;
  if(adj) s += " " + adj;
  if(adv) s += " " + adv;
  return s;
}

function renderM2Text(){
  m2InitIfNeeded();
  const el = document.getElementById("m2Text");
  el.innerHTML = "";

  const subjKey = Mob.m2.flip ? Mob.m2.objKey : Mob.m2.subjKey;
  const objKey  = Mob.m2.flip ? Mob.m2.subjKey : Mob.m2.objKey;

  const block1 = m2PhraseBlockN(subjKey);
  const block3 = m2PhraseBlockN(objKey);

  const verb = realize(Mob.m2.verbKey);

  const s1 = document.createElement("span");
  s1.className="lock";
  s1.textContent = block1 + " ";

  const sv = document.createElement("span");
  sv.className="w verb";
  sv.textContent = verb + " ";

  const s3 = document.createElement("span");
  s3.className="lock";
  s3.textContent = block3 + ".";

  el.appendChild(s1);
  el.appendChild(sv);
  el.appendChild(s3);
}

function doM2Swap(){
  // swap estrito: imagens frente↔fundo (já via Mob.m2.flip), e bloco 1↔bloco 3
  Mob.m2.flip = !Mob.m2.flip;
  applyDelta({ front: (Mob.m2.flip? -0.08:+0.08), pressure: 0.03, cont:rnd(-0.02,0.02) });
  rerenderM2(true);
}

function doM2VerbClick(){
  // verbo muda verbo + altera OBJETO (bloco 3) — sujeito fica
  Mob.m2.verbIx = (Mob.m2.verbIx + 1) % M2_VERBS.length;
  Mob.m2.verbKey = M2_VERBS[Mob.m2.verbIx];

  // muda objeto ao trocar verbo (regra pedida)
  const pool = (G.dense>0.18) ? N_PLAS.concat(N_MEM) : N_MEM.concat(N_SENS);
  Mob.m2.objKey = pick(pool);

  applyDelta({ pressure: 0.06, dense:rnd(-0.04,0.04), cont:rnd(-0.04,0.04) });
  rerenderM2(false);
}

/* ============================================================
   CLIQUES (restrições por móbile) — agora cada clique mexe pouco e mostra muito
============================================================ */
function bindCanvasClicks(key, canvas){
  canvas.addEventListener("click", (ev)=>{
    // M1: canvas mudo
    // M2: clicar no canvas equivale a inverter
    // M3: clicar no fragmento intensifica família do slot
    // M4: canvas mudo
    // FINAL: canvas mudo
    if(key==="m1" || key==="m4" || key==="final") return;

    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top)  * (canvas.height/ r.height);
    const hits = HITS[key] || [];
    const hit = hits.find(h => x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h);
    if(!hit) return;

    try{
      if(key==="m2"){ doM2Swap(); return; }

      if(key==="m3"){
        const slot = hit.slot;
        const fam = slotFamily(slot);

        // intensifica só esse traço (família) — perceptível
        Mob.m3.focusFam = fam;
        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.14, 0, 1);
        Mob.m3.clicks++;

        // influência global pequena (para os outros móbiles “sentirem”)
        applyDelta({
          pressure: 0.03,
          cont: (fam===1||fam===4||fam===7) ? +0.05 : -0.02,
          dense:(fam===6||fam===12) ? +0.05 : 0.00,
          front:(fam===2||fam===5) ? +0.05 : 0.00
        });

        // colapso (catástrofe): sobe para nova configuração do M3 (re-amostra só o M3)
        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          G.collapse = clamp(G.collapse+1,0,3);
          Mob.m3.slots = null; // reamostra apenas aqui
          toast("M3: catástrofe — o regime virou.");
        }

        rerenderM3();
        // e atualiza M4 texto (pequena ressonância) sem mudar imagens
        rerenderM4(false);
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no clique (ver consola).");
    }
  });
}

function bindTextClicks(key, textEl){
  textEl.addEventListener("click", (ev)=>{
    const t = ev.target;
    if(!t || !t.classList) return;

    if(key==="m1") return;

    if(key==="m2"){
      if(!t.classList.contains("verb")) return;
      doM2VerbClick();
      return;
    }

    if(!t.classList.contains("w")) return;

    try{
      if(key==="m3"){
        // palavra intensifica eixo — mas não troca fragmentos
        const axe = t.dataset.axe || "front";
        Mob.m3.clicks++;
        Mob.m3.intensity = clamp(Mob.m3.intensity + 0.10, 0, 1);

        // traduz eixo em família aproximada (para realce visual)
        const famByAxe = (axe==="dense") ? 6 : (axe==="cont") ? 1 : 2;
        Mob.m3.focusFam = famByAxe;

        // influência global pequena
        const delta = { front:0, dense:0, cont:0, pressure:0.025 };
        delta[axe] = 0.06;
        applyDelta(delta);

        if(Mob.m3.intensity >= 0.98){
          Mob.m3.intensity = 0;
          Mob.m3.focusFam = null;
          G.collapse = clamp(G.collapse+1,0,3);
          Mob.m3.slots = null;
          toast("M3: catástrofe — nova configuração.");
        }

        rerenderM3();
        rerenderM4(false);
        return;
      }

      if(key==="m4"){
        // clique só nas palavras: intensifica o perfil fonográfico
        const ph = t.dataset.ph;
        Mob.m4.focusPh = ph;
        Mob.m4.intensity = clamp(Mob.m4.intensity + 0.14, 0, 1);
        Mob.m4.clicks++;

        // altera estado fonográfico de modo claro
        if(ph==="surda") applyDelta({ ph:{dry:+0.30}, pressure:+0.04, cont:-0.02 });
        else if(ph==="sonora") applyDelta({ ph:{voiced:+0.30}, pressure:+0.04, dense:+0.02 });
        else applyDelta({ ph:{open:+0.30}, pressure:+0.04, cont:+0.02 });

        // colapso do M4 (regime muda): reamostra só o M4 (não o resto)
        if(Mob.m4.intensity >= 0.98){
          Mob.m4.intensity = 0;
          Mob.m4.focusPh = null;
          G.collapse = clamp(G.collapse+1,0,3);
          Mob.m4.slots = null;
          toast("M4: colapso — o corpo sonoro virou regime.");
        }

        rerenderM4(true);
        return;
      }
    }catch(e){
      console.error(e);
      toast("Erro no texto: ver consola");
    }
  });
}

/* ============================================================
   RENDER — agora por partes (evita “embaralhar”)
============================================================ */
async function rerenderM1(){
  const c=document.getElementById("m1Canvas");
  await drawMobile(c,"m1",3);
  setRichTextPlain(document.getElementById("m1Text"), genCuratorialParagraph("m1"));
}
async function rerenderM2(redrawCanvas){
  if(redrawCanvas){
    const c=document.getElementById("m2Canvas");
    await drawMobile(c,"m2",2);
  }else{
    // só redesenha para mostrar swap visual (já é necessário quando flip muda)
    const c=document.getElementById("m2Canvas");
    await drawMobile(c,"m2",2);
  }
  renderM2Text();
}
async function rerenderM3(){
  const c=document.getElementById("m3Canvas");
  await drawMobile(c,"m3",7);
  setRichTextWithMeta(document.getElementById("m3Text"), genCuratorialParagraph("m3"), "m3");
}
async function rerenderM4(redrawText){
  const c=document.getElementById("m4Canvas");
  await drawMobile(c,"m4",5);

  // texto do M4 sempre reflete o estado fonográfico, mas não precisa mudar “tudo”
  if(redrawText!==false){
    setRichTextWithMeta(document.getElementById("m4Text"), genCuratorialParagraph("m4"), "m4");
  }else{
    // ainda mantém texto consistente (não deixando congelado demais)
    setRichTextWithMeta(document.getElementById("m4Text"), genCuratorialParagraph("m4"), "m4");
  }
}

function buildFinalText(){
  const link = location.href;
  const a = genCuratorialParagraph("finalA");
  const b = genCuratorialParagraph("finalB");
  const c = `\n\nPartilha e convida: “faz a tua curadoria aqui → ${link}”.\nassinatura: suiornotsui`;
  return `${a}\n\n${b}${c}`;
}

async function rerenderFinal(){
  const c=document.getElementById("finalCanvas");
  await drawMobile(c,"final",10);
  document.getElementById("finalText").textContent = buildFinalText();
  document.getElementById("weeklyGate").textContent =
    "Para ver os estados expositivos semanais, faz primeiro a tua curadoria (gera a tua expo).";
}

/* ============================================================
   SHARE
============================================================ */
function openShare(title, note, text, dataUrl){
  document.getElementById("shareTitle").textContent = title;
  document.getElementById("shareNote").textContent = note || "";
  document.getElementById("shareText").value = text || "";
  document.getElementById("shareImg").src = dataUrl || "";
  document.getElementById("overlay").style.display="flex";
}
function closeShare(){ document.getElementById("overlay").style.display="none"; }
function canvasToDataUrl(id){
  const c=document.getElementById(id);
  try{ return c.toDataURL("image/png"); }catch(e){ return ""; }
}
function shareTextFor(kind){
  const link = location.href;
  if(kind==="m1"){
    return `MÓBILES (entrada) — eu tensionei o nascimento do campo.\n\nNão escolhi “imagens”: escolhi posição.\n\nFaz o teu percurso aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m2"){
    return `MÓBILES — posição e estrutura (S–V–O).\nInverter troca sujeito↔objeto; clicar no verbo muda o objeto.\n\nFaz o teu aqui: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m3"){
    return `MÓBILES — foco e estilo.\nOnde eu insisti, um traço cresceu; o resto recuou.\n\nTesta o teu gesto: ${link}\n\nassinatura: suiornotsui`;
  }
  if(kind==="m4"){
    return `MÓBILES — corpo sonoro da linguagem.\nInsisti no som até o regime ceder.\n\nJoga também: ${link}\n\nassinatura: suiornotsui`;
  }
  return `MÓBILES — minha exposição provisória.\n\n${buildFinalText()}`;
}

/* ============================================================
   BOTÕES / BOOT
============================================================ */
function bindButtons(){
  document.getElementById("m1Tension").addEventListener("click", ()=>{
    // evento grande: retensionar = pode reamostrar todos
    applyDelta({
      front: rnd(-0.55,0.55),
      dense: rnd(-0.50,0.50),
      cont:  rnd(-0.55,0.55),
      pressure: 0.12,
      ph: { dry:rnd(-0.25,0.25), voiced:rnd(-0.25,0.25), open:rnd(-0.25,0.25) }
    });

    // reamostra todos (regime inicial muda)
    Mob.m1.slots=null;
    Mob.m2.slots=null; Mob.m2.subjKey=null; Mob.m2.objKey=null; Mob.m2.verbKey=null;
    Mob.m3.slots=null; Mob.m3.focusFam=null; Mob.m3.intensity=0;
    Mob.m4.slots=null; Mob.m4.focusPh=null; Mob.m4.intensity=0;
    if(Mob.final.ready) Mob.final.slots=null;

    rerenderAll();
  });

  document.getElementById("m2Swap").addEventListener("click", doM2Swap);

  document.getElementById("btnFinalize").addEventListener("click", ()=>{
    Mob.final.ready = true;
    Mob.final.slots = null; // gera constelação nova do estado atual
    rerenderFinal();
    toast("Exposição gerada.");
  });

  document.getElementById("m1Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 1", "imagem + texto", shareTextFor("m1"), canvasToDataUrl("m1Canvas"));
  });
  document.getElementById("m2Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 2", "imagem + texto", shareTextFor("m2"), canvasToDataUrl("m2Canvas"));
  });
  document.getElementById("m3Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 3", "imagem + texto", shareTextFor("m3"), canvasToDataUrl("m3Canvas"));
  });
  document.getElementById("m4Share").addEventListener("click", ()=>{
    openShare("Partilhar — Móbile 4", "imagem + texto", shareTextFor("m4"), canvasToDataUrl("m4Canvas"));
  });
  document.getElementById("finalShare").addEventListener("click", ()=>{
    if(!Mob.final.ready){
      toast("Primeiro: gerar a tua expo.");
      return;
    }
    openShare("Partilhar — tua exposição provisória", "imagem + texto", shareTextFor("final"), canvasToDataUrl("finalCanvas"));
  });

  document.getElementById("closeShare").addEventListener("click", closeShare);
  document.getElementById("overlay").addEventListener("click", (e)=>{
    if(e.target && e.target.id==="overlay") closeShare();
  });
  document.getElementById("copyText").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(document.getElementById("shareText").value);
      toast("Texto copiado.");
    }catch(e){
      toast("Não consegui copiar (permissão).");
    }
  });
  document.getElementById("downloadImg").addEventListener("click", ()=>{
    const url = document.getElementById("shareImg").src;
    if(!url){ toast("Sem imagem."); return; }
    const a=document.createElement("a");
    a.href=url;
    a.download="mobiles.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });
}

function bindAllClicks(){
  bindCanvasClicks("m1", document.getElementById("m1Canvas"));
  bindCanvasClicks("m2", document.getElementById("m2Canvas"));
  bindCanvasClicks("m3", document.getElementById("m3Canvas"));
  bindCanvasClicks("m4", document.getElementById("m4Canvas"));
  bindCanvasClicks("final", document.getElementById("finalCanvas"));

  bindTextClicks("m1", document.getElementById("m1Text"));
  bindTextClicks("m2", document.getElementById("m2Text"));
  bindTextClicks("m3", document.getElementById("m3Text"));
  bindTextClicks("m4", document.getElementById("m4Text"));
  bindTextClicks("final", document.getElementById("finalText"));
}

async function rerenderAll(){
  await rerenderM1();
  await rerenderM2(true);
  await rerenderM3();
  await rerenderM4(true);
  if(Mob.final.ready) await rerenderFinal();
}

(async function boot(){
  bindButtons();
  bindAllClicks();
  await rerenderAll();
})();
</script>
</body>
</html>
