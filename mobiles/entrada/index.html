<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MÓBILES — suiornotsui (NEGATIVO.mov)</title>
  <meta name="description" content="Opera aqui a tua própria curadoria. MÓBILES — máquina curatorial-semântica." />

  <style>
    :root{
      /* docilidade pastel + resto mórbido */
      --bg0:#fbfaf8;
      --bg1:#f6f4ef;
      --ink:#141416;
      --muted:rgba(20,20,22,.68);
      --hair:rgba(20,20,22,.16);

      --bruise: rgba(140,90,160,.22);
      --mold:   rgba(80,150,115,.22);
      --acid:   rgba(165,185,90,.16);
      --ash:    rgba(90,90,105,.10);

      --card: rgba(255,255,255,.62);
      --card2: rgba(255,255,255,.72);

      --line: rgba(20,20,22,.14);
      --line2: rgba(20,20,22,.22);

      --shadow: 0 14px 46px rgba(0,0,0,.10);
      --radius: 26px;

      --serif: ui-serif, "Iowan Old Style", "Palatino Linotype", Palatino, "Cormorant Garamond", Georgia, serif;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    html,body{
      height:100%;
      margin:0;
      color:var(--ink);
      font-family:var(--sans);
      background:
        radial-gradient(1200px 820px at 16% 8%, var(--bruise), transparent 60%),
        radial-gradient(900px 620px at 84% 18%, var(--mold), transparent 55%),
        radial-gradient(1000px 820px at 60% 86%, var(--acid), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, #f7f3f6);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow-x:hidden;
    }

    .wrap{
      max-width: 1040px;
      margin: 0 auto;
      padding: 22px 16px 84px;
    }

    header{
      padding: 8px 6px 14px;
    }
    .brand{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-family:var(--serif);
      font-weight:700;
      letter-spacing:.2px;
      font-size:clamp(28px, 3vw, 40px);
      line-height:1.06;
    }
    .sub{
      color:var(--muted);
      font-size:13px;
      max-width: 52ch;
    }

    .lead{
      margin: 14px 6px 0;
      white-space:pre-wrap;
      font-size:15px;
      line-height:1.55;
      color:rgba(20,20,22,.78);
      max-width: 86ch;
    }

    /* fluxo contínuo, sem “saletinhas” duras */
    .card{
      margin: 20px 0;
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--card), rgba(255,255,255,.44));
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .head{
      padding: 14px 16px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      border-bottom: 1px solid rgba(20,20,22,.08);
      background: rgba(255,255,255,.35);
    }
    .head .t b{
      display:block;
      font-family:var(--serif);
      font-weight: 720;
      letter-spacing:.2px;
      font-size: 18px;
    }
    .head .t small{
      display:block;
      color:var(--muted);
      font-size: 12.5px;
      margin-top: 3px;
      max-width: 68ch;
    }

    .mini{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    button, .btn{
      appearance:none;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,.72);
      color: rgba(20,20,22,.86);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 13px;
      cursor:pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      transition: transform .06s ease;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    button:hover, .btn:hover{ transform: translateY(-1px); }
    button:active, .btn:active{ transform: translateY(0px); }

    .stage{
      position:relative;
      padding: 14px 14px 16px;
    }

    canvas{
      width:100%;
      height:auto;
      border-radius: 18px;
      display:block;
      background:
        radial-gradient(900px 520px at 20% 20%, rgba(255,255,255,.55), rgba(255,255,255,.16) 58%, rgba(255,255,255,.08)),
        linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.06));
      border: 1px solid rgba(20,20,22,.18);
    }

    .txt{
      margin-top: 10px;
      padding: 10px 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.44);
      border: 1px solid rgba(20,20,22,.10);
      white-space:pre-wrap;
      font-size: 14px;
      line-height: 1.55;
      color: rgba(20,20,22,.84);
    }

    .txt .w{
      cursor:pointer;
      border-bottom: 1px dotted rgba(20,20,22,.20);
      padding-bottom: 1px;
    }
    .txt .w:hover{
      background: rgba(140,90,160,.12);
      border-bottom-color: rgba(20,20,22,.36);
      border-radius: 6px;
    }

    .hint{
      margin-top: 10px;
      color: rgba(20,20,22,.66);
      font-size: 12.5px;
      line-height:1.35;
      padding: 0 2px;
    }

    .finalGridNote{
      margin-top:10px;
      color:rgba(20,20,22,.70);
      font-size:12.5px;
      line-height:1.35;
    }

    footer{
      padding: 18px 6px 0;
      color: rgba(20,20,22,.58);
      font-size: 12px;
      line-height:1.35;
    }

    /* toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(20,20,22,.88);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 12.5px;
      box-shadow: 0 18px 70px rgba(0,0,0,.22);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index: 9999;
      max-width: min(92vw, 720px);
      text-align:center;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.on{ opacity: 1; }

    /* modal fallback */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      z-index: 9998;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      align-items:center;
      justify-content:center;
      padding: 16px;
    }
    .overlay.on{ display:flex; }
    .modal{
      width: min(620px, 96vw);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.78);
      box-shadow: 0 26px 90px rgba(0,0,0,.28);
      overflow:hidden;
    }
    .modal .mhead{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(20,20,22,.12);
      background: rgba(255,255,255,.65);
    }
    .modal .mbody{
      padding: 12px 14px;
    }
    .modal pre{
      margin:10px 0 0;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(20,20,22,.12);
      border-radius: 14px;
      padding: 10px;
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(20,20,22,.80);
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .modal .mbtns{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      padding: 0 14px 14px;
    }

    @media (max-width:720px){
      .head{ align-items:flex-start; }
      .mini{ justify-content:flex-start; }
      .sub{ max-width: 100%; }
      .lead{ font-size:14px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <h1>MÓBILES</h1>
        <div class="sub">Entrada — operar curadoria como máquina (semântica + imagem + fonografia) · assinatura: <b>suiornotsui</b></div>
      </div>

      <div class="lead" id="openingText"></div>
    </header>

    <section class="card" id="m1">
      <div class="head">
        <div class="t">
          <b>Móbile 1 — Nascimento do campo</b>
          <small>3 fragmentos · o ponto de partida regula tudo o que poderá emergir depois</small>
        </div>
        <div class="mini">
          <button id="m1Tension">Tensionar nascimento</button>
          <button id="m1Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <canvas id="m1Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m1Text"></div>
        <div class="hint">Aqui você decide “de onde nasce”: a máquina vai resistir/ceder conforme esse começo.</div>
      </div>
    </section>

    <section class="card" id="m2">
      <div class="head">
        <div class="t">
          <b>Móbile 2 — Estrutura e posição</b>
          <small>2 fragmentos · frente/fundo = sujeito/objeto; clicar no verbo abre fuga</small>
        </div>
        <div class="mini">
          <button id="m2Swap">Inverter</button>
          <button id="m2Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <canvas id="m2Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m2Text"></div>
        <div class="hint">Duas posições fechadas. Uma fenda: agir no verbo para deslizar o sentido.</div>
      </div>
    </section>

    <section class="card" id="m3">
      <div class="head">
        <div class="t">
          <b>Móbile 3 — Formação do gesto (foco / estilo)</b>
          <small>7 fragmentos · clique em palavras e fragmentos para reforçar um traço predominante</small>
        </div>
        <div class="mini">
          <button id="m3Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <canvas id="m3Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m3Text"></div>
        <div class="hint">O que você insiste em clicar vira estilo: o mundo começa a obedecer ao teu foco.</div>
      </div>
    </section>

    <section class="card" id="m4">
      <div class="head">
        <div class="t">
          <b>Móbile 4 — Corpo da linguagem (fonografia) + colapso</b>
          <small>5 fragmentos · só as palavras são clicáveis: insistir num corpo sonoro inclina tudo até saturar</small>
        </div>
        <div class="mini">
          <button id="m4Share">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <canvas id="m4Canvas" width="1000" height="560"></canvas>
        <div class="txt" id="m4Text"></div>
        <div class="hint">Agora a palavra vira corpo: seco/sonoro/arranhado — e isso volta pro visual. Excesso: colapso.</div>
      </div>
    </section>

    <section class="card" id="final">
      <div class="head">
        <div class="t">
          <b>Estado alcançado — tua exposição provisória</b>
          <small>10 fragmentos · gera texto (estilo curatorial + crítica), pronto pra partilhar</small>
        </div>
        <div class="mini">
          <button id="btnFinalize">Gerar a minha expo</button>
          <button id="finalShare">Partilhar</button>
        </div>
      </div>
      <div class="stage">
        <canvas id="finalCanvas" width="1000" height="640"></canvas>
        <div class="txt" id="finalText"></div>
        <div class="finalGridNote" id="weeklyGate"></div>
        <div class="hint">Cessar aqui não é “fim”: é um recorte que deixa resto — e o resto chama reencenação.</div>
      </div>
    </section>

    <footer>
      MÓBILES · entrada — dispositivo tensivo de emergência, espraiamento e circulação do improvável · NEGATIVO.mov
    </footer>
  </div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="mhead">
        <b id="shareTitle">Partilhar</b>
        <div style="margin-top:4px;color:var(--muted);font-size:12px" id="shareNote"></div>
      </div>
      <div class="mbody">
        <canvas id="shareCanvas" width="1200" height="1200" style="width:100%;height:auto;border-radius:14px;border:1px solid rgba(20,20,22,.14)"></canvas>
        <pre id="shareText"></pre>
      </div>
      <div class="mbtns">
        <button id="copyText">Copiar texto</button>
        <button id="downloadImg">Baixar imagem</button>
        <button id="nativeShare">Partilhar</button>
        <button id="closeDlg">Fechar</button>
      </div>
    </div>
  </div>

<script>
/* ======================================================
   0) PATHS (CORRIGIDO)
   - Você está em: /mobiles/entrada/
   - sui.json está em: /mobiles/sui.json
   - assets/sui/slot_053.jpg está em: /mobiles/assets/sui/slot_053.jpg
====================================================== */
const BASE_MOBILES = "https://negativo-mov.github.io/negativo.mov/mobiles/";
const SUI_JSON_URL = BASE_MOBILES + "sui.json"; // <- CERTO

/* ======================================================
   1) util
====================================================== */
function clamp(x,min,max){ return Math.max(min, Math.min(max,x)); }
function lerp(a,b,t){ return a+(b-a)*t; }
function rnd(a=1,b=null){ if(b===null){ b=a; a=0; } return a + Math.random()*(b-a); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function nowISO(){ const d=new Date(); return d.toISOString().replace("T"," ").slice(0,19); }

function toast(msg){
  const el=document.getElementById("toast");
  el.textContent = msg;
  el.classList.add("on");
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>el.classList.remove("on"), 2400);
}

/* segurança: se algo quebrar, você vê */
window.addEventListener("error", (e)=>{
  toast("Erro no script: " + (e?.message || "ver consola"));
});

/* ======================================================
   2) TEXTOS FIXOS (APROVADOS)
====================================================== */
const TEXT_OPENING =
`Operas aqui a tua própria curadoria.

A artista é suiornotsui.
Mas as obras que vês nunca são todas.

O que aparece depende do modo como entras,
de onde começas,
do gesto que insistes em repetir,
do que escolhes tocar
e do que deixas passar.

Por trás do que vês, há sempre mais.
Algumas imagens só surgem sob certas tensões.
Outras resistem, permanecem ausentes,
como se aguardassem um olhar que ainda não chegou.

Esse resto —
aquilo que nunca aparece —
sustenta o desejo de continuar.`;

const INTRO_M1 =
`Tudo começa aqui.
Três formas pendem no campo,
leves, ainda indecisas.
Cada tensão desloca o lugar de onde partes.
Não é escolha de imagens.
É escolha de posição.
E o modo como começas
inclina todo o percurso.`;

const INTRO_M2 =
`Agora há relação.
Algo ocupa a frente.
Algo permanece no fundo.
Trocar de lugar muda o sentido,
mas não liberta da forma.
Há posições que se repetem.
Só o gesto —
o que fazes —
abre outra possibilidade.`;

const INTRO_M3 =
`O campo começa a responder ao teu gesto.
Onde insistes, algo cresce.
O que tocas torna-se mais visível.
O que ignoras afasta-se.
Sem perceber, vais formando um modo de ver.
Um estilo.
Uma inclinação do mundo.`;

const INTRO_M4 =
`Agora já não operas imagens.
Operas a própria linguagem.
Cada palavra carrega um corpo.
Um peso.
Um som.
Uma força.
Insistir numa forma faz o campo inteiro ceder.
Até que, em excesso,
algo colapsa
e o regime muda.`;

const TEXT_FINAL_CLOSING =
`O que construíste aqui não é um resultado neutro.
Revela algo do teu modo de ver,
do teu modo de escolher,
do teu modo de insistir.

Esta é a tua curadoria possível —
não a melhor,
não a definitiva,
mas a que emergiu das tuas decisões.

Outras teriam produzido outras constelações.
E ainda assim,
algo ficou sempre de fora.

Esse resto —
o que não conseguiste alcançar —
é o que mantém o desejo vivo.

Partilha o teu percurso.
Não como resposta,
mas como pergunta aberta aos outros.`;

/* ======================================================
   3) LÉXICO (EXATAMENTE o teu) — 70 operadores × 3
====================================================== */
const LEX = {
  /* SUBSTANTIVOS (1–28) */
  vestigio:{ surda:"traço", sonora:"marca", fricativa:"sombra" },
  sopro:{ surda:"pingo", sonora:"bafo", fricativa:"suspiro" },
  dobra:{ surda:"prega", sonora:"curva", fricativa:"flexão" },
  canto:{ surda:"quina", sonora:"beira", fricativa:"franja" },
  margem:{ surda:"limite", sonora:"borda", fricativa:"fronteira" },
  poeira:{ surda:"pó", sonora:"bruma", fricativa:"cinza" },
  silencio:{ surda:"pausa", sonora:"calma", fricativa:"sussurro" },
  rastro:{ surda:"pegada", sonora:"vesta", fricativa:"resíduo" },
  fragmento:{ surda:"cortezinho", sonora:"bordado", fricativa:"desfiado" },
  detalhe:{ surda:"ponto", sonora:"miolo", fricativa:"nuança" },
  lembranca:{ surda:"nota", sonora:"memória", fricativa:"recordação" },
  demora:{ surda:"pausa", sonora:"espera", fricativa:"suspensão" },
  intervalo:{ surda:"corte", sonora:"entre", fricativa:"fresta" },
  eco:{ surda:"toque", sonora:"resposta", fricativa:"ressonância" },
  resto:{ surda:"ruga", sonora:"sobra", fricativa:"resíduo" },
  plano:{ surda:"linha", sonora:"base", fricativa:"superfície" },
  camada:{ surda:"capa", sonora:"nível", fricativa:"espessura" },
  textura:{ surda:"trama", sonora:"tecido", fricativa:"fibra" },
  superficie:{ surda:"pele", sonora:"face", fricativa:"película" },
  escala:{ surda:"passo", sonora:"medida", fricativa:"proporção" },
  ritmo:{ surda:"pulso", sonora:"cadência", fricativa:"fluência" },
  materia:{ surda:"corpo", sonora:"substância", fricativa:"massa" },
  presenca:{ surda:"toque", sonora:"vulto", fricativa:"sombra" },
  tensao:{ surda:"nó", sonora:"peso", fricativa:"pressão" },
  campo:{ surda:"plano", sonora:"território", fricativa:"ambiente" },
  emergencia:{ surda:"salto", sonora:"aparição", fricativa:"insurgência" },
  configuracao:{ surda:"forma", sonora:"estrutura", fricativa:"composição" },
  cessacao:{ surda:"corte", sonora:"encerramento", fricativa:"silenciamento" },

  /* VERBOS (29–50) */
  aproximar:{ surda:"chegar", sonora:"beirar", fricativa:"esfumar" },
  reparar:{ surda:"notar", sonora:"observar", fricativa:"esmiuçar" },
  tocar:{ surda:"tatear", sonora:"roçar", fricativa:"aflorar" },
  escutar:{ surda:"ouvir", sonora:"acolher", fricativa:"sintonizar" },
  demorar_v:{ surda:"parar", sonora:"permanecer", fricativa:"alongar-se" },
  pousar:{ surda:"cair", sonora:"assentar", fricativa:"deslizar" },
  acompanhar:{ surda:"seguir", sonora:"amparar", fricativa:"entrelaçar" },
  cuidar:{ surda:"zelar", sonora:"nutrir", fricativa:"suavizar" },

  recortar:{ surda:"cortar", sonora:"delimitar", fricativa:"fissurar" },
  deslocar:{ surda:"mover", sonora:"transferir", fricativa:"deslizar" },
  sustentar:{ surda:"segurar", sonora:"manter", fricativa:"suspender" },
  distribuir:{ surda:"partir", sonora:"organizar", fricativa:"espalhar" },
  sobrepor:{ surda:"cobrir", sonora:"acumular", fricativa:"sobrefluir" },
  atravessar:{ surda:"passar", sonora:"cruzar", fricativa:"permeiar" },
  insinuar:{ surda:"sugerir", sonora:"indicar", fricativa:"sussurrar" },

  insistir:{ surda:"bater", sonora:"persistir", fricativa:"ressoar" },
  interromper:{ surda:"cortar", sonora:"cessar", fricativa:"esvair-se" },
  fixar:{ surda:"marcar", sonora:"estabelecer", fricativa:"sedimentar" },
  suspender:{ surda:"parar", sonora:"reter", fricativa:"flutuar" },
  reter:{ surda:"prender", sonora:"guardar", fricativa:"conservar" },
  abandonar:{ surda:"largar", sonora:"deixar", fricativa:"dissolver" },
  transformar:{ surda:"romper", sonora:"converter", fricativa:"transfigurar" },

  /* ADJETIVOS (51–62) */
  leve:{ surda:"claro", sonora:"brando", fricativa:"suave" },
  minimo:{ surda:"curto", sonora:"pequeno", fricativa:"sutil" },
  fragil:{ surda:"ténue", sonora:"delicado", fricativa:"sensível" },
  tenue:{ surda:"fino", sonora:"delgado", fricativa:"esfumado" },
  quase_adj:{ surda:"breve", sonora:"próximo", fricativa:"difuso" },

  opaco:{ surda:"denso", sonora:"turvo", fricativa:"fosco" },
  poroso:{ surda:"aberto", sonora:"vazado", fricativa:"permeável" },
  irregular:{ surda:"torto", sonora:"instável", fricativa:"assimétrico" },
  difuso:{ surda:"solto", sonora:"amplo", fricativa:"disperso" },

  latente:{ surda:"oculto", sonora:"presente", fricativa:"subjacente" },
  instavel:{ surda:"quebrado", sonora:"oscilante", fricativa:"flutuante" },
  provisorio:{ surda:"breve", sonora:"mutável", fricativa:"transitório" },

  /* ADVÉRBIOS (63–70) */
  ainda:{ surda:"já", sonora:"agora", fricativa:"sempre" },
  quase_adv:{ surda:"logo", sonora:"perto", fricativa:"talvez" },
  lentamente:{ surda:"aos poucos", sonora:"com calma", fricativa:"suavemente" },
  por_vezes:{ surda:"às vezes", sonora:"frequentemente", fricativa:"ocasionalmente" },
  sempre:{ surda:"toda vez", sonora:"continuamente", fricativa:"infinitamente" },
  raramente:{ surda:"quase nunca", sonora:"poucas vezes", fricativa:"esporadicamente" },
  talvez:{ surda:"quem sabe", sonora:"possivelmente", fricativa:"eventualmente" },
  agora:{ surda:"já", sonora:"neste momento", fricativa:"presentemente" },
};

const OPS = [
  /* substantivos */
  ["vestigio","N"],["sopro","N"],["dobra","N"],["canto","N"],["margem","N"],["poeira","N"],["silencio","N"],["rastro","N"],["fragmento","N"],["detalhe","N"],
  ["lembranca","N"],["demora","N"],["intervalo","N"],["eco","N"],["resto","N"],
  ["plano","N"],["camada","N"],["textura","N"],["superficie","N"],["escala","N"],["ritmo","N"],["materia","N"],
  ["presenca","N"],["tensao","N"],["campo","N"],["emergencia","N"],["configuracao","N"],["cessacao","N"],

  /* verbos */
  ["aproximar","V"],["reparar","V"],["tocar","V"],["escutar","V"],["demorar_v","V"],["pousar","V"],["acompanhar","V"],["cuidar","V"],
  ["recortar","V"],["deslocar","V"],["sustentar","V"],["distribuir","V"],["sobrepor","V"],["atravessar","V"],["insinuar","V"],
  ["insistir","V"],["interromper","V"],["fixar","V"],["suspender","V"],["reter","V"],["abandonar","V"],["transformar","V"],

  /* adjetivos */
  ["leve","ADJ"],["minimo","ADJ"],["fragil","ADJ"],["tenue","ADJ"],["quase_adj","ADJ"],
  ["opaco","ADJ"],["poroso","ADJ"],["irregular","ADJ"],["difuso","ADJ"],
  ["latente","ADJ"],["instavel","ADJ"],["provisorio","ADJ"],

  /* advérbios */
  ["ainda","ADV"],["quase_adv","ADV"],["lentamente","ADV"],["por_vezes","ADV"],["sempre","ADV"],["raramente","ADV"],["talvez","ADV"],["agora","ADV"],
];

/* ======================================================
   4) Gramática visual (12 famílias) — “langue” do campo
====================================================== */
const FAMS = [
  {id:"F1", name:"continuidade linear", axes:{front:-0.2,dense:-0.1,cont:+0.8}},
  {id:"F2", name:"corte vertical",      axes:{front:+0.3,dense:+0.2,cont:-0.8}},
  {id:"F3", name:"deslocamento oblíquo",axes:{front:+0.5,dense:-0.1,cont:+0.2}},
  {id:"F4", name:"ritmo repetitivo",    axes:{front:0.0,dense:+0.2,cont:+0.6}},
  {id:"F5", name:"ruptura",             axes:{front:+0.2,dense:+0.3,cont:-0.9}},
  {id:"F6", name:"densidade",           axes:{front:+0.1,dense:+0.9,cont:-0.2}},
  {id:"F7", name:"rarefação",           axes:{front:-0.3,dense:-0.9,cont:+0.4}},
  {id:"F8", name:"centro instável",     axes:{front:+0.2,dense:+0.5,cont:+0.1}},
  {id:"F9", name:"campo homogêneo",     axes:{front:+0.1,dense:-0.2,cont:-0.5}},
  {id:"F10",name:"direção múltipla",    axes:{front:+0.4,dense:-0.2,cont:-0.6}},
  {id:"F11",name:"contorno",            axes:{front:-0.1,dense:+0.6,cont:+0.2}},
  {id:"F12",name:"massa",               axes:{front:-0.1,dense:+0.8,cont:-0.4}},
];

function slotId(i){ return "slot_" + String(i).padStart(3,"0"); }

const FIELD = { slots:[] };
let SUI_MAP = null;

function buildField(){
  FIELD.slots = [];
  for(let i=1;i<=120;i++){
    const fam = FAMS[(i-1)%12];
    const v = Math.floor((i-1)/12) % 10;
    const t = (v-4.5)/4.5;
    const axes = {
      front: clamp(fam.axes.front + 0.18*t + rnd(-0.03,0.03), -1, 1),
      dense: clamp(fam.axes.dense + 0.22*t + rnd(-0.03,0.03), -1, 1),
      cont:  clamp(fam.axes.cont  - 0.20*t + rnd(-0.03,0.03), -1, 1),
    };
    FIELD.slots.push({ id:slotId(i), idx:i, fam:fam.id, famName:fam.name, v, axes, sui:null });
  }
}

async function tryLoadSui(){
  try{
    const res = await fetch(SUI_JSON_URL + "?cache=" + Date.now());
    if(!res.ok) throw new Error("sui.json não carregou");
    const data = await res.json(); // ex: { "53": "assets/sui/slot_053.jpg" }
    SUI_MAP = data;

    for(const s of FIELD.slots){
      const key = String(s.idx);
      if(SUI_MAP && SUI_MAP[key]){
        const rel = SUI_MAP[key]; // "assets/sui/slot_053.jpg"
        s.sui = { path: (BASE_MOBILES + rel.replace(/^\.?\/*/, "")) };
      }
    }
  }catch(e){
    SUI_MAP = null;
  }
}

/* ======================================================
   5) Estado global (tensivo + fonográfico)
====================================================== */
const G = {
  front: 0.0,   // -1 fundo / +1 frente
  dense: 0.0,   // -1 rarefeito / +1 denso
  cont:  0.0,   // -1 corte / +1 continuidade
  ph: { dry:0, voiced:0, open:0 }, // surdas / sonoras / fricativas
  pressure: 0.0,
  birthMode: 0,  // 0/1/2
  collapse: 0,   // saturação em M4
};

const Mob = {
  m2:{ flip:false, verbBias:0 },
  m3:{ focus:{front:0,dense:0,cont:0}, clicks:0 },
  m4:{ clicks:0 },
  final:{ ready:false, cfg:null }
};

function applyDelta(src, d){
  G.front = clamp(G.front + (d.front||0), -1, 1);
  G.dense = clamp(G.dense + (d.dense||0), -1, 1);
  G.cont  = clamp(G.cont  + (d.cont ||0), -1, 1);
  if(d.ph){
    G.ph.dry   = clamp(G.ph.dry   + (d.ph.dry||0),   -1, 1);
    G.ph.voiced= clamp(G.ph.voiced+ (d.ph.voiced||0),-1, 1);
    G.ph.open  = clamp(G.ph.open  + (d.ph.open||0),  -1, 1);
  }
  G.pressure = clamp(G.pressure + (d.pressure||0), 0, 1.25);
}

/* ======================================================
   6) seleção de slots (com Sui “quase sempre”, mas não sempre)
   - regra: tenta garantir 1 Sui quando existir, com prob. alta
====================================================== */
function slotScore(slot){
  const dx =
    Math.abs(slot.axes.front - G.front) * 0.9 +
    Math.abs(slot.axes.dense - G.dense) * 0.7 +
    Math.abs(slot.axes.cont  - G.cont ) * 1.0;

  let score = -(dx) + rnd(-0.05,0.05);

  // favorecer Sui (slot 53), mas não cravar 100%
  if(slot.sui) score += 1.90;

  // leve acento por “pressão”
  score += (G.pressure-0.2) * 0.15;

  return score;
}

function sampleSlots(n){
  const pool = FIELD.slots.slice();
  pool.sort((a,b)=> slotScore(b)-slotScore(a));
  const top = pool.slice(0, Math.min(42, pool.length));

  // embaralhamento leve
  shuffle(top);

  let chosen = top.slice(0, n);

  // garantir 1 Sui (quando existe) com prob ~0.9
  const suiSlot = FIELD.slots.find(s=>s.sui);
  if(suiSlot){
    const hasSui = chosen.some(s=>s.sui);
    if(!hasSui && Math.random() < 0.90){
      chosen[0] = suiSlot;
    }
  }
  return chosen;
}

/* ======================================================
   7) desenho dos fragmentos
   - “langue” das 12 famílias (procedural)
   - contornos fortes (bem demarcados)
====================================================== */
function palBase(){
  // mais “horror-pastel”: pequenas variações por estado
  const bru = `rgba(140,90,160,${lerp(.10,.28, (G.dense+1)/2).toFixed(2)})`;
  const mol = `rgba(80,150,115,${lerp(.10,.26, (G.cont+1)/2).toFixed(2)})`;
  const acd = `rgba(165,185,90,${lerp(.06,.22, (G.pressure)).toFixed(2)})`;
  return {bru,mol,acd};
}

function drawScene(ctx, key, W, H){
  const {bru,mol,acd} = palBase();
  ctx.save();
  ctx.clearRect(0,0,W,H);

  // base wash
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, "rgba(255,255,255,0.22)");
  g.addColorStop(1, "rgba(255,255,255,0.06)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // “restos” atmosféricos
  ctx.fillStyle = bru;
  ctx.beginPath(); ctx.ellipse(W*0.18, H*0.20, W*0.22, H*0.18, 0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = mol;
  ctx.beginPath(); ctx.ellipse(W*0.82, H*0.22, W*0.20, H*0.16, 0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = acd;
  ctx.beginPath(); ctx.ellipse(W*0.58, H*0.86, W*0.30, H*0.18, 0,0,Math.PI*2); ctx.fill();

  ctx.globalAlpha = 1;

  // cenários mais “visíveis”
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(20,20,22,0.16)";

  if(key==="m1"){
    // berço / móbile
    ctx.strokeStyle = "rgba(20,20,22,0.18)";
    ctx.lineWidth = 2.2;

    // arco do móbile
    ctx.beginPath();
    ctx.moveTo(W*0.10, H*0.18);
    ctx.bezierCurveTo(W*0.32, H*0.08, W*0.68, H*0.08, W*0.90, H*0.18);
    ctx.stroke();

    // fios
    for(const x of [0.22,0.50,0.78]){
      ctx.beginPath();
      ctx.moveTo(W*x, H*0.18);
      ctx.lineTo(W*x, H*0.42);
      ctx.stroke();
      ctx.fillStyle="rgba(255,255,255,0.45)";
      ctx.beginPath(); ctx.arc(W*x, H*0.42, 8, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(20,20,22,0.14)";
      ctx.stroke();
      ctx.strokeStyle = "rgba(20,20,22,0.18)";
    }

    // “colchão” leve
    ctx.strokeStyle = "rgba(20,20,22,0.14)";
    ctx.beginPath();
    ctx.moveTo(W*0.06, H*0.86);
    ctx.quadraticCurveTo(W*0.50, H*0.78, W*0.94, H*0.86);
    ctx.stroke();
  }

  if(key==="m2"){
    // montanhas + pasto + animais minimal
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = "rgba(20,20,22,0.18)";

    // montanhas
    ctx.beginPath();
    ctx.moveTo(W*0.06, H*0.62);
    ctx.lineTo(W*0.22, H*0.34);
    ctx.lineTo(W*0.36, H*0.62);
    ctx.lineTo(W*0.52, H*0.30);
    ctx.lineTo(W*0.68, H*0.62);
    ctx.lineTo(W*0.82, H*0.38);
    ctx.lineTo(W*0.94, H*0.62);
    ctx.stroke();

    // linha do chão
    ctx.strokeStyle = "rgba(90,140,110,0.22)";
    ctx.beginPath();
    ctx.moveTo(W*0.04, H*0.74);
    ctx.quadraticCurveTo(W*0.50, H*0.68, W*0.96, H*0.74);
    ctx.stroke();

    // bichos (só sugestão)
    ctx.strokeStyle = "rgba(20,20,22,0.14)";
    ctx.lineWidth = 2;
    for(const x of [0.24,0.40,0.58,0.78]){
      ctx.beginPath();
      ctx.moveTo(W*x, H*0.71);
      ctx.quadraticCurveTo(W*(x+0.018), H*0.69, W*(x+0.036), H*0.71);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(W*(x+0.010), H*0.71);
      ctx.lineTo(W*(x+0.010), H*0.73);
      ctx.moveTo(W*(x+0.026), H*0.71);
      ctx.lineTo(W*(x+0.026), H*0.73);
      ctx.stroke();
    }
  }

  if(key==="m3"){
    // labirinto
    ctx.lineWidth = 3.0;
    ctx.strokeStyle = "rgba(20,20,22,0.16)";
    const pad= Math.min(W,H)*0.08;
    const x0=pad, y0=pad, x1=W-pad, y1=H-pad*1.1;

    ctx.strokeRect(x0,y0,x1-x0,y1-y0);

    ctx.lineWidth = 2.6;
    const lines = [
      [x0+pad*0.8, y0+pad*1.2, x1-pad*0.6, y0+pad*1.2],
      [x0+pad*0.8, y0+pad*2.4, x0+pad*5.2, y0+pad*2.4],
      [x0+pad*5.2, y0+pad*2.4, x0+pad*5.2, y0+pad*4.6],
      [x0+pad*2.4, y0+pad*3.6, x1-pad*2.0, y0+pad*3.6],
      [x1-pad*2.0, y0+pad*3.6, x1-pad*2.0, y1-pad*2.0],
      [x0+pad*1.6, y0+pad*4.6, x0+pad*1.6, y1-pad*1.2],
    ];
    for(const L of lines){
      ctx.beginPath(); ctx.moveTo(L[0],L[1]); ctx.lineTo(L[2],L[3]); ctx.stroke();
    }
    ctx.strokeStyle="rgba(90,140,110,0.20)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(W*0.06, H*0.92);
    ctx.quadraticCurveTo(W*0.50, H*0.86, W*0.94, H*0.92);
    ctx.stroke();
  }

  if(key==="m4"){
    // escadas “Escher” (mais marcadas)
    ctx.lineWidth = 3.2;
    ctx.strokeStyle="rgba(20,20,22,0.18)";

    const steps = [
      [[.12,.80],[.40,.58],[.72,.80],[.44,1.02]],
      [[.18,.48],[.44,.30],[.68,.48],[.42,.66]],
      [[.28,.70],[.52,.50],[.76,.70],[.52,.90]],
      [[.54,.62],[.78,.40],[.92,.54],[.68,.76]],
    ];
    for(const p of steps){
      ctx.beginPath();
      ctx.moveTo(W*p[0][0], H*p[0][1]);
      ctx.lineTo(W*p[1][0], H*p[1][1]);
      ctx.lineTo(W*p[2][0], H*p[2][1]);
      ctx.lineTo(W*p[3][0], H*p[3][1]);
      ctx.closePath();
      ctx.stroke();
    }

    // linha “resto”
    ctx.strokeStyle="rgba(140,90,160,0.20)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(W*0.08, H*0.18);
    ctx.bezierCurveTo(W*0.34, H*0.08, W*0.62, H*0.26, W*0.92, H*0.12);
    ctx.stroke();
  }

  ctx.restore();
}

function drawSlot(ctx, slot, x,y,w,h){
  // frame forte (demarcado)
  ctx.save();

  // variação leve de altura (valência)
  const dy = rnd(-10, 10) * (0.35 + (G.pressure*0.6));
  y += dy;

  // fundo
  ctx.fillStyle = "rgba(255,255,255,0.42)";
  ctx.fillRect(x,y,w,h);

  // borda dupla (mais contraste)
  ctx.lineWidth = 3.2;
  ctx.strokeStyle = "rgba(20,20,22,0.34)";
  ctx.strokeRect(x,y,w,h);
  ctx.lineWidth = 1.4;
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.strokeRect(x+1.5,y+1.5,w-3,h-3);

  // conteúdo
  if(slot.sui){
    // desenhar a imagem
    const img = slot._img;
    if(img && img.complete){
      // crop “bonito” (cover)
      const ir = img.width / img.height;
      const tr = w / h;
      let sx=0, sy=0, sw=img.width, sh=img.height;
      if(ir > tr){
        sw = img.height * tr;
        sx = (img.width - sw)/2;
      }else{
        sh = img.width / tr;
        sy = (img.height - sh)/2;
      }
      ctx.drawImage(img, sx,sy,sw,sh, x+3, y+3, w-6, h-6);

      // leve véu “mórbido”
      ctx.fillStyle = "rgba(140,90,160,0.10)";
      ctx.fillRect(x+3,y+3,w-6,h-6);
    }else{
      ctx.fillStyle="rgba(140,90,160,0.18)";
      ctx.fillRect(x+3,y+3,w-6,h-6);
      ctx.fillStyle="rgba(20,20,22,0.55)";
      ctx.font="12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
      ctx.fillText("suiornotsui", x+10, y+h/2);
    }
  }else{
    // procedural — remete às 12 famílias (langue)
    const fam = slot.fam;
    const innerX=x+6, innerY=y+6, innerW=w-12, innerH=h-12;

    // tinta conforme densidade/cont
    const inkA = lerp(0.14, 0.36, (G.dense+1)/2);
    ctx.strokeStyle = `rgba(20,20,22,${inkA.toFixed(2)})`;
    ctx.fillStyle = `rgba(255,255,255,${lerp(0.18,0.52,(G.cont+1)/2).toFixed(2)})`;

    // pequenos motivos por família
    if(fam==="F1"){
      // continuidade: linhas suaves
      ctx.lineWidth = 2.2;
      for(let i=0;i<5;i++){
        const yy = innerY + innerH*(i/4);
        ctx.beginPath();
        ctx.moveTo(innerX, yy);
        ctx.bezierCurveTo(innerX+innerW*0.35, yy-12, innerX+innerW*0.65, yy+12, innerX+innerW, yy);
        ctx.stroke();
      }
    }else if(fam==="F2"){
      // corte vertical
      ctx.lineWidth=3.2;
      for(let i=0;i<4;i++){
        const xx = innerX + innerW*(i/3);
        ctx.beginPath();
        ctx.moveTo(xx, innerY);
        ctx.lineTo(xx, innerY+innerH);
        ctx.stroke();
      }
    }else if(fam==="F3"){
      // oblíquo
      ctx.lineWidth=2.8;
      for(let i=0;i<6;i++){
        const yy = innerY + innerH*(i/5);
        ctx.beginPath();
        ctx.moveTo(innerX, yy);
        ctx.lineTo(innerX+innerW, yy - innerH*0.22);
        ctx.stroke();
      }
    }else if(fam==="F4"){
      // ritmo repetitivo
      ctx.lineWidth=2.6;
      for(let i=0;i<8;i++){
        const xx = innerX + innerW*(i/8);
        ctx.beginPath();
        ctx.arc(xx, innerY+innerH*0.55, 10, 0, Math.PI*2);
        ctx.stroke();
      }
    }else if(fam==="F5"){
      // ruptura: rachaduras
      ctx.lineWidth=2.6;
      ctx.beginPath();
      ctx.moveTo(innerX+innerW*0.10, innerY+innerH*0.20);
      ctx.lineTo(innerX+innerW*0.40, innerY+innerH*0.45);
      ctx.lineTo(innerX+innerW*0.28, innerY+innerH*0.62);
      ctx.lineTo(innerX+innerW*0.62, innerY+innerH*0.86);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(innerX+innerW*0.64, innerY+innerH*0.12);
      ctx.lineTo(innerX+innerW*0.52, innerY+innerH*0.34);
      ctx.lineTo(innerX+innerW*0.78, innerY+innerH*0.56);
      ctx.stroke();
    }else if(fam==="F6"){
      // densidade: massa de traços
      ctx.lineWidth=2;
      for(let i=0;i<42;i++){
        const xx = innerX + rnd(innerW);
        const yy = innerY + rnd(innerH);
        ctx.beginPath();
        ctx.moveTo(xx,yy);
        ctx.lineTo(xx+rnd(-22,22), yy+rnd(-22,22));
        ctx.stroke();
      }
    }else if(fam==="F7"){
      // rarefação: quase nada
      ctx.lineWidth=2.4;
      ctx.beginPath();
      ctx.arc(innerX+innerW*0.52, innerY+innerH*0.52, innerW*0.18, 0, Math.PI*2);
      ctx.stroke();
    }else if(fam==="F8"){
      // centro instável
      ctx.lineWidth=2.8;
      const cx = innerX+innerW*0.55 + rnd(-14,14);
      const cy = innerY+innerH*0.50 + rnd(-14,14);
      ctx.beginPath();
      ctx.rect(cx-innerW*0.22, cy-innerH*0.18, innerW*0.44, innerH*0.36);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(innerX, cy);
      ctx.lineTo(innerX+innerW, cy+rnd(-10,10));
      ctx.stroke();
    }else if(fam==="F9"){
      // campo homogêneo: textura quase
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = "rgba(20,20,22,0.06)";
      for(let i=0;i<120;i++){
        ctx.fillRect(innerX+rnd(innerW), innerY+rnd(innerH), 2,2);
      }
      ctx.globalAlpha = 1;
    }else if(fam==="F10"){
      // direção múltipla
      ctx.lineWidth=2.6;
      for(let i=0;i<10;i++){
        const xx = innerX + innerW*0.5;
        const yy = innerY + innerH*0.5;
        ctx.beginPath();
        ctx.moveTo(xx,yy);
        ctx.lineTo(innerX+rnd(innerW), innerY+rnd(innerH));
        ctx.stroke();
      }
    }else if(fam==="F11"){
      // contorno
      ctx.lineWidth=3.0;
      ctx.beginPath();
      ctx.roundRect(innerX+innerW*0.12, innerY+innerH*0.18, innerW*0.76, innerH*0.64, 14);
      ctx.stroke();
    }else if(fam==="F12"){
      // massa
      ctx.fillStyle = "rgba(20,20,22,0.18)";
      ctx.fillRect(innerX+innerW*0.12, innerY+innerH*0.16, innerW*0.76, innerH*0.68);
      ctx.strokeStyle="rgba(20,20,22,0.28)";
      ctx.lineWidth=2.6;
      ctx.strokeRect(innerX+innerW*0.12, innerY+innerH*0.16, innerW*0.76, innerH*0.68);
    }

    // leve “neon mofo” como resto
    ctx.strokeStyle = `rgba(90,140,110,${lerp(0.06,0.18,(G.pressure)).toFixed(2)})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(innerX, innerY+innerH*0.86);
    ctx.quadraticCurveTo(innerX+innerW*0.5, innerY+innerH*0.74, innerX+innerW, innerY+innerH*0.86);
    ctx.stroke();
  }

  ctx.restore();
}

/* ======================================================
   8) Texto gerado (voz curatorial, sempre “bom na língua”)
   - usa operadores + regime fonográfico (surda/sonora/fricativa)
====================================================== */
function phMode(){
  // dominante pelo vetor atual
  const d = G.ph.dry, v = G.ph.voiced, o = G.ph.open;
  // regra simples: maior valor define modo, neutro se tudo baixo
  const m = Math.max(Math.abs(d), Math.abs(v), Math.abs(o));
  if(m < 0.18) return "neutro";
  if(Math.abs(d)===m) return "surda";
  if(Math.abs(v)===m) return "sonora";
  return "fricativa";
}

function realize(opKey){
  const mode = phMode();
  if(mode==="neutro"){
    // neutro: escolhe “sonora” como base (mais “catálogo”)
    return LEX[opKey]?.sonora || opKey;
  }
  if(mode==="surda") return LEX[opKey]?.surda || opKey;
  if(mode==="sonora") return LEX[opKey]?.sonora || opKey;
  return LEX[opKey]?.fricativa || opKey;
}

function maybeAdj(){
  // probabilidade varia com densidade
  const p = lerp(0.30, 0.72, (G.dense+1)/2);
  if(Math.random() > p) return null;
  const keys = ["leve","minimo","fragil","tenue","quase_adj","opaco","poroso","irregular","difuso","latente","instavel","provisorio"];
  return realize(pick(keys));
}
function maybeAdv(){
  const p = lerp(0.28, 0.65, (G.cont+1)/2);
  if(Math.random() > p) return null;
  const keys = ["ainda","quase_adv","lentamente","por_vezes","sempre","raramente","talvez","agora"];
  return realize(pick(keys));
}

function pickN(keys){
  return realize(pick(keys));
}
function pickV(keys){
  return realize(pick(keys));
}

const N_SENS = ["vestigio","sopro","dobra","canto","margem","poeira","silencio","rastro","fragmento","detalhe"];
const N_MEM  = ["lembranca","demora","intervalo","eco","resto"];
const N_PLAS = ["plano","camada","textura","superficie","escala","ritmo","materia"];
const N_CUR  = ["presenca","tensao","campo","emergencia","configuracao","cessacao"];

const V_SENS = ["aproximar","reparar","tocar","escutar","demorar_v","pousar","acompanhar","cuidar"];
const V_COMP = ["recortar","deslocar","sustentar","distribuir","sobrepor","atravessar","insinuar"];
const V_DEC  = ["insistir","interromper","fixar","suspender","reter","abandonar","transformar"];

function genCuratorialLine(kind){
  // kind: "m1" "m2" "m3" "m4" "finalA" "finalB"
  const adj1 = maybeAdj();
  const adv1 = maybeAdv();

  // seleção de léxico por eixo
  const nA = (G.front>0.25) ? pickN(N_CUR) : pickN(N_SENS);
  const nB = (G.dense>0.25) ? pickN(N_PLAS) : pickN(N_MEM);
  const nC = (G.cont>0.20) ? pickN(N_SENS) : pickN(N_CUR);

  const vA = (G.cont>0.15) ? pickV(V_SENS) : pickV(V_COMP);
  const vB = (G.pressure>0.55) ? pickV(V_DEC) : pickV(V_COMP);

  // templates “catálogo”, não “oráculo”
  const T = [];

  if(kind==="m1"){
    T.push(`${INTRO_M1}\n`);
    T.push(`No começo, ${nA} aparece como ${adj1||pickN(N_PLAS)} — e isso já inclina o campo.`);
    T.push(`O que nasce aqui ${vA} ${nB}${adv1?(", "+adv1):""}.`);
    T.push(`O resto não some: ele fica como ${pickN(N_MEM)} à espera de outra tensão.`);
  }

  if(kind==="m2"){
    T.push(`${INTRO_M2}\n`);
    // S–V–O com coerência
    const subj = (Mob.m2.flip) ? nB : nA;
    const obj  = (Mob.m2.flip) ? nA : nB;
    const verb = (Math.abs(G.front) > 0.35) ? vB : vA;

    const adv2 = maybeAdv();
    const adj2 = maybeAdj();

    const s = `${subj}${adj2?(" "+adj2):""} ${verb} ${obj}${adv2?(" "+adv2):""}.`;
    T.push(s);

    T.push(`Trocar frente e fundo muda a leitura — mas não dissolve a forma.`);
    T.push(`Só quando mudas o verbo, o objeto deixa de ser destino e vira passagem.`);
  }

  if(kind==="m3"){
    T.push(`${INTRO_M3}\n`);
    T.push(`Onde tocas, ${nC} ganha relevo; onde evitas, ${pickN(N_CUR)} recua.`);
    T.push(`Insistir em ${pickN(N_PLAS)} faz ${pickN(N_SENS)} responder como estilo.`);
    T.push(`Aos poucos, a tua curadoria deixa de “escolher imagens” e começa a formar campo.`);
  }

  if(kind==="m4"){
    T.push(`${INTRO_M4}\n`);
    const mode = phMode();
    const label = (mode==="surda") ? "plosivas surdas (corte seco)" :
                  (mode==="sonora") ? "plosivas sonoras (massa e peso)" :
                  (mode==="fricativa") ? "fricativas (passagem e arranho)" :
                  "neutro (equilíbrio provisório)";
    T.push(`O regime atual: ${label}.`);
    T.push(`Quando repetes um corpo, o resto do campo se reescreve junto — até ceder.`);
    T.push(`Se satura, não é bug: é cessação como evento. E o evento deixa resto.`);
  }

  if(kind==="finalA"){
    // estilo curatorial do utilizador
    const pFront = (G.front>0.25) ? "frente / figura" : (G.front<-0.25) ? "fundo / distância" : "meio-termo";
    const pDense = (G.dense>0.25) ? "densidade / matéria" : (G.dense<-0.25) ? "rarefação / silêncio" : "medida";
    const pCont  = (G.cont>0.25) ? "continuidade / fluxo" : (G.cont<-0.25) ? "corte / decisão" : "oscilação";
    T.push(`**Estilo curatorial (o teu percurso):**`);
    T.push(`Tendência a ${pFront}, com ${pDense} e ${pCont}.`);
    T.push(`Tu privilegias ${pickN(N_PLAS)} como estrutura, e deixas ${pickN(N_MEM)} operar como resto.`);
  }

  if(kind==="finalB"){
    // texto crítico da exposição (tom catálogo)
    T.push(`**Texto crítico (da exposição):**`);
    T.push(`Esta constelação organiza ${pickN(N_PLAS)} como ${pickN(N_CUR)}, fazendo ${pickN(N_SENS)} aparecer sem se fechar em tema.`);
    T.push(`Há um trabalho de ${pickN(N_MEM)}: o que falta não é ausência — é motor.`);
    T.push(`O conjunto mantém ${pickN(N_CUR)} em estado ${maybeAdj()||pickN(["instavel","provisorio","latente"])}${maybeAdv()?(" "+maybeAdv()):""}, como quem recusa a última palavra.`);
  }

  // junta e limpa
  return T.join("\n");
}

/* texto com spans clicáveis (delegação) */
function setRichText(el, text, clickable){
  // quebra por palavras, preserva quebras de linha
  const parts = text.split(/(\s+)/);
  el.innerHTML = "";
  for(const p of parts){
    if(p.trim()===""){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    if(!clickable){
      el.appendChild(document.createTextNode(p));
      continue;
    }
    // palavras clicáveis: escolhemos “alvos” por heurística: substantivos/verbos/adjs/adv
    // aqui: qualquer token que não seja só pontuação vira clicável, e decide um “traço” por proximidade do vocabulário.
    const span = document.createElement("span");
    span.className = "w";
    span.textContent = p;
    span.dataset.token = p.toLowerCase();
    el.appendChild(span);
  }
}

/* ======================================================
   9) Interações por móbile
====================================================== */
const HITS = { m1:[], m2:[], m3:[], m4:[], final:[] };

function bindCanvasClicks(key, canvas){
  canvas.addEventListener("click", (ev)=>{
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (canvas.width / r.width);
    const y = (ev.clientY - r.top)  * (canvas.height/ r.height);
    const hits = HITS[key] || [];
    const hit = hits.find(h => x>=h.x && x<=h.x+h.w && y>=h.y && y<=h.y+h.h);
    if(!hit) return;

    try{
      if(key==="m2"){
        // clicar em fragmento também inverte (mesma regra do botão)
        doM2Swap();
        return;
      }
      if(key==="m3"){
        // intensifica o traço do slot clicado
        Mob.m3.clicks++;
        const s = hit.slot;
        // foco puxa pro eixo do slot
        applyDelta("m3", {
          front: (s.axes.front - G.front) * 0.22,
          dense: (s.axes.dense - G.dense) * 0.20,
          cont:  (s.axes.cont  - G.cont ) * 0.22,
          pressure: 0.06
        });
        rerenderAll();
        return;
      }
      if(key==="m4"){
        // no M4: fragmentos NÃO clicáveis (só palavras). Ignora.
        toast("No Móbile 4, clica nas palavras.");
        return;
      }
      if(key==="final"){
        // nada
        return;
      }
      if(key==="m1"){
        // opcional: clicar nos 3 como “tensão” também
        doM1Tension();
      }
    }catch(e){
      toast("Erro no clique: ver consola");
      console.error(e);
    }
  });
}

function bindTextClicks(key, textEl){
  // delegação: clique em palavra -> inclina estado
  textEl.addEventListener("click", (ev)=>{
    const t = ev.target;
    if(!t || !t.classList || !t.classList.contains("w")) return;

    try{
      if(key==="m4"){
        // M4: corpo da linguagem. Clique reforça regime por “forma sonora” atual do campo
        // regra: token clicado reforça o regime dominante atual (surda/sonora/fricativa) e empurra o colapso
        const mode = phMode();
        if(mode==="neutro"){
          // se neutro, alterna para o que o usuário “puxa” pelo gesto: escolhemos por random ponderado
          const r = Math.random();
          if(r<0.34) applyDelta("m4",{ph:{dry:+0.28}, cont:-0.06, pressure:+0.06});
          else if(r<0.67) applyDelta("m4",{ph:{voiced:+0.28}, dense:+0.06, pressure:+0.06});
          else applyDelta("m4",{ph:{open:+0.28}, cont:+0.06, pressure:+0.06});
        }else if(mode==="surda"){
          applyDelta("m4",{ph:{dry:+0.22}, cont:-0.08, pressure:+0.06});
        }else if(mode==="sonora"){
          applyDelta("m4",{ph:{voiced:+0.22}, dense:+0.08, pressure:+0.06});
        }else{
          applyDelta("m4",{ph:{open:+0.22}, cont:+0.08, pressure:+0.06});
        }

        Mob.m4.clicks++;
        G.collapse = clamp(G.collapse + 0.14, 0, 1.4);

        // colapso catastrófico: muda regime
        if(G.collapse >= 1.0){
          G.collapse = 0.0;
          // troca brusca: inverte tendência de continuidade / corte e mexe no eixo
          applyDelta("m4", {
            front: rnd(-0.35,0.35),
            dense: rnd(-0.35,0.35),
            cont:  (G.cont>0? -0.55 : +0.55),
            ph: { dry:rnd(-0.35,0.35), voiced:rnd(-0.35,0.35), open:rnd(-0.35,0.35) },
            pressure: 0.18
          });
          toast("Colapso: o regime mudou.");
        }

        rerenderAll();
        return;
      }

      if(key==="m3"){
        // M3: foco; clique em palavra puxa um eixo
        Mob.m3.clicks++;
        // simples: alterna micro-pressões conforme o estado atual
        applyDelta("m3", {
          front: rnd(-0.10,0.10) * (G.front>=0? 1 : -1),
          dense: rnd(-0.10,0.10) * (G.dense>=0? 1 : -1),
          cont:  rnd(-0.12,0.12) * (G.cont>=0? 1 : -1),
          pressure: 0.05
        });
        rerenderAll();
        return;
      }

      if(key==="m2"){
        // clicar no texto do M2: se cair perto de verbo (heurística: qualquer palavra clique abre “fuga”)
        // “fuga”: muda verbBias, altera parâmetros
        Mob.m2.verbBias += 1;
        applyDelta("m2", { front:rnd(-0.10,0.10), cont:rnd(-0.10,0.10), pressure:0.06 });
        rerenderAll();
        return;
      }

      if(key==="m1"){
        // m1: palavra = tensão
        doM1Tension();
      }
    }catch(e){
      toast("Erro no texto: ver consola");
      console.error(e);
    }
  });
}

/* ======================================================
   10) ações dos botões (sem quebrar)
====================================================== */
function doM1Tension(){
  // 3 modos de nascimento (0/1/2) com inclinações distintas
  G.birthMode = (G.birthMode + 1) % 3;

  if(G.birthMode===0){
    applyDelta("m1",{ front:rnd(-0.25,0.25), dense:rnd(-0.15,0.15), cont:+0.20, ph:{open:+0.12}, pressure:0.10 });
  }else if(G.birthMode===1){
    applyDelta("m1",{ front:+0.28, dense:+0.10, cont:-0.25, ph:{dry:+0.16}, pressure:0.12 });
  }else{
    applyDelta("m1",{ front:-0.28, dense:-0.10, cont:+0.05, ph:{voiced:+0.16}, pressure:0.12 });
  }

  rerenderAll();
}

function doM2Swap(){
  Mob.m2.flip = !Mob.m2.flip;
  applyDelta("m2", { front: Mob.m2.flip ? -0.55 : +0.55, cont: 0.10, pressure:0.14 });
  rerenderAll();
}

function renderFinal(){
  // gera 10 slots + texto (duas partes + encerramento + convite)
  const slots = sampleSlots(10);
  Mob.final.cfg = { slots };
  Mob.final.ready = true;

  rerenderFinal();
  toast("Exposição gerada.");
}

function resetAll(){
  G.front=0; G.dense=0; G.cont=0; G.pressure=0;
  G.ph={dry:0,voiced:0,open:0};
  G.birthMode=0; G.collapse=0;
  Mob.m2={ flip:false, verbBias:0 };
  Mob.m3={ focus:{front:0,dense:0,cont:0}, clicks:0 };
  Mob.m4={ clicks:0 };
  Mob.final={ ready:false, cfg:null };
}

/* ======================================================
   11) Render geral (m1..final)
====================================================== */
function drawMobile(canvas, key, count){
  const ctx=canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;

  drawScene(ctx, key, W, H);

  const slots = sampleSlots(count);

  // pré-carregar imagem sui (slot 53)
  for(const s of slots){
    if(s.sui && !s._img){
      const img = new Image();
      img.crossOrigin="anonymous";
      img.src = s.sui.path + "?cache=" + Date.now();
      s._img = img;
      img.onload = ()=> rerenderAll();
    }
  }

  // layout por key (com perspectiva)
  const hits = [];
  if(key==="m1"){
    // 3 pendurados
    const w = W*0.22;
    const h = H*0.30;
    const xs = [W*0.18, W*0.50, W*0.82];
    const ys = [H*0.40, H*0.40, H*0.40];
    for(let i=0;i<3;i++){
      const x = xs[i]-w/2;
      const y = ys[i]-h/2;
      drawSlot(ctx, slots[i], x,y,w,h);
      hits.push({x,y,w,h,slot:slots[i]});
    }
  }else if(key==="m2"){
    // 2 com profundidade
    const bigW=W*0.36, bigH=H*0.42;
    const smallW=W*0.26, smallH=H*0.30;

    const frontSlot = Mob.m2.flip ? slots[1] : slots[0];
    const backSlot  = Mob.m2.flip ? slots[0] : slots[1];

    // fundo
    let xB=W*0.62 - smallW/2;
    let yB=H*0.48 - smallH/2;
    drawSlot(ctx, backSlot, xB,yB,smallW,smallH);
    hits.push({x:xB,y:yB,w:smallW,h:smallH,slot:backSlot});

    // frente
    let xF=W*0.32 - bigW/2;
    let yF=H*0.58 - bigH/2;
    drawSlot(ctx, frontSlot, xF,yF,bigW,bigH);
    hits.push({x:xF,y:yF,w:bigW,h:bigH,slot:frontSlot});
  }else if(key==="m3"){
    // 7 espalhados no labirinto
    const baseW=W*0.20, baseH=H*0.26;
    for(let i=0;i<7;i++){
      const s=slots[i];
      const x = W*(0.16 + (i%4)*0.22) + rnd(-18,18);
      const y = H*(0.26 + Math.floor(i/4)*0.34) + rnd(-18,18);
      const w = baseW * lerp(0.88, 1.18, (s.axes.front+1)/2);
      const h = baseH * lerp(0.88, 1.15, (s.axes.dense+1)/2);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  }else if(key==="m4"){
    // 5 nas escadas
    const baseW=W*0.22, baseH=H*0.28;
    const pos = [
      [0.18,0.70],[0.36,0.46],[0.56,0.70],[0.72,0.44],[0.46,0.30]
    ];
    for(let i=0;i<5;i++){
      const s=slots[i];
      const x = W*pos[i][0];
      const y = H*pos[i][1];
      const w = baseW * lerp(0.90,1.10,(s.axes.front+1)/2);
      const h = baseH * lerp(0.90,1.10,(s.axes.dense+1)/2);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  }else if(key==="final"){
    // 10 em constelação
    const baseW=W*0.19, baseH=H*0.24;
    for(let i=0;i<10;i++){
      const s=slots[i];
      const x = W*(0.10 + (i%5)*0.18) + rnd(-10,10);
      const y = H*(0.18 + Math.floor(i/5)*0.34) + rnd(-10,10);
      const w = baseW * lerp(0.92,1.18,(s.axes.front+1)/2);
      const h = baseH * lerp(0.92,1.16,(s.axes.dense+1)/2);
      drawSlot(ctx, s, x, y, w, h);
      hits.push({x,y,w,h,slot:s});
    }
  }

  HITS[key] = hits;
}

function rerenderM1(){
  const c=document.getElementById("m1Canvas");
  drawMobile(c,"m1",3);
  const text = genCuratorialLine("m1");
  setRichText(document.getElementById("m1Text"), text, true);
}
function rerenderM2(){
  const c=document.getElementById("m2Canvas");
  drawMobile(c,"m2",2);
  const text = genCuratorialLine("m2");
  setRichText(document.getElementById("m2Text"), text, true);
}
function rerenderM3(){
  const c=document.getElementById("m3Canvas");
  drawMobile(c,"m3",7);
  const text = genCuratorialLine("m3");
  setRichText(document.getElementById("m3Text"), text, true);
}
function rerenderM4(){
  const c=document.getElementById("m4Canvas");
  drawMobile(c,"m4",5);
  const text = genCuratorialLine("m4");
  // M4: só palavras clicáveis (ok)
  setRichText(document.getElementById("m4Text"), text, true);
}

function rerenderFinal(){
  const c=document.getElementById("finalCanvas");
  const ctx=c.getContext("2d");
  const W=c.width,H=c.height;

  drawScene(ctx,"final",W,H);

  const slots = (Mob.final.cfg?.slots) ? Mob.final.cfg.slots : sampleSlots(10);
  // pré-carrega sui se vier
  for(const s of slots){
    if(s.sui && !s._img){
      const img=new Image(); img.crossOrigin="anonymous";
      img.src=s.sui.path + "?cache=" + Date.now();
      s._img=img;
      img.onload=()=>rerenderFinal();
    }
  }

  // desenha constelação
  HITS.final = [];
  const baseW=W*0.19, baseH=H*0.22;
  for(let i=0;i<10;i++){
    const s=slots[i];
    const x = W*(0.08 + (i%5)*0.18) + rnd(-10,10);
    const y = H*(0.16 + Math.floor(i/5)*0.34) + rnd(-10,10);
    const w = baseW * lerp(0.92,1.18,(s.axes.front+1)/2);
    const h = baseH * lerp(0.92,1.16,(s.axes.dense+1)/2);
    drawSlot(ctx, s, x, y, w, h);
    HITS.final.push({x,y,w,h,slot:s});
  }

  // texto final
  const A = genCuratorialLine("finalA");
  const B = genCuratorialLine("finalB");
  const shareInvite =
`Partilha a tua exposição.
Cada percurso faz emergir obras diferentes.
Outras pessoas verão imagens que talvez nunca tenhas conseguido alcançar.

E você — o que montaria aqui?
https://negativo-mov.github.io/negativo.mov/mobiles/entrada/`;

  const full =
`${A}\n\n${B}\n\n${TEXT_FINAL_CLOSING}\n\n${shareInvite}`;

  setRichText(document.getElementById("finalText"), full, false);

  document.getElementById("weeklyGate").textContent =
`Para ver os demais estados expositivos da semana, faz primeiro a tua curadoria (gera a tua expo).`;
}

function rerenderAll(){
  rerenderM1();
  rerenderM2();
  rerenderM3();
  rerenderM4();
  if(Mob.final.ready) rerenderFinal();
}

/* ======================================================
   12) Partilha (imagem + texto + link)
====================================================== */
const ShareUI = (function(){
  const overlay = document.getElementById("overlay");
  const titleEl = document.getElementById("shareTitle");
  const noteEl  = document.getElementById("shareNote");
  const canvas  = document.getElementById("shareCanvas");
  const pre     = document.getElementById("shareText");
  const btnCopy = document.getElementById("copyText");
  const btnDl   = document.getElementById("downloadImg");
  const btnShare= document.getElementById("nativeShare");
  const btnClose= document.getElementById("closeDlg");

  let payload=null;

  btnClose.onclick = ()=> overlay.classList.remove("on");
  overlay.addEventListener("click",(e)=>{ if(e.target===overlay) overlay.classList.remove("on"); });

  btnCopy.onclick = async ()=>{
    if(!payload) return;
    try{
      await navigator.clipboard.writeText(payload.text);
      toast("Texto copiado.");
    }catch(e){ toast("Não consegui copiar."); }
  };

  btnDl.onclick = ()=>{
    if(!payload) return;
    const a=document.createElement("a");
    a.download = payload.filename;
    a.href = canvas.toDataURL("image/png");
    a.click();
    toast("Imagem baixada.");
  };

  btnShare.onclick = async ()=>{
    if(!payload) return;
    if(!navigator.share){
      toast("Partilha nativa não disponível aqui.");
      return;
    }
    try{
      if(payload.file && navigator.canShare && navigator.canShare({files:[payload.file]})){
        await navigator.share({ title:payload.title, text:payload.text, files:[payload.file] });
      }else{
        await navigator.share({ title:payload.title, text:payload.text });
      }
      toast("Partilhado.");
    }catch(e){
      // usuário cancelou etc.
      toast("Partilha cancelada.");
    }
  };

  function open(p){
    payload=p;
    titleEl.textContent = p.title;
    noteEl.textContent  = p.note || "";
    pre.textContent = p.text;
    // já desenhado no canvas externo
    overlay.classList.add("on");
  }

  return { open, canvas };
})();

function exportCompositePNG(srcCanvas, label, text){
  const out = ShareUI.canvas;
  const ctx = out.getContext("2d");
  const W=out.width, H=out.height;
  ctx.clearRect(0,0,W,H);

  // fundo
  ctx.fillStyle="#fbfaf8";
  ctx.fillRect(0,0,W,H);

  // cabeçalho
  ctx.fillStyle="rgba(20,20,22,0.82)";
  ctx.font="700 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("MÓBILES — suiornotsui", 70, 56);

  ctx.fillStyle="rgba(20,20,22,0.56)";
  ctx.font="14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(label, 70, 78);
  ctx.fillText(nowISO(), 70, 98);

  // imagem
  const pad=70;
  const targetW = W - pad*2;
  const ratio = srcCanvas.height/srcCanvas.width;
  const targetH = Math.min(H*0.60, targetW*ratio);
  const dx=(W-targetW)/2;
  const dy=130;
  ctx.drawImage(srcCanvas, dx, dy, targetW, targetH);

  // texto
  ctx.fillStyle="rgba(20,20,22,0.78)";
  ctx.font="16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";

  const lines = text.split("\n").slice(0,10);
  let ty = dy + targetH + 46;
  for(const ln of lines){
    ctx.fillText(ln, pad, ty);
    ty += 24;
    if(ty > H-60) break;
  }

  // rodapé/link
  ctx.fillStyle="rgba(20,20,22,0.55)";
  ctx.font="13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Faz a tua curadoria: https://negativo-mov.github.io/negativo.mov/mobiles/entrada/", pad, H-34);

  return out;
}

async function canvasToFile(canvas, filename){
  return new Promise((resolve)=>{
    canvas.toBlob((blob)=>{
      if(!blob) return resolve({file:null,blob:null});
      resolve({ file: new File([blob], filename, {type:"image/png"}), blob });
    },"image/png",0.92);
  });
}

async function shareFrom(key){
  const map = {
    m1:{ canvasId:"m1Canvas", label:"Móbile 1 — Nascimento do campo", textId:"m1Text" },
    m2:{ canvasId:"m2Canvas", label:"Móbile 2 — Estrutura e posição", textId:"m2Text" },
    m3:{ canvasId:"m3Canvas", label:"Móbile 3 — Formação do gesto", textId:"m3Text" },
    m4:{ canvasId:"m4Canvas", label:"Móbile 4 — Corpo da linguagem", textId:"m4Text" },
    final:{ canvasId:"finalCanvas", label:"Estado alcançado — Exposição provisória", textId:"finalText" },
  }[key];

  const c = document.getElementById(map.canvasId);
  const t = document.getElementById(map.textId).innerText || "";

  const shareText =
`${map.label}

${t}

E você?
Faz a tua curadoria:
https://negativo-mov.github.io/negativo.mov/mobiles/entrada/`;

  const out = exportCompositePNG(c, map.label, shareText);
  const {file} = await canvasToFile(out, `mobiles_${key}.png`);

  // tenta share direto
  const canNativeFileShare = !!(navigator.share && navigator.canShare && file && navigator.canShare({files:[file]}));

  if(navigator.share){
    try{
      if(canNativeFileShare){
        await navigator.share({ title:"MÓBILES — suiornotsui", text:shareText, files:[file] });
        toast("Partilhado.");
        return;
      }else{
        // share só texto
        await navigator.share({ title:"MÓBILES — suiornotsui", text:shareText });
        toast("Partilhado.");
        return;
      }
    }catch(e){
      // cai pro modal
    }
  }

  ShareUI.open({
    title:`Partilhar — ${map.label}`,
    note: canNativeFileShare ? "Partilha nativa com imagem + texto disponível." : "Se a partilha nativa não aceitar ficheiros, baixa a imagem e copia o texto.",
    text: shareText,
    filename: `mobiles_${key}.png`,
    file
  });
}

/* ======================================================
   13) BOOT + binds
====================================================== */
function bindAll(){
  // textos
  document.getElementById("openingText").textContent = TEXT_OPENING;

  // botões
  document.getElementById("m1Tension").onclick = ()=>{ try{ doM1Tension(); }catch(e){ console.error(e); toast("Erro no M1"); } };
  document.getElementById("m2Swap").onclick    = ()=>{ try{ doM2Swap(); }catch(e){ console.error(e); toast("Erro no M2"); } };
  document.getElementById("btnFinalize").onclick = ()=>{ try{ renderFinal(); }catch(e){ console.error(e); toast("Erro ao gerar expo"); } };

  document.getElementById("m1Share").onclick = ()=>shareFrom("m1");
  document.getElementById("m2Share").onclick = ()=>shareFrom("m2");
  document.getElementById("m3Share").onclick = ()=>shareFrom("m3");
  document.getElementById("m4Share").onclick = ()=>shareFrom("m4");
  document.getElementById("finalShare").onclick = ()=>shareFrom("final");

  // cliques canvas
  bindCanvasClicks("m1", document.getElementById("m1Canvas"));
  bindCanvasClicks("m2", document.getElementById("m2Canvas"));
  bindCanvasClicks("m3", document.getElementById("m3Canvas"));
  bindCanvasClicks("m4", document.getElementById("m4Canvas"));
  bindCanvasClicks("final", document.getElementById("finalCanvas"));

  // cliques texto
  bindTextClicks("m1", document.getElementById("m1Text"));
  bindTextClicks("m2", document.getElementById("m2Text"));
  bindTextClicks("m3", document.getElementById("m3Text"));
  bindTextClicks("m4", document.getElementById("m4Text"));
}

(async function boot(){
  try{
    buildField();
    await tryLoadSui();
    resetAll();
    bindAll();
    rerenderAll();
    toast(SUI_MAP ? "sui.json carregado." : "sui.json não carregou (sem override Sui).");
  }catch(e){
    console.error(e);
    toast("Boot falhou: ver consola.");
  }
})();
</script>
</body>
</html>
